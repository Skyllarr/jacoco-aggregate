<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AcmeClientSpi.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">WildFly Elytron</a> &gt; <a href="../index.html" class="el_bundle">wildfly-elytron-x500-cert-acme</a> &gt; <a href="index.source.html" class="el_package">org.wildfly.security.x500.cert.acme</a> &gt; <span class="el_source">AcmeClientSpi.java</span></div><h1>AcmeClientSpi.java</h1><pre class="source lang-java linenums">/*
 * JBoss, Home of Professional Open Source.
 * Copyright 2018 Red Hat, Inc., and individual contributors
 * as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package org.wildfly.security.x500.cert.acme;

import static org.wildfly.security.x500.cert.acme.Acme.ACCEPT_LANGUAGE;
import static org.wildfly.security.x500.cert.acme.Acme.ACCOUNT;
import static org.wildfly.security.x500.cert.acme.Acme.ALG;
import static org.wildfly.security.x500.cert.acme.Acme.AUTHORIZATION;
import static org.wildfly.security.x500.cert.acme.Acme.AUTHORIZATIONS;
import static org.wildfly.security.x500.cert.acme.Acme.BAD_NONCE;
import static org.wildfly.security.x500.cert.acme.Acme.BASE64_URL;
import static org.wildfly.security.x500.cert.acme.Acme.CAA_IDENTITIES;
import static org.wildfly.security.x500.cert.acme.Acme.CERTIFICATE;
import static org.wildfly.security.x500.cert.acme.Acme.CHALLENGES;
import static org.wildfly.security.x500.cert.acme.Acme.CONTACT;
import static org.wildfly.security.x500.cert.acme.Acme.CONTENT_TYPE;
import static org.wildfly.security.x500.cert.acme.Acme.CSR;
import static org.wildfly.security.x500.cert.acme.Acme.DEACTIVATED;
import static org.wildfly.security.x500.cert.acme.Acme.DETAIL;
import static org.wildfly.security.x500.cert.acme.Acme.DNS;
import static org.wildfly.security.x500.cert.acme.Acme.EXTERNAL_ACCOUNT_REQUIRED;
import static org.wildfly.security.x500.cert.acme.Acme.FINALIZE;
import static org.wildfly.security.x500.cert.acme.Acme.GET;
import static org.wildfly.security.x500.cert.acme.Acme.HEAD;
import static org.wildfly.security.x500.cert.acme.Acme.IDENTIFIER;
import static org.wildfly.security.x500.cert.acme.Acme.IDENTIFIERS;
import static org.wildfly.security.x500.cert.acme.Acme.INSTANCE;
import static org.wildfly.security.x500.cert.acme.Acme.INVALID;
import static org.wildfly.security.x500.cert.acme.Acme.JOSE_JSON_CONTENT_TYPE;
import static org.wildfly.security.x500.cert.acme.Acme.JSON_CONTENT_TYPE;
import static org.wildfly.security.x500.cert.acme.Acme.JWK;
import static org.wildfly.security.x500.cert.acme.Acme.KID;
import static org.wildfly.security.x500.cert.acme.Acme.LOCATION;
import static org.wildfly.security.x500.cert.acme.Acme.META;
import static org.wildfly.security.x500.cert.acme.Acme.NONCE;
import static org.wildfly.security.x500.cert.acme.Acme.OLD_KEY;
import static org.wildfly.security.x500.cert.acme.Acme.ONLY_RETURN_EXISTING;
import static org.wildfly.security.x500.cert.acme.Acme.ORDER;
import static org.wildfly.security.x500.cert.acme.Acme.PAYLOAD;
import static org.wildfly.security.x500.cert.acme.Acme.PEM_CERTIFICATE_CHAIN_CONTENT_TYPE;
import static org.wildfly.security.x500.cert.acme.Acme.PENDING;
import static org.wildfly.security.x500.cert.acme.Acme.POST;
import static org.wildfly.security.x500.cert.acme.Acme.PROBLEM_JSON_CONTENT_TYPE;
import static org.wildfly.security.x500.cert.acme.Acme.PROTECTED;
import static org.wildfly.security.x500.cert.acme.Acme.RATE_LIMITED;
import static org.wildfly.security.x500.cert.acme.Acme.REASON;
import static org.wildfly.security.x500.cert.acme.Acme.REPLAY_NONCE;
import static org.wildfly.security.x500.cert.acme.Acme.RETRY_AFTER;
import static org.wildfly.security.x500.cert.acme.Acme.STATUS;
import static org.wildfly.security.x500.cert.acme.Acme.SUBPROBLEMS;
import static org.wildfly.security.x500.cert.acme.Acme.TERMS_OF_SERVICE;
import static org.wildfly.security.x500.cert.acme.Acme.TOKEN;
import static org.wildfly.security.x500.cert.acme.Acme.URL;
import static org.wildfly.security.x500.cert.acme.Acme.SIGNATURE;
import static org.wildfly.security.x500.cert.acme.Acme.TERMS_OF_SERVICE_AGREED;
import static org.wildfly.security.x500.cert.acme.Acme.TITLE;
import static org.wildfly.security.x500.cert.acme.Acme.TYPE;
import static org.wildfly.security.x500.cert.acme.Acme.USER_ACTION_REQUIRED;
import static org.wildfly.security.x500.cert.acme.Acme.USER_AGENT;
import static org.wildfly.security.x500.cert.acme.Acme.VALID;
import static org.wildfly.security.x500.cert.acme.Acme.VALUE;
import static org.wildfly.security.x500.cert.acme.Acme.WEBSITE;
import static org.wildfly.security.x500.cert.acme.Acme.base64UrlEncode;
import static org.wildfly.security.x500.cert.acme.Acme.getAlgHeaderFromSignatureAlgorithm;
import static org.wildfly.security.x500.cert.acme.Acme.getJwk;
import static org.wildfly.security.x500.cert.acme.ElytronMessages.acme;
import static org.wildfly.security.x500.cert.util.KeyUtil.getDefaultCompatibleSignatureAlgorithmName;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.IDN;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Signature;
import java.security.SignatureException;
import java.security.cert.CRLReason;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.interfaces.ECPrivateKey;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import javax.json.Json;
import javax.json.JsonArray;
import javax.json.JsonArrayBuilder;
import javax.json.JsonObject;
import javax.json.JsonObjectBuilder;
import javax.json.JsonReader;
import javax.json.JsonString;
import javax.security.auth.x500.X500Principal;

import org.wildfly.common.Assert;
import org.wildfly.common.iteration.CodePointIterator;
import org.wildfly.security.Version;
import org.wildfly.security.asn1.ASN1Encodable;
import org.wildfly.security.asn1.DERDecoder;
import org.wildfly.security.x500.GeneralName;
import org.wildfly.security.x500.X500;
import org.wildfly.security.x500.X500AttributeTypeAndValue;
import org.wildfly.security.x500.X500PrincipalBuilder;
import org.wildfly.security.x500.cert.PKCS10CertificateSigningRequest;
import org.wildfly.security.x500.cert.SelfSignedX509CertificateAndSigningKey;
import org.wildfly.security.x500.cert.SubjectAlternativeNamesExtension;
import org.wildfly.security.x500.cert.X509CertificateChainAndSigningKey;

/**
 * SPI for an &lt;a href=&quot;https://www.ietf.org/id/draft-ietf-acme-acme-14.txt&quot;&gt;Automatic Certificate Management Environment (ACME)&lt;/a&gt;
 * client provider to implement.
 *
 * @author &lt;a href=&quot;mailto:fjuma@redhat.com&quot;&gt;Farah Juma&lt;/a&gt;
 * @since 1.5.0
 */
<span class="fc" id="L148">public abstract class AcmeClientSpi {</span>

    /**
     * The default key size that will be used if the key algorithm name is EC.
     */
    public static final int DEFAULT_EC_KEY_SIZE = 256;

    /**
     * The default key size that will be used if the key algorithm name is not EC.
     */
    public static final int DEFAULT_KEY_SIZE = 2048;

    /**
     * The default key algorithm name.
     */
    public static final String DEFAULT_KEY_ALGORITHM_NAME = &quot;RSA&quot;;

    private static final int MAX_RETRIES = 10;
    private static final long DEFAULT_RETRY_AFTER_MILLI = 3000;
<span class="fc" id="L167">    private static final int[] CONTENT_TYPE_DELIMS = new int[] {';', '='};</span>
    private static final String CHARSET = &quot;charset&quot;;
    private static final String UTF_8 = &quot;utf-8&quot;;
<span class="fc" id="L170">    private static final String USER_AGENT_STRING = &quot;Elytron ACME Client/&quot; + Version.getVersion();</span>

<span class="fc" id="L172">    private static final JsonObject EMPTY_PAYLOAD = Json.createObjectBuilder().build();</span>
    private static final String EMPTY_STRING = &quot;&quot;;

    /**
     * Get the resource URLs needed to perform operations from the ACME server.
     *
     * @param account the ACME account information to use (must not be {@code null})
     * @param staging whether or not the staging server URL should be used
     * @return a map of ACME resources to URLs
     * @throws AcmeException if an error occurs while attempting to get the resource URLs from the ACME server
     */
    public Map&lt;AcmeResource, URL&gt; getResourceUrls(AcmeAccount account, boolean staging) throws AcmeException {
<span class="fc" id="L184">        Assert.checkNotNullParam(&quot;account&quot;, account);</span>
<span class="fc" id="L185">        final Map&lt;AcmeResource, URL&gt; resourceUrls = account.getResourceUrls(staging);</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">        if (resourceUrls.isEmpty()) {</span>
<span class="pc bpc" id="L187" title="3 of 4 branches missed.">            if (staging &amp;&amp; account.getServerUrl(true) == null) {</span>
<span class="nc" id="L188">                throw acme.noAcmeServerStagingUrlGiven();</span>
            }
<span class="fc" id="L190">            HttpURLConnection connection = sendGetRequest(account.getServerUrl(staging), HttpURLConnection.HTTP_OK, JSON_CONTENT_TYPE);</span>
<span class="fc" id="L191">            JsonObject directoryJson = getJsonResponse(connection);</span>
            try {
<span class="fc bfc" id="L193" title="All 2 branches covered.">                for (AcmeResource resource : AcmeResource.values()) {</span>
<span class="fc" id="L194">                    String resourceUrl = getOptionalJsonString(directoryJson, resource.getValue());</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">                    URL url = resourceUrl != null ? new URL(resourceUrl) : null;</span>
<span class="fc" id="L196">                    resourceUrls.put(resource, url);</span>
                }
<span class="nc" id="L198">            } catch (MalformedURLException e) {</span>
<span class="nc" id="L199">                throw acme.unableToRetrieveAcmeServerDirectoryUrls(e);</span>
<span class="fc" id="L200">            }</span>
        }
<span class="fc" id="L202">        return resourceUrls;</span>
    }

    /**
     * Get the metadata associated with the ACME server.
     *
     * @param account the ACME account information to use (must not be {@code null})
     * @param staging whether or not the staging server URL should be used
     * @return the metadata associated with the ACME server (may be {@code null})
     * @throws AcmeException if an error occurs while attempting to get the metadata associated with the ACME server
     */
    public AcmeMetadata getMetadata(AcmeAccount account, boolean staging) throws AcmeException {
<span class="fc" id="L214">        Assert.checkNotNullParam(&quot;account&quot;, account);</span>
<span class="pc bpc" id="L215" title="3 of 4 branches missed.">        if (staging &amp;&amp; account.getServerUrl(true) == null) {</span>
<span class="nc" id="L216">            throw acme.noAcmeServerStagingUrlGiven();</span>
        }
<span class="fc" id="L218">        HttpURLConnection connection = sendGetRequest(account.getServerUrl(staging), HttpURLConnection.HTTP_OK, JSON_CONTENT_TYPE);</span>
<span class="fc" id="L219">        JsonObject directoryJson = getJsonResponse(connection);</span>
<span class="fc" id="L220">        JsonObject metadata = directoryJson.getJsonObject(META);</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">        if (metadata == null) {</span>
<span class="fc" id="L222">            return null;</span>
        }
<span class="fc" id="L224">        AcmeMetadata.Builder metadataBuilder = AcmeMetadata.builder();</span>
<span class="fc" id="L225">        String termsOfServiceUrl = getOptionalJsonString(metadata, TERMS_OF_SERVICE);</span>
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">        if (termsOfServiceUrl != null) {</span>
<span class="fc" id="L227">            metadataBuilder.setTermsOfServiceUrl(termsOfServiceUrl);</span>
        }
<span class="fc" id="L229">        String websiteUrl = getOptionalJsonString(metadata, WEBSITE);</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">        if (websiteUrl != null) {</span>
<span class="fc" id="L231">            metadataBuilder.setWebsiteUrl(websiteUrl);</span>
        }
<span class="fc" id="L233">        JsonArray caaIdentitiesArray = metadata.getJsonArray(CAA_IDENTITIES);</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">        if (caaIdentitiesArray != null) {</span>
<span class="fc" id="L235">            final List&lt;String&gt; caaIdentities = new ArrayList&lt;&gt;(caaIdentitiesArray.size());</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">            for (JsonString caaIdentity : caaIdentitiesArray.getValuesAs(JsonString.class)) {</span>
<span class="fc" id="L237">                caaIdentities.add(caaIdentity.getString());</span>
<span class="fc" id="L238">            }</span>
<span class="fc" id="L239">            metadataBuilder.setCaaIdentities(caaIdentities.toArray(new String[caaIdentities.size()]));</span>
        }
<span class="fc" id="L241">        boolean externalAccountRequired = metadata.getBoolean(EXTERNAL_ACCOUNT_REQUIRED, false);</span>
<span class="fc" id="L242">        metadataBuilder.setExternalAccountRequired(externalAccountRequired);</span>
<span class="fc" id="L243">        return metadataBuilder.build();</span>
    }

    /**
     * Create an account with an ACME server using the given account information.
     *
     * @param account the ACME account information to use (must not be {@code null})
     * @param staging whether or not the staging server URL should be used
     * @return {@code true} if the account was created, {@code false} if the account already existed
     * @throws AcmeException if an error occurs while attempting to create or lookup an account with
     * the ACME server
     */
    public boolean createAccount(AcmeAccount account, boolean staging) throws AcmeException {
<span class="fc" id="L256">        return createAccount(account, staging, false);</span>
    }

    /**
     * Create an account with an ACME server using the given account information.
     *
     * @param account the ACME account information to use (must not be {@code null})
     * @param staging whether or not the staging server URL should be used
     * @param onlyReturnExisting {@code true} if the ACME server should not create a new account if one does not
     *                           already exist (this allows an existing account's URL to be looked up and populated
     *                           using the account key)
     * @return {@code true} if the account was created, {@code false} if the account already existed
     * @throws AcmeException if an error occurs while attempting to create or lookup an account with the ACME server
     * or if {@code onlyReturnExisting} is set to {@code true} and the account does not exist
     */
    public boolean createAccount(AcmeAccount account, boolean staging, boolean onlyReturnExisting) throws AcmeException {
<span class="fc" id="L272">        Assert.checkNotNullParam(&quot;account&quot;, account);</span>
<span class="fc" id="L273">        final String newAccountUrl = getResourceUrl(account, AcmeResource.NEW_ACCOUNT, staging).toString();</span>

<span class="fc" id="L275">        JsonObjectBuilder payloadBuilder = Json.createObjectBuilder();</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">        if (onlyReturnExisting) {</span>
<span class="fc" id="L277">            payloadBuilder.add(ONLY_RETURN_EXISTING, true);</span>
        } else {
            // create a new account
<span class="fc" id="L280">            payloadBuilder.add(TERMS_OF_SERVICE_AGREED, account.isTermsOfServiceAgreed());</span>
<span class="pc bpc" id="L281" title="2 of 4 branches missed.">            if (account.getContactUrls() != null &amp;&amp; !(account.getContactUrls().length == 0)) {</span>
<span class="fc" id="L282">                JsonArrayBuilder contactBuilder = Json.createArrayBuilder();</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">                for (String contactUrl : account.getContactUrls()) {</span>
<span class="fc" id="L284">                    contactBuilder.add(contactUrl);</span>
                }
<span class="fc" id="L286">                payloadBuilder.add(CONTACT, contactBuilder.build());</span>
            }
        }

<span class="fc" id="L290">        HttpURLConnection connection = sendPostRequestWithRetries(account, staging, newAccountUrl, true,</span>
<span class="fc" id="L291">                getEncodedJson(payloadBuilder.build()), HttpURLConnection.HTTP_CREATED, HttpURLConnection.HTTP_OK);</span>
<span class="fc" id="L292">        account.setAccountUrl(getLocation(connection, ACCOUNT));</span>
        try {
<span class="fc bfc" id="L294" title="All 2 branches covered.">            return connection.getResponseCode() == HttpURLConnection.HTTP_CREATED;</span>
<span class="nc" id="L295">        } catch (IOException e) {</span>
<span class="nc" id="L296">            throw new AcmeException(e);</span>
        }
    }

    /**
     * Update whether or not the terms of service have been agreed to for an account with an ACME server.
     *
     * @param account the ACME account information to use (must not be {@code null})
     * @param staging whether or not the staging server URL should be used
     * @param termsOfServiceAgreed the new value for whether or not the terms of service have been agreed to
     * @throws AcmeException if an error occurs while attempting to update the account
     */
    public void updateAccount(AcmeAccount account, boolean staging, boolean termsOfServiceAgreed) throws AcmeException {
<span class="nc" id="L309">        updateAccount(account, staging, termsOfServiceAgreed, null);</span>
<span class="nc" id="L310">    }</span>

    /**
     * Update the contact URLs for an account with an ACME server.
     *
     * @param account the ACME account information to use (must not be {@code null})
     * @param staging whether or not the staging server URL should be used
     * @param contactUrls the new account contact URLs
     * @throws AcmeException if an error occurs while attempting to update the account
     */
    public void updateAccount(AcmeAccount account, boolean staging, String[] contactUrls) throws AcmeException {
<span class="nc" id="L321">        updateAccount(account, staging, account.isTermsOfServiceAgreed(), contactUrls);</span>
<span class="nc" id="L322">    }</span>

    /**
     * Update an account with an ACME server using the given account information.
     *
     * @param account the ACME account information to use (must not be {@code null})
     * @param staging whether or not the staging server URL should be used
     * @param termsOfServiceAgreed the new value for whether or not the terms of service have been agreed to
     * @param contactUrls the new account contact URLs
     * @throws AcmeException if an error occurs while attempting to update the account
     */
    public void updateAccount(AcmeAccount account, boolean staging, boolean termsOfServiceAgreed, String[] contactUrls) throws AcmeException {
<span class="fc" id="L334">        Assert.checkNotNullParam(&quot;account&quot;, account);</span>
<span class="fc" id="L335">        JsonObjectBuilder payloadBuilder = Json.createObjectBuilder()</span>
<span class="fc" id="L336">                .add(TERMS_OF_SERVICE_AGREED, termsOfServiceAgreed);</span>
<span class="pc bpc" id="L337" title="1 of 4 branches missed.">        if (contactUrls != null &amp;&amp; ! (contactUrls.length == 0)) {</span>
<span class="fc" id="L338">            JsonArrayBuilder contactBuilder = Json.createArrayBuilder();</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">            for (String contactUrl : contactUrls) {</span>
<span class="fc" id="L340">                contactBuilder.add(contactUrl);</span>
            }
<span class="fc" id="L342">            payloadBuilder.add(CONTACT, contactBuilder.build());</span>
        }

<span class="fc" id="L345">        sendPostRequestWithRetries(account, staging, getAccountUrl(account, staging), false,</span>
<span class="fc" id="L346">                getEncodedJson(payloadBuilder.build()), HttpURLConnection.HTTP_OK);</span>
<span class="fc" id="L347">        account.setTermsOfServiceAgreed(termsOfServiceAgreed);</span>
<span class="pc bpc" id="L348" title="1 of 4 branches missed.">        if (contactUrls != null &amp;&amp; ! (contactUrls.length == 0)) {</span>
<span class="fc" id="L349">            account.setContactUrls(contactUrls);</span>
        }
<span class="fc" id="L351">    }</span>

    /**
     * Change the key that is associated with the given ACME account.
     *
     * @param account the ACME account information to use (must not be {@code null})
     * @param staging whether or not the staging server URL should be used
     * @throws AcmeException if an error occurs while attempting to change the key that is associated with the given ACME account
     */
    public void changeAccountKey(AcmeAccount account, boolean staging) throws AcmeException {
<span class="fc" id="L361">        Assert.checkNotNullParam(&quot;account&quot;, account);</span>
<span class="fc" id="L362">        SelfSignedX509CertificateAndSigningKey newCertificateAndSigningKey = SelfSignedX509CertificateAndSigningKey.builder()</span>
<span class="fc" id="L363">                .setKeySize(account.getKeySize())</span>
<span class="fc" id="L364">                .setKeyAlgorithmName(account.getKeyAlgorithmName())</span>
<span class="fc" id="L365">                .setDn(account.getDn())</span>
<span class="fc" id="L366">                .build();</span>
<span class="fc" id="L367">        changeAccountKey(account, staging, newCertificateAndSigningKey.getSelfSignedCertificate(), newCertificateAndSigningKey.getSigningKey());</span>
<span class="fc" id="L368">    }</span>

    /**
     * Change the key that is associated with the given ACME account.
     *
     * @param account the ACME account information to use (must not be {@code null})
     * @param staging whether or not the staging server URL should be used
     * @param certificate the new certificate to associate with the given ACME account (must not be {@code null})
     * @param privateKey the new private key to associate with the given ACME account (must not be {@code null})
     * @throws AcmeException if an error occurs while attempting to change the key that is associated with the given ACME account
     */
    public void changeAccountKey(AcmeAccount account, boolean staging, X509Certificate certificate, PrivateKey privateKey) throws AcmeException {
<span class="fc" id="L380">        Assert.checkNotNullParam(&quot;account&quot;, account);</span>
<span class="fc" id="L381">        Assert.checkNotNullParam(&quot;certificate&quot;, certificate);</span>
<span class="fc" id="L382">        Assert.checkNotNullParam(&quot;privateKey&quot;, privateKey);</span>
<span class="fc" id="L383">        final String keyChangeUrl = getResourceUrl(account, AcmeResource.KEY_CHANGE, staging).toString();</span>
<span class="fc" id="L384">        final String signatureAlgorithm = getDefaultCompatibleSignatureAlgorithmName(privateKey);</span>
<span class="fc" id="L385">        final String algHeader = getAlgHeaderFromSignatureAlgorithm(signatureAlgorithm);</span>
<span class="fc" id="L386">        final String innerEncodedProtectedHeader = getEncodedProtectedHeader(algHeader, certificate.getPublicKey(), keyChangeUrl);</span>
<span class="fc" id="L387">        JsonObjectBuilder innerPayloadBuilder = Json.createObjectBuilder()</span>
<span class="fc" id="L388">                .add(ACCOUNT, getAccountUrl(account, staging))</span>
<span class="fc" id="L389">                .add(OLD_KEY, getJwk(account.getPublicKey(), account.getAlgHeader()));</span>
<span class="fc" id="L390">        final String innerEncodedPayload = getEncodedJson(innerPayloadBuilder.build());</span>
<span class="fc" id="L391">        final String innerEncodedSignature = getEncodedSignature(privateKey, signatureAlgorithm, innerEncodedProtectedHeader, innerEncodedPayload);</span>
<span class="fc" id="L392">        final String outerEncodedPayload = getEncodedJson(getJws(innerEncodedProtectedHeader, innerEncodedPayload, innerEncodedSignature));</span>

<span class="fc" id="L394">        sendPostRequestWithRetries(account, staging, keyChangeUrl, false, outerEncodedPayload, HttpURLConnection.HTTP_OK);</span>
<span class="fc" id="L395">        account.changeCertificateAndPrivateKey(certificate, privateKey); // update account info</span>
<span class="fc" id="L396">    }</span>

    /**
     * Deactivate the given ACME account. It is not possible to reactivate an ACME account after it has
     * been deactivated.
     *
     * @param account the ACME account information to use (must not be {@code null})
     * @param staging whether or not the staging server URL should be used
     * @throws AcmeException if an error occurs while attempting to deactivate the given ACME account
     */
    public void deactivateAccount(AcmeAccount account, boolean staging) throws AcmeException {
<span class="fc" id="L407">        Assert.checkNotNullParam(&quot;account&quot;, account);</span>
<span class="fc" id="L408">        JsonObject payload = Json.createObjectBuilder()</span>
<span class="fc" id="L409">                .add(STATUS, DEACTIVATED)</span>
<span class="fc" id="L410">                .build();</span>
<span class="fc" id="L411">        sendPostRequestWithRetries(account, staging, getAccountUrl(account, staging), false, getEncodedJson(payload), HttpURLConnection.HTTP_OK);</span>
<span class="fc" id="L412">    }</span>

    /**
     * Obtain a certificate chain using the given ACME account.
     *
     * @param account the ACME account information to use (must not be {@code null})
     * @param staging whether or not the staging server URL should be used
     * @param domainNames the domain names to request the certificate for (must not be {@code null})
     * @return the X509 certificate chain and private key
     * @throws AcmeException if an occur occurs while attempting to obtain the certificate
     */
    public X509CertificateChainAndSigningKey obtainCertificateChain(AcmeAccount account, boolean staging, String... domainNames) throws AcmeException {
<span class="nc" id="L424">        return obtainCertificateChain(account, staging, null, -1, domainNames);</span>
    }

    /**
     * Obtain a certificate chain using the given ACME account.
     *
     * @param account the ACME account information to use (must not be {@code null})
     * @param staging whether or not the staging server URL should be used
     * @param keyAlgorithmName the optional key algorithm name to use when generating the key pair (may be {@code null})
     * @param keySize the optional key size to use when generating the key pair (-1 to indicate that the default key size should be used)
     * @param domainNames the domain names to request the certificate for (must not be {@code null})
     * @return the X509 certificate chain and private key
     * @throws AcmeException if an occur occurs while attempting to obtain the certificate
     */
    public X509CertificateChainAndSigningKey obtainCertificateChain(AcmeAccount account, boolean staging, String keyAlgorithmName, int keySize,
                                                                    String... domainNames) throws AcmeException {
<span class="fc" id="L440">        Assert.checkNotNullParam(&quot;account&quot;, account);</span>
<span class="fc" id="L441">        Assert.checkNotNullParam(&quot;domainNames&quot;, domainNames);</span>
<span class="fc" id="L442">        final LinkedHashSet&lt;String&gt; domainNamesSet = getDomainNames(domainNames);</span>

        // create a new order
<span class="fc" id="L445">        final String newOrderUrl = getResourceUrl(account, AcmeResource.NEW_ORDER, staging).toString();</span>
<span class="fc" id="L446">        JsonArrayBuilder identifiersBuilder = Json.createArrayBuilder();</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">        for (String domainName : domainNamesSet) {</span>
<span class="fc" id="L448">            JsonObject identifier = Json.createObjectBuilder()</span>
<span class="fc" id="L449">                    .add(TYPE, DNS)</span>
<span class="fc" id="L450">                    .add(VALUE, domainName)</span>
<span class="fc" id="L451">                    .build();</span>
<span class="fc" id="L452">            identifiersBuilder.add(identifier);</span>
<span class="fc" id="L453">        }</span>
<span class="fc" id="L454">        JsonObjectBuilder payloadBuilder = Json.createObjectBuilder()</span>
<span class="fc" id="L455">                .add(IDENTIFIERS, identifiersBuilder.build());</span>
<span class="fc" id="L456">        HttpURLConnection connection = sendPostRequestWithRetries(account, staging, newOrderUrl, false, getEncodedJson(payloadBuilder.build()), HttpURLConnection.HTTP_CREATED);</span>
<span class="fc" id="L457">        final String orderUrl = getLocation(connection, ORDER);</span>
<span class="fc" id="L458">        JsonObject jsonResponse = getJsonResponse(connection);</span>
<span class="fc" id="L459">        final String finalizeOrderUrl = jsonResponse.getString(FINALIZE);</span>
<span class="fc" id="L460">        final JsonArray authorizationsArray = jsonResponse.getJsonArray(AUTHORIZATIONS);</span>
<span class="fc" id="L461">        final List&lt;String&gt; authorizationUrls = new ArrayList&lt;&gt;(authorizationsArray.size());</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">        for (JsonString authorization : authorizationsArray.getValuesAs(JsonString.class)) {</span>
<span class="fc" id="L463">            authorizationUrls.add(authorization.getString());</span>
<span class="fc" id="L464">        }</span>

        // respond to challenges for each authorization resource
<span class="fc" id="L467">        List&lt;AcmeChallenge&gt; selectedChallenges = new ArrayList&lt;&gt;(authorizationUrls.size());</span>
        try {
<span class="fc bfc" id="L469" title="All 2 branches covered.">            for (String authorizationUrl : authorizationUrls) {</span>
<span class="fc" id="L470">                connection = sendPostAsGetRequest(account, staging, authorizationUrl, JSON_CONTENT_TYPE, HttpURLConnection.HTTP_OK);</span>
<span class="fc" id="L471">                jsonResponse = getJsonResponse(connection);</span>
<span class="fc" id="L472">                AcmeChallenge selectedChallenge = respondToChallenges(account, staging, jsonResponse);</span>
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">                if (selectedChallenge != null) {</span>
<span class="fc" id="L474">                    selectedChallenges.add(selectedChallenge);</span>
                }
<span class="fc" id="L476">            }</span>

            // poll the authorization resources until server has finished validating the challenge responses
<span class="fc bfc" id="L479" title="All 2 branches covered.">            for (String authorizationUrl : authorizationUrls) {</span>
<span class="fc" id="L480">                jsonResponse = pollResourceUntilFinalized(account, staging, authorizationUrl);</span>
<span class="pc bpc" id="L481" title="1 of 2 branches missed.">                if (! jsonResponse.getString(STATUS).equals(VALID)) {</span>
<span class="nc" id="L482">                    throw acme.challengeResponseFailedValidationByAcmeServer();</span>
                }
<span class="fc" id="L484">            }</span>

            // create and submit a CSR now that we've fulfilled the server's requirements
<span class="fc" id="L487">            List&lt;GeneralName&gt; generalNames = new ArrayList&lt;&gt;(domainNamesSet.size());</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">            for (String domainName : domainNamesSet) {</span>
<span class="fc" id="L489">                generalNames.add(new GeneralName.DNSName(domainName));</span>
<span class="fc" id="L490">            }</span>
<span class="fc" id="L491">            X500PrincipalBuilder principalBuilder = new X500PrincipalBuilder();</span>
<span class="fc" id="L492">            principalBuilder.addItem(X500AttributeTypeAndValue.create(X500.OID_AT_COMMON_NAME, ASN1Encodable.ofUtf8String(((GeneralName.DNSName) generalNames.get(0)).getName())));</span>
<span class="fc" id="L493">            X500Principal dn = principalBuilder.build();</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">            if (keyAlgorithmName == null) {</span>
<span class="fc" id="L495">                keyAlgorithmName = DEFAULT_KEY_ALGORITHM_NAME;</span>
            }
<span class="fc bfc" id="L497" title="All 2 branches covered.">            if (keySize == -1) {</span>
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">                if (keyAlgorithmName.equals(&quot;EC&quot;)) {</span>
<span class="nc" id="L499">                    keySize = DEFAULT_EC_KEY_SIZE;</span>
                } else {
<span class="fc" id="L501">                    keySize = DEFAULT_KEY_SIZE;</span>
                }
            }

<span class="fc" id="L505">            SelfSignedX509CertificateAndSigningKey selfSignedX509CertificateAndSigningKey = SelfSignedX509CertificateAndSigningKey.builder()</span>
<span class="fc" id="L506">                    .setDn(dn)</span>
<span class="fc" id="L507">                    .setKeyAlgorithmName(keyAlgorithmName)</span>
<span class="fc" id="L508">                    .setKeySize(keySize)</span>
<span class="fc" id="L509">                    .build();</span>
<span class="fc" id="L510">            PKCS10CertificateSigningRequest.Builder csrBuilder = PKCS10CertificateSigningRequest.builder()</span>
<span class="fc" id="L511">                    .setCertificate(selfSignedX509CertificateAndSigningKey.getSelfSignedCertificate())</span>
<span class="fc" id="L512">                    .setSigningKey(selfSignedX509CertificateAndSigningKey.getSigningKey())</span>
<span class="fc" id="L513">                    .setSubjectDn(dn);</span>
<span class="fc" id="L514">            csrBuilder.addExtension(new SubjectAlternativeNamesExtension(false, generalNames));</span>

<span class="fc" id="L516">            payloadBuilder = Json.createObjectBuilder()</span>
<span class="fc" id="L517">                    .add(CSR, base64UrlEncode(csrBuilder.build().getEncoded()));</span>
<span class="fc" id="L518">            connection = sendPostRequestWithRetries(account, staging, finalizeOrderUrl, false, getEncodedJson(payloadBuilder.build()), HttpURLConnection.HTTP_OK);</span>

            // poll the order resource until the server has made the certificate chain available
<span class="fc" id="L521">            jsonResponse = pollResourceUntilFinalized(account, staging, orderUrl);</span>
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">            if (! jsonResponse.getString(STATUS).equals(VALID)) {</span>
<span class="nc" id="L523">                throw acme.noCertificateWillBeIssuedByAcmeServer();</span>
            }

            // download the certificate chain
<span class="fc" id="L527">            String certificateUrl = getOptionalJsonString(jsonResponse, CERTIFICATE);</span>
<span class="pc bpc" id="L528" title="1 of 2 branches missed.">            if (certificateUrl == null) {</span>
<span class="nc" id="L529">                throw acme.noCertificateUrlProvidedByAcmeServer();</span>
            }
<span class="fc" id="L531">            connection = sendPostAsGetRequest(account, staging, certificateUrl, PEM_CERTIFICATE_CHAIN_CONTENT_TYPE, HttpURLConnection.HTTP_OK);</span>
<span class="fc" id="L532">            X509Certificate[] certificateChain = getPemCertificateChain(connection);</span>
<span class="fc" id="L533">            PrivateKey privateKey = selfSignedX509CertificateAndSigningKey.getSigningKey();</span>
<span class="fc" id="L534">            return new X509CertificateChainAndSigningKey(certificateChain, privateKey);</span>
        } finally {
            // clean up
<span class="fc bfc" id="L537" title="All 2 branches covered.">            for (AcmeChallenge challenge : selectedChallenges) {</span>
<span class="fc" id="L538">                cleanupAfterChallenge(account, challenge);</span>
<span class="fc" id="L539">            }</span>
        }
    }

    /**
     * Create an authorization for the given identifier.
     * &lt;p&gt;
     * This method allows an ACME client to obtain authorization for an identifier proactively before attempting
     * to obtain a certificate.
     *
     * @param account the ACME account information to use (must not be {@code null})
     * @param staging whether or not the staging server URL should be used
     * @param domainName the domain name to create an authorization for (must not be {@code null})
     * @return the authorization URL corresponding to the given identifier
     * @throws AcmeException if an error occurs while attempting to create an authorization for the given identifier
     */
    public String createAuthorization(AcmeAccount account, boolean staging, String domainName) throws AcmeException {
<span class="nc" id="L556">        Assert.checkNotNullParam(&quot;account&quot;, account);</span>
<span class="nc" id="L557">        Assert.checkNotNullParam(&quot;domainName&quot;, domainName);</span>
<span class="nc" id="L558">        final String newAuthzUrl = getResourceUrl(account, AcmeResource.NEW_AUTHZ, staging).toString();</span>
<span class="nc" id="L559">        JsonObject identifier = Json.createObjectBuilder()</span>
<span class="nc" id="L560">                .add(TYPE, DNS)</span>
<span class="nc" id="L561">                .add(VALUE, getSanitizedDomainName(domainName))</span>
<span class="nc" id="L562">                .build();</span>
<span class="nc" id="L563">        JsonObjectBuilder payloadBuilder = Json.createObjectBuilder()</span>
<span class="nc" id="L564">                .add(IDENTIFIER, identifier);</span>

<span class="nc" id="L566">        HttpURLConnection connection = sendPostRequestWithRetries(account, staging, newAuthzUrl, false,</span>
<span class="nc" id="L567">                getEncodedJson(payloadBuilder.build()), HttpURLConnection.HTTP_CREATED);</span>
<span class="nc" id="L568">        String authorizationUrl = getLocation(connection, AUTHORIZATION);</span>
<span class="nc" id="L569">        JsonObject jsonResponse = getJsonResponse(connection);</span>
<span class="nc" id="L570">        AcmeChallenge selectedChallenge = respondToChallenges(account, staging, jsonResponse);</span>
        try {
<span class="nc" id="L572">            jsonResponse = pollResourceUntilFinalized(account, staging, authorizationUrl);</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">            if (! jsonResponse.getString(STATUS).equals(VALID)) {</span>
<span class="nc" id="L574">                throw acme.challengeResponseFailedValidationByAcmeServer();</span>
            }
<span class="nc" id="L576">            return authorizationUrl;</span>
        } finally {
<span class="nc bnc" id="L578" title="All 2 branches missed.">            if (selectedChallenge != null) {</span>
<span class="nc" id="L579">                cleanupAfterChallenge(account, selectedChallenge);</span>
            }
        }
    }

    /**
     * Deactivate an authorization.
     *
     * @param account the ACME account information to use (must not be {@code null})
     * @param staging whether or not the staging server URL should be used
     * @param authorizationUrl the authorization url (must not be {@code null})
     * @throws AcmeException if an error occurs while attempting to deactivate an authorization for the given identifier
     */
    public void deactivateAuthorization(AcmeAccount account, boolean staging, String authorizationUrl) throws AcmeException {
<span class="nc" id="L593">        Assert.checkNotNullParam(&quot;account&quot;, account);</span>
<span class="nc" id="L594">        Assert.checkNotNullParam(&quot;authorizationUrl&quot;, authorizationUrl);</span>
<span class="nc" id="L595">        JsonObject payload = Json.createObjectBuilder()</span>
<span class="nc" id="L596">                .add(STATUS, DEACTIVATED)</span>
<span class="nc" id="L597">                .build();</span>
<span class="nc" id="L598">        sendPostRequestWithRetries(account, staging, authorizationUrl, false, getEncodedJson(payload), HttpURLConnection.HTTP_OK);</span>
<span class="nc" id="L599">    }</span>

    /**
     * Prove control of the identifier associated with the given list of challenges.
     * &lt;p&gt;
     * This method should select one challenge from the given list of challenges from the ACME server to prove
     * control of the identifier associated with the challenges as specified by the ACME v2 protocol.
     *
     * @param account the ACME account information to use (must not be {@code null})
     * @param challenges the list of challenges from the ACME server (must not be {@code null})
     * @return the challenge that was selected and used to prove control of the identifier
     * @throws AcmeException if an error occurs while attempting to provide control of the identifier associated
     * with the challenges or if none of the challenge types are supported by this client
     */
    public abstract AcmeChallenge proveIdentifierControl(AcmeAccount account, List&lt;AcmeChallenge&gt; challenges) throws AcmeException;

    /**
     * Undo the actions that were taken to prove control of the identifier associated with the given challenge.
     *
     * @param account the ACME account information to use (must not be {@code null})
     * @param challenge the challenge (must not be {@code null})
     * @throws AcmeException if an error occurs while attempting to undo the actions that were taken to prove control
     * of the identifier associated with the given challenge
     */
    public abstract void cleanupAfterChallenge(AcmeAccount account, AcmeChallenge challenge) throws AcmeException;

    /**
     * Revoke the given certificate.
     *
     * @param account the ACME account information to use (must not be {@code null})
     * @param staging whether or not the staging server URL should be used
     * @param certificate the certificate to be revoked (must not be {@code null})
     * @throws AcmeException if an error occurs while attempting to revoke the given certificate
     */
    public void revokeCertificate(AcmeAccount account, boolean staging, X509Certificate certificate) throws AcmeException {
<span class="nc" id="L634">        revokeCertificate(account, staging, certificate, null);</span>
<span class="nc" id="L635">    }</span>

    /**
     * Revoke the given certificate.
     *
     * @param account the ACME account information to use (must not be {@code null})
     * @param staging whether or not the staging server URL should be used
     * @param certificate the certificate to be revoked (must not be {@code null})
     * @param reason the optional reason why the certificate is being revoked (may be {@code null})
     * @throws AcmeException if an error occurs while attempting to revoke the given certificate
     */
    public void revokeCertificate(AcmeAccount account, boolean staging, X509Certificate certificate, CRLReason reason) throws AcmeException {
<span class="fc" id="L647">        Assert.checkNotNullParam(&quot;account&quot;, account);</span>
<span class="fc" id="L648">        Assert.checkNotNullParam(&quot;certificate&quot;, certificate);</span>
<span class="fc" id="L649">        final String revokeCertUrl = getResourceUrl(account, AcmeResource.REVOKE_CERT, staging).toString();</span>

        byte[] encodedCertificate;
        try {
<span class="fc" id="L653">            encodedCertificate = certificate.getEncoded();</span>
<span class="nc" id="L654">        } catch (CertificateEncodingException e) {</span>
<span class="nc" id="L655">            throw acme.unableToGetEncodedFormOfCertificateToBeRevoked(e);</span>
<span class="fc" id="L656">        }</span>
<span class="fc" id="L657">        JsonObjectBuilder payloadBuilder = Json.createObjectBuilder()</span>
<span class="fc" id="L658">                .add(CERTIFICATE, base64UrlEncode(encodedCertificate));</span>
<span class="fc bfc" id="L659" title="All 2 branches covered.">        if (reason != null) {</span>
<span class="fc" id="L660">            payloadBuilder.add(REASON, reason.ordinal());</span>
        }
<span class="fc" id="L662">        sendPostRequestWithRetries(account, staging, revokeCertUrl, false, getEncodedJson(payloadBuilder.build()), HttpURLConnection.HTTP_OK);</span>
<span class="fc" id="L663">    }</span>

    /**
     * Get a new nonce for the given account from the ACME server.
     *
     * @param account the ACME account information to use (must not be {@code null})
     * @param staging whether or not the staging server URL should be used
     * @return nonce the new nonce for the given account
     * @throws AcmeException if an error occurs while attempting to get the new nonce from the ACME server
     */
    public byte[] getNewNonce(final AcmeAccount account, final boolean staging) throws AcmeException {
<span class="fc" id="L674">        Assert.checkNotNullParam(&quot;account&quot;, account);</span>
        try {
<span class="fc" id="L676">            final URL newNonceUrl = getResourceUrl(account, AcmeResource.NEW_NONCE, staging);</span>
<span class="fc" id="L677">            HttpURLConnection connection = (HttpURLConnection) newNonceUrl.openConnection();</span>
<span class="fc" id="L678">            connection.setRequestMethod(HEAD);</span>
<span class="fc" id="L679">            connection.setRequestProperty(ACCEPT_LANGUAGE, Locale.getDefault().toLanguageTag());</span>
<span class="fc" id="L680">            connection.setRequestProperty(USER_AGENT, USER_AGENT_STRING);</span>
<span class="fc" id="L681">            connection.connect();</span>
<span class="fc" id="L682">            int responseCode = connection.getResponseCode();</span>
<span class="pc bpc" id="L683" title="3 of 4 branches missed.">            if (responseCode != HttpURLConnection.HTTP_NO_CONTENT &amp;&amp; responseCode != HttpURLConnection.HTTP_OK) {</span>
<span class="nc" id="L684">                handleAcmeErrorResponse(connection, responseCode);</span>
            }
<span class="fc" id="L686">            byte[] nonce = getReplayNonce(connection);</span>
<span class="pc bpc" id="L687" title="1 of 2 branches missed.">            if (nonce == null) {</span>
<span class="nc" id="L688">                throw acme.noNonceProvidedByAcmeServer();</span>
            }
<span class="fc" id="L690">            return nonce;</span>
<span class="nc" id="L691">        } catch (Exception e) {</span>
<span class="nc" id="L692">            throw acme.unableToObtainNewNonceFromAcmeServer();</span>
        }
    }

    String[] queryAccountContactUrls(AcmeAccount account, boolean staging) throws AcmeException {
<span class="fc" id="L697">        Assert.checkNotNullParam(&quot;account&quot;, account);</span>
<span class="fc" id="L698">        HttpURLConnection connection = sendPostAsGetRequest(account, staging, getAccountUrl(account, staging), null, HttpURLConnection.HTTP_OK);</span>
<span class="fc" id="L699">        JsonObject jsonResponse = getJsonResponse(connection);</span>
<span class="fc" id="L700">        JsonArray contactsArray = jsonResponse.getJsonArray(CONTACT);</span>
<span class="pc bpc" id="L701" title="2 of 4 branches missed.">        if (contactsArray != null &amp;&amp; contactsArray.size() &gt; 0) {</span>
<span class="fc" id="L702">            List&lt;String&gt; contacts = new ArrayList&lt;&gt;(contactsArray.size());</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">            for (JsonString contact : contactsArray.getValuesAs(JsonString.class)) {</span>
<span class="fc" id="L704">                contacts.add(contact.getString());</span>
<span class="fc" id="L705">            }</span>
<span class="fc" id="L706">            return contacts.toArray(new String[contacts.size()]);</span>
        }
<span class="nc" id="L708">        return null;</span>
    }

    String queryAccountStatus(AcmeAccount account, boolean staging) throws AcmeException {
<span class="fc" id="L712">        Assert.checkNotNullParam(&quot;account&quot;, account);</span>
<span class="fc" id="L713">        HttpURLConnection connection = sendPostAsGetRequest(account, staging, getAccountUrl(account, staging), null, HttpURLConnection.HTTP_OK);</span>
<span class="fc" id="L714">        JsonObject jsonResponse = getJsonResponse(connection);</span>
<span class="fc" id="L715">        return jsonResponse.getString(STATUS);</span>
    }

    private URL getResourceUrl(AcmeAccount account, AcmeResource resource, boolean staging) throws AcmeException {
<span class="fc" id="L719">        URL resourceUrl = getResourceUrls(account, staging).get(resource);</span>
<span class="pc bpc" id="L720" title="1 of 2 branches missed.">        if (resourceUrl == null) {</span>
<span class="nc" id="L721">            throw acme.resourceNotSupportedByAcmeServer(resource.getValue());</span>
        }
<span class="fc" id="L723">        return resourceUrl;</span>
    }

    private HttpURLConnection sendGetRequest(String resourceUrl, int expectedResponseCode, String expectedContentType) throws AcmeException {
        try {
<span class="fc" id="L728">            final URL directoryUrl = new URL(resourceUrl);</span>
<span class="fc" id="L729">            HttpURLConnection connection = (HttpURLConnection) directoryUrl.openConnection();</span>
<span class="fc" id="L730">            connection.setRequestMethod(GET);</span>
<span class="fc" id="L731">            connection.setRequestProperty(ACCEPT_LANGUAGE, Locale.getDefault().toLanguageTag());</span>
<span class="fc" id="L732">            connection.setRequestProperty(USER_AGENT, USER_AGENT_STRING);</span>
<span class="fc" id="L733">            connection.connect();</span>
<span class="fc" id="L734">            int responseCode = connection.getResponseCode();</span>
<span class="pc bpc" id="L735" title="1 of 2 branches missed.">            if (responseCode != expectedResponseCode) {</span>
<span class="nc" id="L736">                handleAcmeErrorResponse(connection, responseCode);</span>
            }
<span class="fc" id="L738">            String contentType = connection.getContentType();</span>
<span class="pc bpc" id="L739" title="1 of 2 branches missed.">            if (! checkContentType(connection, expectedContentType)) {</span>
<span class="nc" id="L740">                throw acme.unexpectedContentTypeFromAcmeServer(contentType);</span>
            }
<span class="fc" id="L742">            return connection;</span>
<span class="nc" id="L743">        } catch (Exception e) {</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">            if (e instanceof AcmeException) {</span>
<span class="nc" id="L745">                throw (AcmeException) e;</span>
            } else {
<span class="nc" id="L747">                throw new AcmeException(e);</span>
            }
        }
    }

    private HttpURLConnection sendPostAsGetRequest(AcmeAccount account, boolean staging, String resourceUrl,
                                                   String expectedContentType, int... expectedResponseCodes) throws AcmeException {
        // payload of the JWS must be a zero-length octet string
<span class="fc" id="L755">        return sendPostRequestWithRetries(account, staging, resourceUrl, false, EMPTY_STRING,</span>
                expectedContentType, expectedResponseCodes);
    }

    private HttpURLConnection sendPostRequestWithRetries(AcmeAccount account, boolean staging, String resourceUrl, boolean useJwk, String encodedPayload,
                                                         int... expectedResponseCodes) throws AcmeException {
<span class="fc" id="L761">        return sendPostRequestWithRetries(account, staging, resourceUrl, useJwk, encodedPayload, null, expectedResponseCodes);</span>
    }


    private HttpURLConnection sendPostRequestWithRetries(AcmeAccount account, boolean staging, String resourceUrl, boolean useJwk, String encodedPayload,
                                                         String expectedContentType, int... expectedResponseCodes) throws AcmeException {
        try {
<span class="fc" id="L768">            final URL url = new URL(resourceUrl);</span>
            HttpURLConnection connection;
<span class="pc bpc" id="L770" title="1 of 2 branches missed.">            for (int i = 0; i &lt; MAX_RETRIES; i++) {</span>
<span class="fc" id="L771">                String encodedProtectedHeader = getEncodedProtectedHeader(useJwk, resourceUrl, account, staging);</span>
<span class="fc" id="L772">                String encodedSignature = getEncodedSignature(account.getPrivateKey(), account.getSignature(), encodedProtectedHeader, encodedPayload);</span>
<span class="fc" id="L773">                JsonObject jws = getJws(encodedProtectedHeader, encodedPayload, encodedSignature);</span>
<span class="fc" id="L774">                connection = (HttpURLConnection) url.openConnection();</span>
<span class="fc" id="L775">                connection.setRequestMethod(POST);</span>
<span class="fc" id="L776">                connection.setRequestProperty(CONTENT_TYPE, JOSE_JSON_CONTENT_TYPE);</span>
<span class="fc" id="L777">                connection.setRequestProperty(ACCEPT_LANGUAGE, Locale.getDefault().toLanguageTag());</span>
<span class="fc" id="L778">                connection.setRequestProperty(USER_AGENT, USER_AGENT_STRING);</span>
<span class="fc" id="L779">                connection.setDoOutput(true);</span>
<span class="fc" id="L780">                connection.setFixedLengthStreamingMode(jws.toString().length());</span>
<span class="fc" id="L781">                connection.connect();</span>
<span class="fc" id="L782">                try (OutputStream out = connection.getOutputStream()) {</span>
<span class="fc" id="L783">                    out.write(jws.toString().getBytes(StandardCharsets.US_ASCII));</span>
                }
<span class="fc" id="L785">                int responseCode = connection.getResponseCode();</span>

<span class="fc" id="L787">                account.setNonce(getReplayNonce(connection)); // update the account nonce</span>

<span class="pc bpc" id="L789" title="1 of 2 branches missed.">                for (int expectedResponseCode : expectedResponseCodes) {</span>
<span class="fc bfc" id="L790" title="All 2 branches covered.">                    if (expectedResponseCode == responseCode) {</span>
<span class="fc bfc" id="L791" title="All 2 branches covered.">                        if (expectedContentType != null) {</span>
<span class="fc" id="L792">                            String contentType = connection.getContentType();</span>
<span class="pc bpc" id="L793" title="1 of 2 branches missed.">                            if (! checkContentType(connection, expectedContentType)) {</span>
<span class="nc" id="L794">                                throw acme.unexpectedContentTypeFromAcmeServer(contentType);</span>
                            }
                        }
<span class="fc" id="L797">                        return connection;</span>
                    }
                }
<span class="nc" id="L800">                handleAcmeErrorResponse(connection, responseCode);</span>
            }
<span class="nc" id="L802">            throw acme.badAcmeNonce(); // max attempts reached</span>
<span class="fc" id="L803">        } catch (Exception e) {</span>
<span class="pc bpc" id="L804" title="1 of 2 branches missed.">            if (e instanceof AcmeException) {</span>
<span class="fc" id="L805">                throw (AcmeException) e;</span>
            } else {
<span class="nc" id="L807">                throw new AcmeException(e);</span>
            }
        }
    }

    private JsonObject pollResourceUntilFinalized(AcmeAccount account, boolean staging, String resourceUrl) throws AcmeException {
        boolean statusFinalized;
        JsonObject jsonResponse;
        do {
<span class="fc" id="L816">            statusFinalized = true;</span>
<span class="fc" id="L817">            HttpURLConnection connection = sendPostAsGetRequest(account, staging, resourceUrl, JSON_CONTENT_TYPE, HttpURLConnection.HTTP_OK);</span>
<span class="fc" id="L818">            jsonResponse = getJsonResponse(connection);</span>
<span class="fc" id="L819">            String status = jsonResponse.getString(STATUS);</span>
<span class="pc bpc" id="L820" title="3 of 4 branches missed.">            if (! status.equals(VALID) &amp;&amp; ! status.equals(INVALID)) {</span>
                // server still processing the client response, try again after some time
<span class="nc" id="L822">                statusFinalized = false;</span>
<span class="nc" id="L823">                long retryAfterMilli = getRetryAfter(connection, true);</span>
<span class="nc bnc" id="L824" title="All 2 branches missed.">                if (retryAfterMilli &gt; 0) {</span>
                    try {
<span class="nc" id="L826">                        Thread.sleep(retryAfterMilli);</span>
<span class="nc" id="L827">                    } catch (InterruptedException e) {</span>
<span class="nc" id="L828">                        Thread.currentThread().interrupt();</span>
<span class="nc" id="L829">                        throw new RuntimeException(e);</span>
<span class="nc" id="L830">                    }</span>
                }
            }
<span class="pc bpc" id="L833" title="1 of 2 branches missed.">        } while (! statusFinalized);</span>
<span class="fc" id="L834">        return jsonResponse;</span>
    }

    private AcmeChallenge respondToChallenges(AcmeAccount account, boolean staging, JsonObject authorization) throws AcmeException {
<span class="fc" id="L838">        List&lt;AcmeChallenge&gt; challenges = null;</span>
<span class="pc bpc" id="L839" title="1 of 2 branches missed.">        if (authorization.getString(STATUS).equals(PENDING)) {</span>
<span class="fc" id="L840">            JsonObject identifier = authorization.getJsonObject(IDENTIFIER);</span>
<span class="fc" id="L841">            JsonArray challengeArray = authorization.getJsonArray(CHALLENGES);</span>
<span class="fc" id="L842">            challenges = new ArrayList&lt;&gt;(challengeArray.size());</span>
<span class="fc bfc" id="L843" title="All 2 branches covered.">            for (JsonObject challenge : challengeArray.getValuesAs(JsonObject.class)) {</span>
<span class="fc" id="L844">                challenges.add(new AcmeChallenge(AcmeChallenge.Type.forName(challenge.getString(TYPE)), challenge.getString(URL),</span>
<span class="fc" id="L845">                        challenge.getString(TOKEN), identifier.getString(TYPE), identifier.getString(VALUE)));</span>
<span class="fc" id="L846">            }</span>
        }
<span class="pc bpc" id="L848" title="2 of 4 branches missed.">        if (challenges != null &amp;&amp; ! challenges.isEmpty()) {</span>
<span class="fc" id="L849">            AcmeChallenge selectedChallenge = proveIdentifierControl(account, challenges);</span>
            try {
<span class="fc" id="L851">                sendPostRequestWithRetries(account, staging, selectedChallenge.getUrl(), false, getEncodedJson(EMPTY_PAYLOAD), HttpURLConnection.HTTP_OK);</span>
<span class="fc" id="L852">                return selectedChallenge;</span>
<span class="nc" id="L853">            } catch (AcmeException e) {</span>
<span class="nc" id="L854">                cleanupAfterChallenge(account, selectedChallenge);</span>
<span class="nc" id="L855">                throw e;</span>
            }
        }
<span class="nc" id="L858">        return null;</span>
    }

    private static LinkedHashSet&lt;String&gt; getDomainNames(String[] domainNames) throws AcmeException {
<span class="pc bpc" id="L862" title="1 of 2 branches missed.">        if (domainNames.length == 0) {</span>
<span class="nc" id="L863">            throw acme.domainNamesIsEmpty();</span>
        }
<span class="fc" id="L865">        final LinkedHashSet&lt;String&gt; domainNamesSet = new LinkedHashSet&lt;&gt;();</span>
<span class="fc bfc" id="L866" title="All 2 branches covered.">        for (String domainName : domainNames) {</span>
<span class="fc" id="L867">            domainNamesSet.add(getSanitizedDomainName(domainName));</span>
        }
<span class="fc" id="L869">        return domainNamesSet;</span>
    }

    private static String getSanitizedDomainName(String domainName) throws AcmeException {
<span class="pc bpc" id="L873" title="1 of 2 branches missed.">        if (domainName == null) {</span>
<span class="nc" id="L874">            throw acme.domainNameIsNull();</span>
        }
<span class="fc" id="L876">        domainName = IDN.toASCII(domainName.trim());</span>
<span class="fc" id="L877">        return domainName.toLowerCase(Locale.ROOT);</span>
    }

    /* -- Methods used to parse responses from the ACME server -- */

    private static JsonObject getJsonResponse(HttpURLConnection connection) throws AcmeException {
        JsonObject jsonResponse;
<span class="fc bfc" id="L884" title="All 2 branches covered.">        try (InputStream inputStream = new BufferedInputStream(connection.getResponseCode() &lt; 400 ? connection.getInputStream() : connection.getErrorStream());</span>
<span class="fc" id="L885">                JsonReader jsonReader = Json.createReader(inputStream)) {</span>
<span class="fc" id="L886">            jsonResponse = jsonReader.readObject();</span>
<span class="nc" id="L887">        } catch (IOException e) {</span>
<span class="nc" id="L888">            throw acme.unableToObtainJsonResponseFromAcmeServer(e);</span>
<span class="fc" id="L889">        }</span>
<span class="fc" id="L890">        return jsonResponse;</span>
    }

    private static byte[] getReplayNonce(HttpURLConnection connection) throws AcmeException {
<span class="fc" id="L894">        String nonce = connection.getHeaderField(REPLAY_NONCE);</span>
<span class="pc bpc" id="L895" title="1 of 2 branches missed.">        if (nonce == null) {</span>
<span class="nc" id="L896">            return null;</span>
        }
<span class="fc" id="L898">        return CodePointIterator.ofString(nonce).base64Decode(BASE64_URL, false).drain();</span>
    }

    private static String getLocation(HttpURLConnection connection, String urlType) throws AcmeException {
<span class="fc" id="L902">        String location = connection.getHeaderField(LOCATION);</span>
<span class="fc bfc" id="L903" title="All 2 branches covered.">        if (location == null) {</span>
<span class="fc" id="L904">            throw acme.noLocationUrlProvidedByAcmeServer(urlType);</span>
        }
<span class="fc" id="L906">        return location;</span>
    }

    private static long getRetryAfter(HttpURLConnection connection, boolean useDefaultIfHeaderNotPresent) throws AcmeException {
<span class="nc" id="L910">        long retryAfterMilli  = -1;</span>
<span class="nc" id="L911">        String retryAfter = connection.getHeaderField(RETRY_AFTER);</span>
<span class="nc bnc" id="L912" title="All 2 branches missed.">        if (retryAfter != null) {</span>
            try {
<span class="nc" id="L914">                retryAfterMilli = Integer.parseInt(retryAfter) * 1000;</span>
<span class="nc" id="L915">            } catch (NumberFormatException e) {</span>
<span class="nc" id="L916">                long retryAfterDate = connection.getHeaderFieldDate(RETRY_AFTER, 0L);</span>
<span class="nc bnc" id="L917" title="All 2 branches missed.">                if (retryAfterDate != 0) {</span>
<span class="nc" id="L918">                    retryAfterMilli = retryAfterDate - Instant.now().toEpochMilli();</span>
                }
<span class="nc" id="L920">            }</span>
        }

<span class="nc bnc" id="L923" title="All 2 branches missed.">        if (retryAfterMilli == -1) {</span>
<span class="nc bnc" id="L924" title="All 2 branches missed.">            if (useDefaultIfHeaderNotPresent) {</span>
<span class="nc" id="L925">                retryAfterMilli = DEFAULT_RETRY_AFTER_MILLI;</span>
            }
        }
<span class="nc" id="L928">        return retryAfterMilli;</span>
    }

    private static void handleAcmeErrorResponse(HttpURLConnection connection, int responseCode) throws AcmeException {
        try {
<span class="fc" id="L933">            String responseMessage = connection.getResponseMessage();</span>
<span class="fc bfc" id="L934" title="All 2 branches covered.">            if (! checkContentType(connection, PROBLEM_JSON_CONTENT_TYPE)) {</span>
<span class="fc" id="L935">                throw acme.unexpectedResponseCodeFromAcmeServer(responseCode, responseMessage);</span>
            }
<span class="fc" id="L937">            JsonObject jsonResponse = getJsonResponse(connection);</span>
<span class="fc" id="L938">            String type = getOptionalJsonString(jsonResponse, TYPE);</span>
<span class="pc bpc" id="L939" title="1 of 2 branches missed.">            if (type != null) {</span>
<span class="pc bpc" id="L940" title="1 of 2 branches missed.">                if (type.equals(BAD_NONCE)) {</span>
<span class="nc" id="L941">                    return; // the request will be re-attempted</span>
<span class="pc bpc" id="L942" title="1 of 2 branches missed.">                } else if (type.equals(USER_ACTION_REQUIRED)) {</span>
<span class="nc" id="L943">                    String instance = getOptionalJsonString(jsonResponse, INSTANCE);</span>
<span class="nc bnc" id="L944" title="All 2 branches missed.">                    if (instance != null) {</span>
<span class="nc" id="L945">                        throw acme.userActionRequired(instance);</span>
                    }
<span class="pc bpc" id="L947" title="1 of 2 branches missed.">                } else if (type.equals(RATE_LIMITED)) {</span>
<span class="nc" id="L948">                    long retryAfter = getRetryAfter(connection, false);</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">                    if (retryAfter &gt; 0) {</span>
<span class="nc" id="L950">                        throw acme.rateLimitExceededTryAgainLater(Instant.ofEpochMilli(retryAfter));</span>
                    } else {
<span class="nc" id="L952">                        throw acme.rateLimitExceeded();</span>
                    }
                }
            }
<span class="fc" id="L956">            String problemMessages = getProblemMessages(jsonResponse);</span>
<span class="pc bpc" id="L957" title="2 of 4 branches missed.">            if (problemMessages != null &amp;&amp; ! problemMessages.isEmpty()) {</span>
<span class="fc" id="L958">                throw new AcmeException(problemMessages);</span>
            } else {
<span class="nc" id="L960">                throw acme.unexpectedResponseCodeFromAcmeServer(responseCode, responseMessage);</span>
            }
<span class="fc" id="L962">        } catch (Exception e) {</span>
<span class="pc bpc" id="L963" title="1 of 2 branches missed.">            if (e instanceof AcmeException) {</span>
<span class="fc" id="L964">                throw (AcmeException) e;</span>
            } else {
<span class="nc" id="L966">                throw new AcmeException(e);</span>
            }
        }
    }

    private static String getProblemMessages(JsonObject errorResponse) {
<span class="fc" id="L972">        StringBuilder problemMessages = new StringBuilder();</span>
<span class="fc" id="L973">        String mainProblem = getProblemMessage(errorResponse);</span>
<span class="pc bpc" id="L974" title="1 of 2 branches missed.">        if (mainProblem != null) {</span>
<span class="fc" id="L975">            problemMessages.append(getProblemMessage(errorResponse));</span>
        }
<span class="fc" id="L977">        JsonArray subproblems = errorResponse.getJsonArray(SUBPROBLEMS);</span>
<span class="pc bpc" id="L978" title="3 of 4 branches missed.">        if (subproblems != null &amp;&amp; subproblems.size() &gt; 0) {</span>
<span class="nc" id="L979">            problemMessages.append(&quot;:&quot;);</span>
<span class="nc bnc" id="L980" title="All 2 branches missed.">            for (JsonObject subproblem : subproblems.getValuesAs(JsonObject.class)) {</span>
<span class="nc" id="L981">                problemMessages.append(&quot;\n&quot;).append(getProblemMessage(subproblem));</span>
<span class="nc" id="L982">            }</span>
        }
<span class="fc" id="L984">        return problemMessages.toString();</span>
    }

    private static String getProblemMessage(JsonObject jsonResponse) {
<span class="fc" id="L988">        String type = getOptionalJsonString(jsonResponse, TYPE);</span>
<span class="fc" id="L989">        String detail = getOptionalJsonString(jsonResponse, DETAIL);</span>
<span class="fc" id="L990">        String title = getOptionalJsonString(jsonResponse, TITLE);</span>
<span class="fc" id="L991">        String problemMessage = null;</span>
<span class="pc bpc" id="L992" title="1 of 2 branches missed.">        if (detail != null) {</span>
<span class="fc" id="L993">            problemMessage = detail;</span>
<span class="nc bnc" id="L994" title="All 2 branches missed.">        } else if (title != null) {</span>
<span class="nc" id="L995">            problemMessage = title;</span>
<span class="nc bnc" id="L996" title="All 2 branches missed.">        } else if (type != null) {</span>
<span class="nc" id="L997">            problemMessage = type;</span>
        }
<span class="fc" id="L999">        return problemMessage;</span>
    }

    private static String getOptionalJsonString(JsonObject jsonObject, String name) {
<span class="fc" id="L1003">        JsonString value = jsonObject.getJsonString(name);</span>
<span class="fc bfc" id="L1004" title="All 2 branches covered.">        if (value == null) {</span>
<span class="fc" id="L1005">            return null;</span>
        }
<span class="fc" id="L1007">        return value.getString();</span>
    }

    private static X509Certificate[] getPemCertificateChain(HttpURLConnection connection) throws AcmeException {
        try {
<span class="fc" id="L1012">            CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;);</span>
            Collection&lt;? extends Certificate&gt; reply;
<span class="fc" id="L1014">            try (InputStream inputStream = new BufferedInputStream(getConvertedInputStream(connection.getInputStream()))) {</span>
<span class="fc" id="L1015">                reply = certificateFactory.generateCertificates(inputStream);</span>
            }
<span class="fc" id="L1017">            return X500.asX509CertificateArray(reply.toArray(new Certificate[reply.size()]));</span>
<span class="nc" id="L1018">        } catch (CertificateException | IOException e) {</span>
<span class="nc" id="L1019">            throw acme.unableToDownloadCertificateChainFromAcmeServer(e);</span>
        }
    }

    /* -- Methods used to encode JWS messages to send to the ACME server -- */

    private static String getEncodedJson(JsonObject jsonObject) {
<span class="fc" id="L1026">        return CodePointIterator.ofString(jsonObject.toString()).asUtf8().base64Encode(BASE64_URL, false).drainToString();</span>
    }

    private static JsonObject getJws(String encodedProtectedHeader, String encodedPayload, String encodedSignature) {
<span class="fc" id="L1030">        return Json.createObjectBuilder()</span>
<span class="fc" id="L1031">                .add(PROTECTED, encodedProtectedHeader)</span>
<span class="fc" id="L1032">                .add(PAYLOAD, encodedPayload)</span>
<span class="fc" id="L1033">                .add(SIGNATURE, encodedSignature)</span>
<span class="fc" id="L1034">                .build();</span>
    }

    private static String getEncodedProtectedHeader(String algHeader, PublicKey publicKey, String resourceUrl) {
<span class="fc" id="L1038">        JsonObject protectedHeader = Json.createObjectBuilder()</span>
<span class="fc" id="L1039">                .add(ALG, algHeader)</span>
<span class="fc" id="L1040">                .add(JWK, getJwk(publicKey, algHeader))</span>
<span class="fc" id="L1041">                .add(URL, resourceUrl)</span>
<span class="fc" id="L1042">                .build();</span>
<span class="fc" id="L1043">        return getEncodedJson(protectedHeader);</span>
    }

    private String getEncodedProtectedHeader(boolean useJwk, String resourceUrl, AcmeAccount account, boolean staging) throws AcmeException {
<span class="fc" id="L1047">        JsonObjectBuilder protectedHeaderBuilder = Json.createObjectBuilder().add(ALG, account.getAlgHeader());</span>
<span class="fc bfc" id="L1048" title="All 2 branches covered.">        if (useJwk) {</span>
<span class="fc" id="L1049">            protectedHeaderBuilder.add(JWK, getJwk(account.getPublicKey(), account.getAlgHeader()));</span>
        } else {
<span class="fc" id="L1051">            protectedHeaderBuilder.add(KID, getAccountUrl(account, staging));</span>
        }
<span class="fc" id="L1053">        protectedHeaderBuilder</span>
<span class="fc" id="L1054">                .add(NONCE, base64UrlEncode(getNonce(account, staging)))</span>
<span class="fc" id="L1055">                .add(URL, resourceUrl);</span>
<span class="fc" id="L1056">        return getEncodedJson(protectedHeaderBuilder.build());</span>
    }

    private static String getEncodedSignature(PrivateKey privateKey, Signature signature, String encodedProtectedHeader, String encodedPayload) throws AcmeException {
        final byte[] signatureBytes;
        try {
<span class="fc" id="L1062">            signature.update((encodedProtectedHeader + &quot;.&quot; + encodedPayload).getBytes(StandardCharsets.UTF_8));</span>
<span class="fc" id="L1063">            signatureBytes = signature.sign();</span>
<span class="fc bfc" id="L1064" title="All 2 branches covered.">            if (privateKey instanceof ECPrivateKey) {</span>
                // need to convert the DER encoded signature to concatenated bytes
<span class="fc" id="L1066">                DERDecoder derDecoder = new DERDecoder(signatureBytes);</span>
<span class="fc" id="L1067">                derDecoder.startSequence();</span>
<span class="fc" id="L1068">                byte[] r = derDecoder.drainElementValue();</span>
<span class="fc" id="L1069">                byte[] s = derDecoder.drainElementValue();</span>
<span class="fc" id="L1070">                derDecoder.endSequence();</span>
<span class="fc" id="L1071">                int rLength = r.length;</span>
<span class="fc" id="L1072">                int sLength = s.length;</span>
<span class="fc" id="L1073">                int rActual = rLength;</span>
<span class="fc" id="L1074">                int sActual = sLength;</span>
<span class="pc bpc" id="L1075" title="1 of 4 branches missed.">                while (rActual &gt; 0 &amp;&amp; r[rLength - rActual] == 0) {</span>
<span class="fc" id="L1076">                    rActual--;</span>
                }
<span class="pc bpc" id="L1078" title="1 of 4 branches missed.">                while (sActual &gt; 0 &amp;&amp; s[sLength - sActual] == 0) {</span>
<span class="fc" id="L1079">                    sActual--;</span>
                }
<span class="fc" id="L1081">                int rawLength = Math.max(rActual, sActual);</span>
<span class="fc" id="L1082">                int signatureByteLength = getECSignatureByteLength(signature.getAlgorithm());</span>
<span class="fc" id="L1083">                rawLength = Math.max(rawLength, signatureByteLength / 2);</span>
<span class="fc" id="L1084">                byte[] concatenatedSignatureBytes = new byte[rawLength * 2];</span>
<span class="fc" id="L1085">                System.arraycopy(r, rLength - rActual, concatenatedSignatureBytes, rawLength - rActual, rActual);</span>
<span class="fc" id="L1086">                System.arraycopy(s, sLength - sActual, concatenatedSignatureBytes, 2 * rawLength - sActual, sActual);</span>
<span class="fc" id="L1087">                return base64UrlEncode(concatenatedSignatureBytes);</span>
            }
<span class="fc" id="L1089">            return base64UrlEncode(signatureBytes);</span>
<span class="nc" id="L1090">        } catch (SignatureException e) {</span>
<span class="nc" id="L1091">            throw acme.unableToCreateAcmeSignature(e);</span>
        }
    }

    private static String getEncodedSignature(PrivateKey privateKey, String signatureAlgorithm, String encodedProtectedHeader, String encodedPayload) throws AcmeException {
        try {
<span class="fc" id="L1097">            Signature signature = Signature.getInstance(signatureAlgorithm);</span>
<span class="fc" id="L1098">            signature.initSign(privateKey);</span>
<span class="fc" id="L1099">            return getEncodedSignature(privateKey, signature, encodedProtectedHeader, encodedPayload);</span>
<span class="nc" id="L1100">        } catch (NoSuchAlgorithmException | InvalidKeyException e) {</span>
<span class="nc" id="L1101">            throw acme.unableToCreateAcmeSignature(e);</span>
        }
    }

    private static int getECSignatureByteLength(String signatureAlgorithm) throws AcmeException {
<span class="pc bpc" id="L1106" title="3 of 4 branches missed.">        switch(signatureAlgorithm) {</span>
            case &quot;SHA256withECDSA&quot;:
<span class="fc" id="L1108">                return 64;</span>
            case &quot;SHA384withECDSA&quot;:
<span class="nc" id="L1110">                return 96;</span>
            case &quot;SHA512withECDSA&quot;:
<span class="nc" id="L1112">                return 132;</span>
            default:
<span class="nc" id="L1114">                throw acme.unsupportedAcmeAccountSignatureAlgorithm(signatureAlgorithm);</span>
        }
    }

    private byte[] getNonce(AcmeAccount account, boolean staging) throws AcmeException {
<span class="fc" id="L1119">        byte[] nonce = account.getNonce();</span>
<span class="fc bfc" id="L1120" title="All 2 branches covered.">        if (nonce == null) {</span>
<span class="fc" id="L1121">            nonce = getNewNonce(account, staging);</span>
        }
<span class="fc" id="L1123">        return nonce;</span>
    }

    private String getAccountUrl(AcmeAccount account, boolean staging) throws AcmeException {
<span class="fc" id="L1127">        String accountUrl = account.getAccountUrl();</span>
<span class="fc bfc" id="L1128" title="All 2 branches covered.">        if (accountUrl == null) {</span>
<span class="fc" id="L1129">            createAccount(account, staging, true);</span>
<span class="fc" id="L1130">            accountUrl = account.getAccountUrl();</span>
<span class="pc bpc" id="L1131" title="1 of 2 branches missed.">            if (accountUrl == null) {</span>
<span class="nc" id="L1132">                acme.acmeAccountDoesNotExist();</span>
            }
        }
<span class="fc" id="L1135">        return accountUrl;</span>
    }

    private static boolean checkContentType(HttpURLConnection connection, String expectedMediaType) throws AcmeException {
<span class="fc" id="L1139">        String contentType = connection.getContentType();</span>
<span class="pc bpc" id="L1140" title="1 of 2 branches missed.">        if (contentType == null) {</span>
<span class="nc" id="L1141">            return false;</span>
        }
<span class="fc" id="L1143">        CodePointIterator cpi = CodePointIterator.ofString(contentType);</span>
<span class="fc" id="L1144">        CodePointIterator di = cpi.delimitedBy(CONTENT_TYPE_DELIMS);</span>
<span class="fc" id="L1145">        String mediaType = di.drainToString().trim();</span>
<span class="fc" id="L1146">        skipDelims(di, cpi, CONTENT_TYPE_DELIMS);</span>
<span class="pc bpc" id="L1147" title="1 of 2 branches missed.">        while (di.hasNext()) {</span>
<span class="nc" id="L1148">            String parameter = di.drainToString().trim();</span>
<span class="nc" id="L1149">            skipDelims(di, cpi, CONTENT_TYPE_DELIMS);</span>
<span class="nc bnc" id="L1150" title="All 2 branches missed.">            if (parameter.equalsIgnoreCase(CHARSET)) {</span>
<span class="nc" id="L1151">                String value = di.drainToString().trim();</span>
<span class="nc bnc" id="L1152" title="All 2 branches missed.">                if (! value.equalsIgnoreCase(UTF_8)) {</span>
<span class="nc" id="L1153">                    return false;</span>
                }
            }
<span class="nc" id="L1156">        }</span>
<span class="fc" id="L1157">        return mediaType.equalsIgnoreCase(expectedMediaType);</span>
    }

    private static void skipDelims(CodePointIterator di, CodePointIterator cpi, int...delims) throws AcmeException {
<span class="pc bpc" id="L1161" title="2 of 4 branches missed.">        while ((! di.hasNext()) &amp;&amp; cpi.hasNext()) {</span>
<span class="nc bnc" id="L1162" title="All 2 branches missed.">            if (! isDelim(cpi.next(), delims)) {</span>
<span class="nc" id="L1163">                throw acme.invalidContentTypeFromAcmeServer();</span>
            }
        }
<span class="fc" id="L1166">    }</span>

    private static boolean isDelim(int c, int... delims) {
<span class="nc bnc" id="L1169" title="All 2 branches missed.">        for (int delim : delims) {</span>
<span class="nc bnc" id="L1170" title="All 2 branches missed.">            if (delim == c) {</span>
<span class="nc" id="L1171">                return true;</span>
            }
        }
<span class="nc" id="L1174">        return false;</span>
    }

    private static InputStream getConvertedInputStream(InputStream inputStream) throws IOException {
<span class="fc" id="L1178">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L1179">        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {</span>
            String currentLine;
<span class="fc bfc" id="L1181" title="All 2 branches covered.">            while ((currentLine = reader.readLine()) != null) {</span>
                // ignore any blank lines to avoid parsing issues on IBM JDK
<span class="fc bfc" id="L1183" title="All 2 branches covered.">                if (! currentLine.trim().isEmpty()) {</span>
<span class="fc" id="L1184">                    sb.append(currentLine + System.lineSeparator());</span>
                }
            }
        }
<span class="fc" id="L1188">        return new ByteArrayInputStream(sb.toString().getBytes(StandardCharsets.UTF_8));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>