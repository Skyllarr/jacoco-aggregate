<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ModularCrypt.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">WildFly Elytron</a> &gt; <a href="../index.html" class="el_bundle">wildfly-elytron-credential</a> &gt; <a href="index.source.html" class="el_package">org.wildfly.security.password.util</a> &gt; <span class="el_source">ModularCrypt.java</span></div><h1>ModularCrypt.java</h1><pre class="source lang-java linenums">/*
 * JBoss, Home of Professional Open Source.
 * Copyright 2014 Red Hat, Inc., and individual contributors
 * as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.wildfly.security.password.util;

import static java.lang.Math.max;

import static org.wildfly.security.credential._private.ElytronMessages.log;
import static org.wildfly.security.password.interfaces.BSDUnixDESCryptPassword.ALGORITHM_BSD_CRYPT_DES;
import static org.wildfly.security.password.interfaces.SunUnixMD5CryptPassword.ALGORITHM_SUN_CRYPT_MD5;
import static org.wildfly.security.password.interfaces.SunUnixMD5CryptPassword.ALGORITHM_SUN_CRYPT_MD5_BARE_SALT;
import static org.wildfly.security.password.interfaces.UnixDESCryptPassword.ALGORITHM_CRYPT_DES;
import static org.wildfly.security.password.interfaces.UnixSHACryptPassword.ALGORITHM_CRYPT_SHA_256;
import static org.wildfly.security.password.interfaces.UnixSHACryptPassword.ALGORITHM_CRYPT_SHA_512;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.security.spec.InvalidKeySpecException;
import java.util.NoSuchElementException;

import org.wildfly.common.Assert;
import org.wildfly.common.codec.Base64Alphabet;
import org.wildfly.common.iteration.ByteIterator;
import org.wildfly.common.iteration.CodePointIterator;
import org.wildfly.security.password.Password;
import org.wildfly.security.password.interfaces.BCryptPassword;
import org.wildfly.security.password.interfaces.BSDUnixDESCryptPassword;
import org.wildfly.security.password.interfaces.MaskedPassword;
import org.wildfly.security.password.interfaces.SunUnixMD5CryptPassword;
import org.wildfly.security.password.interfaces.UnixDESCryptPassword;
import org.wildfly.security.password.interfaces.UnixMD5CryptPassword;
import org.wildfly.security.password.interfaces.UnixSHACryptPassword;

/**
 * Helper utility methods for operation on passwords based on the Modular Crypt Format(MCF).
 *
 * @author &lt;a href=&quot;mailto:jpkroehling.javadoc@redhat.com&quot;&gt;Juraci Paixão Kröhling&lt;/a&gt;
 * @author &lt;a href=&quot;mailto:david.lloyd@redhat.com&quot;&gt;David M. Lloyd&lt;/a&gt;
 */
<span class="pc bpc" id="L56" title="1 of 2 branches missed.">public final class ModularCrypt {</span>
    private ModularCrypt() {}

    // the order or value of these numbers is not important, just their uniqueness

    private static final int A_CRYPT_MD5                = 1;
    private static final int A_BCRYPT                   = 2;
    private static final int A_BSD_NT_HASH              = 3;
    private static final int A_CRYPT_SHA_256            = 4;
    private static final int A_CRYPT_SHA_512            = 5;
    private static final int A_SUN_CRYPT_MD5            = 6;
    private static final int A_APACHE_HTDIGEST          = 7;
    private static final int A_BSD_CRYPT_DES            = 8;
    private static final int A_CRYPT_DES                = 9;
    private static final int A_SUN_CRYPT_MD5_BARE_SALT  = 10;
    private static final int A_MASKED                   = 11;

    private static int doIdentifyAlgorithm(char[] chars) {
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">        if (chars.length &lt; 5) {</span>
<span class="nc" id="L75">            return 0;</span>
        }
<span class="fc bfc" id="L77" title="All 2 branches covered.">        if (chars[0] == '$') {</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">            if (chars[2] == '$') {</span>
<span class="pc bpc" id="L79" title="3 of 6 branches missed.">                switch (chars[1]) {</span>
<span class="fc" id="L80">                    case '1': return A_CRYPT_MD5;</span>
<span class="nc" id="L81">                    case '2': return A_BCRYPT;</span>
<span class="nc" id="L82">                    case '3': return A_BSD_NT_HASH;</span>
<span class="fc" id="L83">                    case '5': return A_CRYPT_SHA_256;</span>
<span class="fc" id="L84">                    case '6': return A_CRYPT_SHA_512;</span>
                    // 'P' == phpass
                    // 'H' == phpass
<span class="nc" id="L87">                    default: return 0;</span>
                }
<span class="fc bfc" id="L89" title="All 2 branches covered.">            } else if (chars[3] == '$') {</span>
<span class="pc bpc" id="L90" title="1 of 2 branches missed.">                if (chars[1] == '2') {</span>
<span class="pc bpc" id="L91" title="5 of 6 branches missed.">                    if (chars[2] == 'a' || chars[2] == 'x' || chars[2] == 'y') {</span>
                        // todo decide if we need a variation here
<span class="fc" id="L93">                        return A_BCRYPT;</span>
                    } else {
<span class="nc" id="L95">                        return 0;</span>
                    }
                } else {
<span class="nc" id="L98">                    return 0;</span>
                }
<span class="fc bfc" id="L100" title="All 4 branches covered.">            } else if (chars[4] == '$' || chars[4] == ',') {</span>
<span class="pc bpc" id="L101" title="3 of 6 branches missed.">                if (chars[1] == 'm' &amp;&amp; chars[2] == 'd' &amp;&amp; chars[3] == '5') { //$md5$</span>
<span class="fc" id="L102">                    int idx = lastIndexOf(chars, '$');</span>
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">                    if (idx &gt; 0) {</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">                        if (chars[idx - 1] == '$') {</span>
<span class="fc" id="L105">                            return A_SUN_CRYPT_MD5;</span>
                        } else {
<span class="fc" id="L107">                            return A_SUN_CRYPT_MD5_BARE_SALT;</span>
                        }
                    } else {
<span class="nc" id="L110">                        return 0;</span>
                    }
                } else {
<span class="nc" id="L113">                    return 0;</span>
                }
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">            } else if (chars[5] == '$') {</span>
<span class="nc bnc" id="L116" title="All 8 branches missed.">                if (chars[1] == 'a' &amp;&amp; chars[2] == 'p' &amp;&amp; chars[3] == 'r' &amp;&amp; chars[4] == '1') { //$apr1$</span>
<span class="nc" id="L117">                    return A_APACHE_HTDIGEST;</span>
                } else {
<span class="nc" id="L119">                    return 0;</span>
                }
<span class="pc bpc" id="L121" title="7 of 14 branches missed.">            } else if (chars[1] == 'm' &amp;&amp; chars[2] == 'a' &amp;&amp; chars[3] == 's' &amp;&amp; chars[4] == 'k' &amp;&amp; chars[5] == 'e' &amp;&amp; chars[6] == 'd' &amp;&amp; chars[7] == '-') { // $masked-</span>
<span class="fc" id="L122">                return A_MASKED;</span>
            }
            else {
<span class="nc" id="L125">                return 0;</span>
            }
<span class="fc bfc" id="L127" title="All 2 branches covered.">        } else if (chars[0] == '_') {</span>
<span class="fc" id="L128">            return A_BSD_CRYPT_DES;</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">        } else if (chars.length == 13) {</span>
<span class="fc" id="L130">            return A_CRYPT_DES;</span>
        } else {
<span class="fc" id="L132">            return 0;</span>
        }
    }


    /**
     * Attempt to identify the algorithm used by the given crypt string password.
     *
     * @param chars the password crypt string characters
     * @return the algorithm name, or {@code null} if no algorithm could be guessed
     */
    public static String identifyAlgorithm(char[] chars) {
<span class="fc" id="L144">        return getAlgorithmNameString(doIdentifyAlgorithm(chars));</span>
    }

    private static String getAlgorithmNameString(final int id) {
<span class="pc bpc" id="L148" title="9 of 11 branches missed.">        switch (id) {</span>
<span class="nc" id="L149">            case A_CRYPT_MD5:               return &quot;crypt-md5&quot;;</span>
<span class="fc" id="L150">            case A_BCRYPT:                  return &quot;bcrypt&quot;;</span>
<span class="nc" id="L151">            case A_BSD_NT_HASH:             return &quot;bsd-nt-hash&quot;;</span>
<span class="nc" id="L152">            case A_CRYPT_SHA_256:           return ALGORITHM_CRYPT_SHA_256;</span>
<span class="nc" id="L153">            case A_CRYPT_SHA_512:           return ALGORITHM_CRYPT_SHA_512;</span>
<span class="nc" id="L154">            case A_SUN_CRYPT_MD5:           return ALGORITHM_SUN_CRYPT_MD5;</span>
<span class="nc" id="L155">            case A_APACHE_HTDIGEST:         return &quot;apache-htdigest&quot;;</span>
<span class="nc" id="L156">            case A_BSD_CRYPT_DES:           return &quot;bsd-crypt-des&quot;;</span>
<span class="nc" id="L157">            case A_CRYPT_DES:               return &quot;crypt-des&quot;;</span>
<span class="nc" id="L158">            case A_SUN_CRYPT_MD5_BARE_SALT: return ALGORITHM_SUN_CRYPT_MD5_BARE_SALT;</span>
<span class="fc" id="L159">            default: return null;</span>
        }
    }

    /**
     * Encode the given {@link Password} to a char array.
     *
     * @param password the password to encode
     * @return a char array representing the encoded password
     * @throws InvalidKeySpecException if the given password is not supported or could be encoded
     */
    public static char[] encode(Password password) throws InvalidKeySpecException {
<span class="fc" id="L171">        StringBuilder b = getCryptStringToBuilder(password);</span>
<span class="fc" id="L172">        char[] chars = new char[b.length()];</span>
<span class="fc" id="L173">        b.getChars(0, b.length(), chars, 0);</span>
<span class="fc" id="L174">        return chars;</span>
    }

    /**
     * Encode the given {@link Password} to a string.
     *
     * @param password the password to encode
     * @return a string representing the encoded password
     * @throws InvalidKeySpecException if the given password is not supported or could be encoded
     */
    public static String encodeAsString(Password password) throws InvalidKeySpecException {
<span class="fc" id="L185">        return getCryptStringToBuilder(password).toString();</span>
    }

    private static StringBuilder getCryptStringToBuilder(Password password) throws InvalidKeySpecException {
<span class="fc" id="L189">        Assert.checkNotNullParam(&quot;password&quot;, password);</span>
<span class="fc" id="L190">        final StringBuilder b = new StringBuilder();</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">        if (password instanceof BCryptPassword) {</span>
<span class="fc" id="L192">            BCryptPassword spec = (BCryptPassword) password;</span>
<span class="fc" id="L193">            b.append(&quot;$2a$&quot;);</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">            if (spec.getIterationCount() &lt; 10)</span>
<span class="fc" id="L195">                b.append(0);</span>
<span class="fc" id="L196">            b.append(spec.getIterationCount());</span>
<span class="fc" id="L197">            b.append(&quot;$&quot;);</span>
<span class="fc" id="L198">            ByteIterator.ofBytes(spec.getSalt()).base64Encode(BCRYPT, false).drainTo(b);</span>
<span class="fc" id="L199">            ByteIterator.ofBytes(spec.getHash()).base64Encode(BCRYPT, false).drainTo(b);</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">        } else if (password instanceof BSDUnixDESCryptPassword) {</span>
<span class="fc" id="L201">            b.append('_');</span>
<span class="fc" id="L202">            final BSDUnixDESCryptPassword spec = (BSDUnixDESCryptPassword) password;</span>
<span class="fc" id="L203">            final int iterationCount = spec.getIterationCount();</span>
<span class="fc" id="L204">            b.appendCodePoint(MOD_CRYPT.encode(iterationCount &amp; 0x3f));</span>
<span class="fc" id="L205">            b.appendCodePoint(MOD_CRYPT.encode((iterationCount &gt;&gt; 6) &amp; 0x3f));</span>
<span class="fc" id="L206">            b.appendCodePoint(MOD_CRYPT.encode((iterationCount &gt;&gt; 12) &amp; 0x3f));</span>
<span class="fc" id="L207">            b.appendCodePoint(MOD_CRYPT.encode((iterationCount &gt;&gt; 18) &amp; 0x3f));</span>
<span class="fc" id="L208">            final int salt = spec.getSalt();</span>
<span class="fc" id="L209">            b.appendCodePoint(MOD_CRYPT.encode(salt &amp; 0x3f));</span>
<span class="fc" id="L210">            b.appendCodePoint(MOD_CRYPT.encode((salt &gt;&gt; 6) &amp; 0x3f));</span>
<span class="fc" id="L211">            b.appendCodePoint(MOD_CRYPT.encode((salt &gt;&gt; 12) &amp; 0x3f));</span>
<span class="fc" id="L212">            b.appendCodePoint(MOD_CRYPT.encode((salt &gt;&gt; 18) &amp; 0x3f));</span>
<span class="fc" id="L213">            ByteIterator.ofBytes(spec.getHash()).base64Encode(MOD_CRYPT, false).drainTo(b);</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">        } else if (password instanceof UnixDESCryptPassword) {</span>
<span class="fc" id="L215">            final UnixDESCryptPassword spec = (UnixDESCryptPassword) password;</span>
<span class="fc" id="L216">            final short salt = spec.getSalt();</span>
<span class="fc" id="L217">            b.appendCodePoint(MOD_CRYPT.encode(salt &amp; 0x3f));</span>
<span class="fc" id="L218">            b.appendCodePoint(MOD_CRYPT.encode((salt &gt;&gt; 6) &amp; 0x3f));</span>
<span class="fc" id="L219">            ByteIterator.ofBytes(spec.getHash()).base64Encode(MOD_CRYPT, false).drainTo(b);</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">        } else if (password instanceof UnixMD5CryptPassword) {</span>
<span class="fc" id="L221">            b.append(&quot;$1$&quot;);</span>
<span class="fc" id="L222">            final UnixMD5CryptPassword spec = (UnixMD5CryptPassword) password;</span>
<span class="fc" id="L223">            final byte[] salt = spec.getSalt();</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">            for (final byte sb : salt) {</span>
<span class="fc" id="L225">                b.append((char) (sb &amp; 0xff));</span>
            }
<span class="fc" id="L227">            b.append('$');</span>
<span class="fc" id="L228">            ByteIterator.ofBytes(spec.getHash(), MD5_IDX).base64Encode(MOD_CRYPT_LE, false).drainTo(b);</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">        } else if (password instanceof SunUnixMD5CryptPassword) {</span>
<span class="fc" id="L230">            final SunUnixMD5CryptPassword spec = (SunUnixMD5CryptPassword) password;</span>
<span class="fc" id="L231">            final int iterationCount = spec.getIterationCount();</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">            if (iterationCount &gt; 0) {</span>
<span class="fc" id="L233">                b.append(&quot;$md5,rounds=&quot;).append(iterationCount).append('$');</span>
            } else {
<span class="fc" id="L235">                b.append(&quot;$md5$&quot;);</span>
            }
<span class="fc" id="L237">            final byte[] salt = spec.getSalt();</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">            for (final byte sb : salt) {</span>
<span class="fc" id="L239">                b.append((char) (sb &amp; 0xff));</span>
            }
<span class="pc bpc" id="L241" title="1 of 3 branches missed.">            switch (spec.getAlgorithm()) {</span>
                case ALGORITHM_SUN_CRYPT_MD5: {
<span class="fc" id="L243">                    b.append(&quot;$$&quot;);</span>
<span class="fc" id="L244">                    break;</span>
                }
                case ALGORITHM_SUN_CRYPT_MD5_BARE_SALT: {
<span class="fc" id="L247">                    b.append(&quot;$&quot;);</span>
<span class="fc" id="L248">                    break;</span>
                }
                default: {
<span class="nc" id="L251">                    throw log.invalidKeySpecUnrecognizedKeySpecAlgorithm();</span>
                }
            }
<span class="fc" id="L254">            ByteIterator.ofBytes(spec.getHash(), MD5_IDX).base64Encode(MOD_CRYPT_LE, false).drainTo(b);</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">        } else if (password instanceof UnixSHACryptPassword) {</span>
<span class="fc" id="L256">            final UnixSHACryptPassword spec = (UnixSHACryptPassword) password;</span>
            final int[] interleave;
<span class="pc bpc" id="L258" title="1 of 3 branches missed.">            switch (spec.getAlgorithm()) {</span>
                case ALGORITHM_CRYPT_SHA_256: {
<span class="fc" id="L260">                    b.append(&quot;$5$&quot;);</span>
<span class="fc" id="L261">                    interleave = SHA_256_IDX;</span>
<span class="fc" id="L262">                    break;</span>
                }
                case ALGORITHM_CRYPT_SHA_512: {
<span class="fc" id="L265">                    b.append(&quot;$6$&quot;);</span>
<span class="fc" id="L266">                    interleave = SHA_512_IDX;</span>
<span class="fc" id="L267">                    break;</span>
                }
                default: {
<span class="nc" id="L270">                    throw log.invalidKeySpecUnrecognizedKeySpecAlgorithm();</span>
                }
            }
<span class="fc" id="L273">            final int iterationCount = spec.getIterationCount();</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">            if (iterationCount != 5_000) {</span>
<span class="fc" id="L275">                b.append(&quot;rounds=&quot;).append(iterationCount).append('$');</span>
            }
<span class="fc" id="L277">            final byte[] salt = spec.getSalt();</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">            for (final byte sb : salt) {</span>
<span class="fc" id="L279">                b.append((char) (sb &amp; 0xff));</span>
            }
<span class="fc" id="L281">            b.append('$');</span>
<span class="fc" id="L282">            ByteIterator.ofBytes(spec.getHash(), interleave).base64Encode(MOD_CRYPT_LE, false).drainTo(b);</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">        } else if (password instanceof MaskedPassword) {</span>
<span class="fc" id="L284">            final MaskedPassword spec = (MaskedPassword) password;</span>
<span class="fc" id="L285">            b.append('$').append(spec.getAlgorithm()).append('$');</span>

<span class="fc" id="L287">            b.append(spec.getInitialKeyMaterial()).append('$');</span>
<span class="fc" id="L288">            b.append(spec.getIterationCount()).append('$');</span>
<span class="fc" id="L289">            ByteIterator.ofBytes(spec.getSalt()).base64Encode().drainTo(b).append('$');</span>
<span class="fc" id="L290">            ByteIterator.ofBytes(spec.getMaskedPasswordBytes()).base64Encode().drainTo(b);</span>

<span class="fc bfc" id="L292" title="All 2 branches covered.">            if (spec.getInitializationVector() != null) {</span>
<span class="fc" id="L293">                b.append('$');</span>
<span class="fc" id="L294">                ByteIterator.ofBytes(spec.getInitializationVector()).base64Encode().drainTo(b);</span>
            }
<span class="fc" id="L296">        } else {</span>
<span class="nc" id="L297">            throw log.invalidKeySpecPasswordSpecCannotBeRenderedAsString();</span>
        }
<span class="fc" id="L299">        return b;</span>
    }

    /**
     * Decode the given string and creates a {@link Password} instance.
     *
     * @param cryptString the string representing the encoded format of the password
     * @return a {@link Password} instance created from the given string
     * @throws InvalidKeySpecException if the given password is not supported or could be decoded
     */
    public static Password decode(String cryptString) throws InvalidKeySpecException {
<span class="fc" id="L310">        Assert.checkNotNullParam(&quot;cryptString&quot;, cryptString);</span>
<span class="fc" id="L311">        return decode(cryptString.toCharArray());</span>
    }

    /**
     * Decode the given char array and creates a {@link Password} instance.
     *
     * @param cryptString the char array representing the encoded format of the password
     * @return a {@link Password} instance created from the given string
     * @throws InvalidKeySpecException if the given password is not supported or could be decoded
     */
    public static Password decode(char[] cryptString) throws InvalidKeySpecException {
<span class="fc" id="L322">        Assert.checkNotNullParam(&quot;cryptString&quot;, cryptString);</span>
<span class="fc" id="L323">        final int algorithmId = doIdentifyAlgorithm(cryptString);</span>
<span class="pc bpc" id="L324" title="3 of 12 branches missed.">        switch (algorithmId) {</span>
            case A_CRYPT_MD5: {
<span class="fc" id="L326">                return parseUnixMD5CryptPasswordString(cryptString);</span>
            }
            case A_BCRYPT: {
<span class="fc" id="L329">                return parseBCryptPasswordString(cryptString);</span>
            }
            case A_BSD_NT_HASH: {
<span class="nc" id="L332">                throw new UnsupportedOperationException(&quot;not supported yet&quot;);</span>
            }
            case A_CRYPT_SHA_256: {
<span class="fc" id="L335">                return parseUnixSHA256CryptPasswordString(cryptString);</span>
            }
            case A_CRYPT_SHA_512: {
<span class="fc" id="L338">                return parseUnixSHA512CryptPasswordString(cryptString);</span>
            }
            case A_SUN_CRYPT_MD5: {
<span class="fc" id="L341">                return parseSunUnixMD5CryptPasswordString(ALGORITHM_SUN_CRYPT_MD5, cryptString);</span>
            }
            case A_SUN_CRYPT_MD5_BARE_SALT: {
<span class="fc" id="L344">                return parseSunUnixMD5CryptPasswordString(ALGORITHM_SUN_CRYPT_MD5_BARE_SALT, cryptString);</span>
            }
            case A_APACHE_HTDIGEST: {
<span class="nc" id="L347">                throw new UnsupportedOperationException(&quot;not supported yet&quot;);</span>
            }
            case A_BSD_CRYPT_DES: {
<span class="fc" id="L350">                return parseBSDUnixDESCryptPasswordString(cryptString);</span>
            }
            case A_CRYPT_DES: {
<span class="fc" id="L353">                return parseUnixDESCryptPasswordString(cryptString);</span>
            }
            case A_MASKED: {
<span class="fc" id="L356">                return parseMaskedPasswordString(cryptString);</span>
            }
<span class="nc" id="L358">            default: throw log.invalidKeySpecUnknownCryptStringAlgorithm();</span>
        }
    }

    public static Password createPassword(byte[] password, String algorithm) throws InvalidKeySpecException {
<span class="fc" id="L363">        Assert.checkNotNullParam(&quot;password&quot;, password);</span>
<span class="fc" id="L364">        Assert.checkNotNullParam(&quot;algorithm&quot;, algorithm);</span>
<span class="pc bpc" id="L365" title="1 of 3 branches missed.">        switch(algorithm) {</span>
            case UnixDESCryptPassword.ALGORITHM_CRYPT_DES: {
<span class="fc" id="L367">                return createCryptBasedPassword(password);</span>
            }
            case BSDUnixDESCryptPassword.ALGORITHM_BSD_CRYPT_DES: {
<span class="fc" id="L370">                return createBsdCryptBasedPassword(password);</span>
            }
<span class="nc" id="L372">            default: throw log.invalidKeySpecUnknownCryptStringAlgorithm();</span>
        }
    }

    public static void composePassword(ByteArrayOutputStream out, Password password) throws IOException {
<span class="fc" id="L377">        Assert.checkNotNullParam(&quot;out&quot;, out);</span>
<span class="fc" id="L378">        Assert.checkNotNullParam(&quot;password&quot;, password);</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">        if (password instanceof UnixDESCryptPassword) {</span>
<span class="fc" id="L380">            composeCryptBasedPassword(out, (UnixDESCryptPassword) password);</span>
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">        } else if (password instanceof  BSDUnixDESCryptPassword) {</span>
<span class="fc" id="L382">            composeBsdCryptBasedPassword(out, (BSDUnixDESCryptPassword) password);</span>
        }
<span class="fc" id="L384">    }</span>

    private static int parseModCryptIterationCount(final CodePointIterator reader, final int minIterations, final int maxIterations,
            final int defaultIterations) throws InvalidKeySpecException {
        int iterationCount;
<span class="fc" id="L389">        final CodePointIterator dr = reader.delimitedBy('$');</span>
        try {
<span class="fc bfc" id="L391" title="All 2 branches covered.">            if (dr.limitedTo(7).contentEquals(CodePointIterator.ofString(&quot;rounds=&quot;))) {</span>
<span class="fc" id="L392">                iterationCount = 0;</span>
                int ch;
<span class="fc bfc" id="L394" title="All 2 branches covered.">                while (dr.hasNext()) {</span>
<span class="fc" id="L395">                    ch = dr.next();</span>
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">                    if (iterationCount != maxIterations) {</span>
<span class="pc bpc" id="L397" title="2 of 4 branches missed.">                        if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') {</span>
                            // multiply by 10, add next
<span class="fc" id="L399">                            iterationCount = (iterationCount &lt;&lt; 3) + (iterationCount &lt;&lt; 1) + ch - '0';</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">                            if (iterationCount &gt; maxIterations) {</span>
                                // stop overflow
<span class="fc" id="L402">                                iterationCount = maxIterations;</span>
                            }
                        }
                    } else {
<span class="nc" id="L406">                        throw log.invalidKeySpecInvalidCharacterEncountered();</span>
                    }
                }
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">                if (! reader.hasNext()) {</span>
<span class="nc" id="L410">                    throw log.invalidKeySpecNoIterationCountTerminatorGiven();</span>
                }
<span class="fc" id="L412">                reader.next(); // skip $</span>
            } else {
<span class="fc" id="L414">                iterationCount = defaultIterations;</span>
            }
<span class="nc" id="L416">        } catch (NoSuchElementException ignored) {</span>
<span class="nc" id="L417">            throw log.invalidKeySpecUnexpectedEndOfInputString();</span>
<span class="fc" id="L418">        }</span>
<span class="fc" id="L419">        return max(minIterations, iterationCount);</span>
    }

    private static int[] inverse(int[] orig) {
<span class="fc" id="L423">        final int[] n = new int[orig.length];</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">        for (int i = 0; i &lt; orig.length; i ++) {</span>
<span class="fc" id="L425">            n[orig[i]] = i;</span>
        }
<span class="fc" id="L427">        return n;</span>
    }

<span class="fc" id="L430">    private static final int[] MD5_IDX = {</span>
        12,  6,  0,
        13,  7,  1,
        14,  8,  2,
        15,  9,  3,
         5, 10,  4,
            11
    };

<span class="fc" id="L439">    private static final int[] MD5_IDX_REV = inverse(MD5_IDX);</span>

<span class="fc" id="L441">    private static final int[] SHA_256_IDX = {</span>
                20, 10,  0,
        11,  1, 21,
             2, 22, 12,
                23, 13,  3,
        14,  4, 24,
             5, 25, 15,
                26, 16,  6,
        17,  7, 27,
             8, 28, 18,
                29, 19,  9,
                30,
                31
    };

<span class="fc" id="L456">    private static final int[] SHA_256_IDX_REV = inverse(SHA_256_IDX);</span>

<span class="fc" id="L458">    private static final int[] SHA_512_IDX = {</span>
            42, 21,  0,
         1, 43, 22,
                23,  2, 44,
            45, 24,  3,
         4, 46, 25,
                26,  5, 47,
            48, 27,  6,
         7, 49, 28,
                29,  8, 50,
            51, 30,  9,
        10, 52, 31,
                32, 11, 53,
            54, 33, 12,
        13, 55, 34,
                35, 14, 56,
            57, 36, 15,
        16, 58, 37,
                38, 17, 59,
            60, 39, 18,
        19, 61, 40,
                41, 20, 62,
                        63
    };

<span class="fc" id="L483">    private static final int[] SHA_512_IDX_REV = inverse(SHA_512_IDX);</span>

    private static Password parseUnixSHA256CryptPasswordString(char[] cryptString) throws InvalidKeySpecException {
<span class="pc bpc" id="L486" title="2 of 4 branches missed.">        assert cryptString[0] == '$'; // previously tested by doIdentifyAlgorithm</span>
<span class="pc bpc" id="L487" title="2 of 4 branches missed.">        assert cryptString[1] == '5'; // previously tested by doIdentifyAlgorithm</span>
<span class="pc bpc" id="L488" title="2 of 4 branches missed.">        assert cryptString[2] == '$'; // previously tested by doIdentifyAlgorithm</span>
<span class="fc" id="L489">        return parseUnixSHACryptPassword(cryptString, SHA_256_IDX_REV, ALGORITHM_CRYPT_SHA_256);</span>
    }

    private static Password parseUnixSHA512CryptPasswordString(char[] cryptString) throws InvalidKeySpecException {
<span class="pc bpc" id="L493" title="2 of 4 branches missed.">        assert cryptString[0] == '$'; // previously tested by doIdentifyAlgorithm</span>
<span class="pc bpc" id="L494" title="2 of 4 branches missed.">        assert cryptString[1] == '6'; // previously tested by doIdentifyAlgorithm</span>
<span class="pc bpc" id="L495" title="2 of 4 branches missed.">        assert cryptString[2] == '$'; // previously tested by doIdentifyAlgorithm</span>
<span class="fc" id="L496">        return parseUnixSHACryptPassword(cryptString, SHA_512_IDX_REV, ALGORITHM_CRYPT_SHA_512);</span>
    }

    private static Password parseUnixSHACryptPassword(final char[] cryptString, final int[] table, final String algorithm) throws InvalidKeySpecException {
<span class="fc" id="L500">        CodePointIterator r = CodePointIterator.ofChars(cryptString, 3);</span>
        try {
            final int iterationCount; // spec default

            // iteration count
<span class="fc" id="L505">            iterationCount = parseModCryptIterationCount(r, 1_000, 999_999_999, 5_000);</span>

<span class="fc" id="L507">            byte[] salt = r.delimitedBy('$').drainToString().getBytes(StandardCharsets.ISO_8859_1);</span>
<span class="pc bpc" id="L508" title="1 of 2 branches missed.">            if (! r.hasNext()) {</span>
<span class="nc" id="L509">                throw log.invalidKeySpecNoSaltTerminatorGiven();</span>
            }
<span class="fc" id="L511">            r.next(); // skip $</span>
<span class="fc" id="L512">            final byte[] decoded = r.base64Decode(MOD_CRYPT_LE, false).limitedTo(table.length).drain();</span>
<span class="pc bpc" id="L513" title="1 of 2 branches missed.">            if (decoded.length != table.length) {</span>
<span class="nc" id="L514">                throw log.invalidHashLength();</span>
            }
<span class="fc" id="L516">            byte[] hash = ByteIterator.ofBytes(decoded, table).drain();</span>
<span class="fc" id="L517">            return UnixSHACryptPassword.createRaw(algorithm, salt, hash, iterationCount);</span>
<span class="nc" id="L518">        } catch (NoSuchElementException e) {</span>
<span class="nc" id="L519">            throw log.invalidKeySpecUnexpectedEndOfPasswordStringWithCause(e);</span>
        }
    }

    private static Password parseUnixMD5CryptPasswordString(final char[] cryptString) throws InvalidKeySpecException {
<span class="pc bpc" id="L524" title="2 of 4 branches missed.">        assert cryptString[0] == '$'; // previously tested by doIdentifyAlgorithm</span>
<span class="pc bpc" id="L525" title="2 of 4 branches missed.">        assert cryptString[1] == '1'; // previously tested by doIdentifyAlgorithm</span>
<span class="pc bpc" id="L526" title="2 of 4 branches missed.">        assert cryptString[2] == '$'; // previously tested by doIdentifyAlgorithm</span>
<span class="fc" id="L527">        CodePointIterator r = CodePointIterator.ofChars(cryptString, 3);</span>
        try {
<span class="fc" id="L529">            final byte[] salt = r.delimitedBy('$').drainToString().getBytes(StandardCharsets.ISO_8859_1);</span>
<span class="pc bpc" id="L530" title="1 of 2 branches missed.">            if (! r.hasNext()) {</span>
<span class="nc" id="L531">                throw log.invalidKeySpecNoSaltTerminatorGiven();</span>
            }
<span class="fc" id="L533">            r.next(); // skip $</span>
<span class="fc" id="L534">            final byte[] decoded = r.base64Decode(MOD_CRYPT_LE, false).limitedTo(MD5_IDX_REV.length).drain();</span>
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">            if (decoded.length != MD5_IDX.length) {</span>
<span class="nc" id="L536">                throw log.invalidHashLength();</span>
            }

<span class="fc" id="L539">            byte[] hash = ByteIterator.ofBytes(decoded, MD5_IDX_REV).drain();</span>
<span class="fc" id="L540">            return UnixMD5CryptPassword.createRaw(UnixMD5CryptPassword.ALGORITHM_CRYPT_MD5, salt, hash);</span>
<span class="nc" id="L541">        } catch (NoSuchElementException e) {</span>
<span class="nc" id="L542">            throw log.invalidKeySpecUnexpectedEndOfPasswordStringWithCause(e);</span>
        }
    }

    private static Password parseSunUnixMD5CryptPasswordString(final String algorithm, final char[] cryptString) throws InvalidKeySpecException {
<span class="pc bpc" id="L547" title="2 of 4 branches missed.">        assert cryptString[0] == '$'; // previously tested by doIdentifyAlgorithm</span>
<span class="pc bpc" id="L548" title="2 of 4 branches missed.">        assert cryptString[1] == 'm'; // previously tested by doIdentifyAlgorithm</span>
<span class="pc bpc" id="L549" title="2 of 4 branches missed.">        assert cryptString[2] == 'd'; // previously tested by doIdentifyAlgorithm</span>
<span class="pc bpc" id="L550" title="2 of 4 branches missed.">        assert cryptString[3] == '5'; // previously tested by doIdentifyAlgorithm</span>
<span class="pc bpc" id="L551" title="2 of 6 branches missed.">        assert (cryptString[4] == '$' || cryptString[4] == ','); // previously tested by doIdentifyAlgorithm</span>
<span class="fc" id="L552">        CodePointIterator r = CodePointIterator.ofChars(cryptString, 5);</span>
        try {
            final int iterationCount;
<span class="fc bfc" id="L555" title="All 2 branches covered.">            if (cryptString[4] == ',') {</span>
                // The spec doesn't specify a maximum number of rounds but we're using 2,147,479,551
                // to prevent overflow (2,147,483,647 - 4,096 = 2,147,479,551)
<span class="fc" id="L558">                iterationCount = parseModCryptIterationCount(r, 0, 2_147_479_551, 0);</span>
            } else {
<span class="fc" id="L560">                iterationCount = 0;</span>
            }
<span class="fc" id="L562">            final byte[] salt = r.delimitedBy('$').drainToString().getBytes(StandardCharsets.ISO_8859_1);</span>
<span class="pc bpc" id="L563" title="1 of 2 branches missed.">            if (! r.hasNext()) {</span>
<span class="nc" id="L564">                throw log.invalidKeySpecNoSaltTerminatorGiven();</span>
            }
<span class="fc" id="L566">            r.next();</span>

            // Consume the second '$' after the salt, if present. Note that crypt strings returned
            // by the Sun implementation can have one of the following two formats:
            // 1) $md5[,rounds={rounds}]${salt}$${hash} (this format is more common)
            // 2) $md5[,rounds={rounds}]${salt}${hash} (because there's only a single '$' after the
            //                                          salt, this is referred to as a &quot;bare salt&quot;)
<span class="pc bpc" id="L573" title="2 of 6 branches missed.">            if (algorithm.equals(ALGORITHM_SUN_CRYPT_MD5) &amp;&amp; r.hasNext() &amp;&amp; r.peekNext() == '$') {</span>
<span class="fc" id="L574">                r.next(); // discard $</span>
            }

<span class="fc" id="L577">            byte[] decoded = r.base64Decode(MOD_CRYPT_LE, false).limitedTo(MD5_IDX_REV.length).drain();</span>
<span class="pc bpc" id="L578" title="1 of 2 branches missed.">            if (decoded.length != MD5_IDX.length) {</span>
<span class="nc" id="L579">                throw log.invalidHashLength();</span>
            }

<span class="fc" id="L582">            byte[] hash = ByteIterator.ofBytes(decoded, MD5_IDX_REV).drain();</span>
<span class="fc" id="L583">            return SunUnixMD5CryptPassword.createRaw(algorithm, salt, hash, iterationCount);</span>
<span class="nc" id="L584">        } catch (NoSuchElementException e) {</span>
<span class="nc" id="L585">            throw log.invalidKeySpecUnexpectedEndOfPasswordStringWithCause(e);</span>
        }
    }

    private static Password parseBCryptPasswordString(final char[] cryptString) throws InvalidKeySpecException {
<span class="pc bpc" id="L590" title="2 of 4 branches missed.">        assert cryptString[0] == '$'; // previously tested by doIdentifyAlgorithm</span>
<span class="pc bpc" id="L591" title="2 of 4 branches missed.">        assert cryptString[1] == '2'; // previously tested by doIdentifyAlgorithm</span>
<span class="fc" id="L592">        char minor = 0;</span>
<span class="pc bpc" id="L593" title="1 of 2 branches missed.">        if (cryptString[2] != '$') {</span>
<span class="fc" id="L594">            minor = cryptString[2];</span>
<span class="pc bpc" id="L595" title="5 of 6 branches missed.">            if (minor != 'a' &amp;&amp; minor != 'x' &amp;&amp; minor != 'y') {</span>
<span class="nc" id="L596">                throw log.invalidKeySpecInvalidMinorVersion();</span>
            }
<span class="pc bpc" id="L598" title="2 of 4 branches missed.">            assert cryptString[3] == '$';</span>
        }

<span class="pc bpc" id="L601" title="1 of 2 branches missed.">        CodePointIterator r = CodePointIterator.ofChars(cryptString, minor == 0 ? 3 : 4);</span>
        try {
            // read the bcrypt cost (number of rounds in log format)
<span class="fc" id="L604">            int cost = Integer.parseInt(r.limitedTo(2).drainToString());</span>
<span class="pc bpc" id="L605" title="2 of 4 branches missed.">            if (r.hasNext() &amp;&amp; r.peekNext() != '$') {</span>
<span class="nc" id="L606">                throw log.invalidKeySpecCostMustBeTwoDigitInteger();</span>
            }
            // discard the '$'
<span class="pc bpc" id="L609" title="1 of 2 branches missed.">            if (! r.hasNext()) {</span>
<span class="nc" id="L610">                throw log.invalidKeySpecUnexpectedEndOfPasswordString();</span>
            }
<span class="fc" id="L612">            r.next();</span>

            // the next 22 characters correspond to the encoded salt - it is mapped to a 16-byte array after decoding.
<span class="fc" id="L615">            byte[] decodedSalt = r.limitedTo(22).base64Decode(BCRYPT, false).drain();</span>

            // the final 31 characters correspond to the encoded password - it is mapped to a 23-byte array after decoding.
<span class="fc" id="L618">            byte[] decodedPassword = r.limitedTo(31).base64Decode(BCRYPT, false).drain();</span>

<span class="fc" id="L620">            return BCryptPassword.createRaw(BCryptPassword.ALGORITHM_BCRYPT, decodedPassword, decodedSalt, cost);</span>
<span class="nc" id="L621">        } catch (NoSuchElementException e) {</span>
<span class="nc" id="L622">            throw log.invalidKeySpecUnexpectedEndOfPasswordStringWithCause(e);</span>
        }
    }

    private static Password parseUnixDESCryptPasswordString(char[] cryptString) throws InvalidKeySpecException {
<span class="pc bpc" id="L627" title="2 of 4 branches missed.">        assert cryptString.length == 13; // previously tested by doIdentifyAlgorithm</span>
<span class="fc" id="L628">        CodePointIterator r = CodePointIterator.ofChars(cryptString);</span>
        // 12 bit salt
<span class="fc" id="L630">        int s0 = MOD_CRYPT.decode(r.next());</span>
<span class="fc" id="L631">        int s1 = MOD_CRYPT.decode(r.next());</span>
<span class="fc" id="L632">        short salt = (short) (s0 | s1 &lt;&lt; 6);</span>
        // 64 bit hash
<span class="fc" id="L634">        byte[] hash = r.base64Decode(MOD_CRYPT, false).limitedTo(8).drain();</span>
<span class="fc" id="L635">        return UnixDESCryptPassword.createRaw(UnixDESCryptPassword.ALGORITHM_CRYPT_DES, salt, hash);</span>
    }

    private static Password parseBSDUnixDESCryptPasswordString(char[] cryptString) throws InvalidKeySpecException {
        // Note that crypt strings have the format: &quot;_{rounds}{salt}{hash}&quot; as described
        // in the &quot;DES Extended Format&quot; section here: http://www.freebsd.org/cgi/man.cgi?crypt(3)

<span class="pc bpc" id="L642" title="2 of 4 branches missed.">        assert cryptString.length == 20;</span>
<span class="pc bpc" id="L643" title="2 of 4 branches missed.">        assert cryptString[0] == '_'; // previously tested by doIdentifyAlgorithm</span>

<span class="fc" id="L645">        CodePointIterator r = CodePointIterator.ofChars(cryptString, 1);</span>

        // The next 4 characters correspond to the encoded number of rounds - this is decoded to a 24-bit integer
<span class="fc" id="L648">        int s0 = MOD_CRYPT.decode(r.next());</span>
<span class="fc" id="L649">        int s1 = MOD_CRYPT.decode(r.next());</span>
<span class="fc" id="L650">        int s2 = MOD_CRYPT.decode(r.next());</span>
<span class="fc" id="L651">        int s3 = MOD_CRYPT.decode(r.next());</span>
<span class="fc" id="L652">        int iterationCount = s0 | s1 &lt;&lt; 6 | s2 &lt;&lt; 12 | s3 &lt;&lt; 18;</span>

        // The next 4 characters correspond to the encoded salt - this is decoded to a 24-bit integer
<span class="fc" id="L655">        s0 = MOD_CRYPT.decode(r.next());</span>
<span class="fc" id="L656">        s1 = MOD_CRYPT.decode(r.next());</span>
<span class="fc" id="L657">        s2 = MOD_CRYPT.decode(r.next());</span>
<span class="fc" id="L658">        s3 = MOD_CRYPT.decode(r.next());</span>
<span class="fc" id="L659">        int salt = s0 | s1 &lt;&lt; 6 | s2 &lt;&lt; 12 | s3 &lt;&lt; 18;</span>

        // The final 11 characters correspond to the encoded password - this is decoded to a 64-bit hash
<span class="fc" id="L662">        byte[] hash = r.base64Decode(MOD_CRYPT, false).limitedTo(11).drain();</span>
<span class="fc" id="L663">        return BSDUnixDESCryptPassword.createRaw(BSDUnixDESCryptPassword.ALGORITHM_BSD_CRYPT_DES, hash, salt, iterationCount);</span>
    }

    private static Password parseMaskedPasswordString(char[] chars) throws InvalidKeySpecException {
<span class="pc bpc" id="L667" title="3 of 6 branches missed.">        assert chars[0] == '$' &amp;&amp; chars[7] == '-';</span>
<span class="fc" id="L668">        CodePointIterator r = CodePointIterator.ofChars(chars, 1);</span>

<span class="fc" id="L670">        String algorithm = r.delimitedBy('$').drainToString();</span>
<span class="pc bpc" id="L671" title="1 of 2 branches missed.">        if (! MaskedPassword.isMaskedAlgorithm(algorithm)) {</span>
<span class="nc" id="L672">            throw log.invalidKeySpecInvalidMinorVersion();</span>
        }
<span class="pc bpc" id="L674" title="1 of 2 branches missed.">        if (! r.hasNext()) throw log.invalidKeySpecNoSaltTerminatorGiven();</span>
<span class="fc" id="L675">        r.next(); // skip $ delimiter</span>

<span class="fc" id="L677">        char[] keyMaterial = r.delimitedBy('$').drainToString().toCharArray();</span>
<span class="pc bpc" id="L678" title="1 of 2 branches missed.">        if (! r.hasNext()) throw log.invalidKeySpecNoSaltTerminatorGiven();</span>
<span class="fc" id="L679">        r.next(); // skip $ delimiter</span>

<span class="fc" id="L681">        int iterationCount = Integer.valueOf(r.delimitedBy('$').drainToString());</span>
<span class="pc bpc" id="L682" title="1 of 2 branches missed.">        if (! r.hasNext()) throw log.invalidKeySpecNoSaltTerminatorGiven();</span>
<span class="fc" id="L683">        r.next(); // skip $ delimiter</span>

<span class="fc" id="L685">        byte[] salt = r.delimitedBy('$').base64Decode().drain();</span>
<span class="pc bpc" id="L686" title="1 of 2 branches missed.">        if (! r.hasNext()) throw log.invalidKeySpecNoSaltTerminatorGiven();</span>
<span class="fc" id="L687">        r.next(); // skip $ delimiter</span>

<span class="fc" id="L689">        byte[] maskedPasswordBytes = r.delimitedBy('$').base64Decode().drain();</span>

<span class="fc" id="L691">        byte[] initializationVector = null;</span>
<span class="fc bfc" id="L692" title="All 2 branches covered.">        if (r.hasNext()) { // has IV</span>
<span class="fc" id="L693">            r.next(); // skip $ delimiter</span>
<span class="fc" id="L694">            initializationVector = r.base64Decode().drain();</span>
        }

<span class="fc" id="L697">        return MaskedPassword.createRaw(algorithm, keyMaterial, iterationCount, salt, maskedPasswordBytes, initializationVector);</span>
    }

    private static int lastIndexOf(final char[] chars, final char c) {
<span class="pc bpc" id="L701" title="1 of 2 branches missed.">        for (int i = (chars.length - 1); i &gt;= 0; i--) {</span>
<span class="fc bfc" id="L702" title="All 2 branches covered.">            if (chars[i] == c) return i;</span>
        }
<span class="nc" id="L704">        return -1;</span>
    }

    private static Password createCryptBasedPassword(byte[] userPassword) throws InvalidKeySpecException {
<span class="pc bpc" id="L708" title="1 of 2 branches missed.">        if (userPassword.length != 20) {</span>
<span class="nc" id="L709">            throw log.insufficientDataToFormDigestAndSalt();</span>
        }

<span class="fc" id="L712">        final int lo = MOD_CRYPT.decode(userPassword[7] &amp; 0xff);</span>
<span class="fc" id="L713">        final int hi = MOD_CRYPT.decode(userPassword[8] &amp; 0xff);</span>
<span class="pc bpc" id="L714" title="2 of 4 branches missed.">        if (lo == -1 || hi == -1) {</span>
<span class="nc" id="L715">            throw log.invalidSalt((char) lo, (char) hi);</span>
        }
<span class="fc" id="L717">        short salt = (short) (lo | hi &lt;&lt; 6);</span>
<span class="fc" id="L718">        byte[] hash = CodePointIterator.ofUtf8Bytes(userPassword, 9, 11).base64Decode(MOD_CRYPT, false).drain();</span>

<span class="fc" id="L720">        return UnixDESCryptPassword.createRaw(ALGORITHM_CRYPT_DES, salt, hash);</span>
    }

    private static Password createBsdCryptBasedPassword(byte[] userPassword) throws InvalidKeySpecException {
<span class="pc bpc" id="L724" title="1 of 2 branches missed.">        if (userPassword.length != 27) {</span>
<span class="nc" id="L725">            throw log.insufficientDataToFormDigestAndSalt();</span>
        }

<span class="fc" id="L728">        int b0 = MOD_CRYPT.decode(userPassword[8] &amp; 0xff);</span>
<span class="fc" id="L729">        int b1 = MOD_CRYPT.decode(userPassword[9] &amp; 0xff);</span>
<span class="fc" id="L730">        int b2 = MOD_CRYPT.decode(userPassword[10] &amp; 0xff);</span>
<span class="fc" id="L731">        int b3 = MOD_CRYPT.decode(userPassword[11] &amp; 0xff);</span>
<span class="pc bpc" id="L732" title="4 of 8 branches missed.">        if (b0 == -1 || b1 == -1 || b2 == -1 || b3 == -1) {</span>
<span class="nc" id="L733">            throw log.invalidRounds((char) b0, (char) b1, (char) b2, (char) b3);</span>
        }
<span class="fc" id="L735">        int iterationCount = b0 | b1 &lt;&lt; 6 | b2 &lt;&lt; 12 | b3 &lt;&lt; 18;</span>

<span class="fc" id="L737">        b0 = MOD_CRYPT.decode(userPassword[12] &amp; 0xff);</span>
<span class="fc" id="L738">        b1 = MOD_CRYPT.decode(userPassword[13] &amp; 0xff);</span>
<span class="fc" id="L739">        b2 = MOD_CRYPT.decode(userPassword[14] &amp; 0xff);</span>
<span class="fc" id="L740">        b3 = MOD_CRYPT.decode(userPassword[15] &amp; 0xff);</span>
<span class="pc bpc" id="L741" title="4 of 8 branches missed.">        if (b0 == -1 || b1 == -1 || b2 == -1 || b3 == -1) {</span>
<span class="nc" id="L742">            throw log.invalidSalt((char) b0, (char) b1, (char) b2, (char) b3);</span>
        }
<span class="fc" id="L744">        int salt = b0 | b1 &lt;&lt; 6 | b2 &lt;&lt; 12 | b3 &lt;&lt; 18;</span>

<span class="fc" id="L746">        byte[] hash = CodePointIterator.ofUtf8Bytes(userPassword, 16, 11).base64Decode(MOD_CRYPT, false).drain();</span>
<span class="fc" id="L747">        return BSDUnixDESCryptPassword.createRaw(ALGORITHM_BSD_CRYPT_DES, hash, salt, iterationCount);</span>
    }

    private static void composeCryptBasedPassword(ByteArrayOutputStream out, UnixDESCryptPassword password) throws IOException {
<span class="fc" id="L751">        out.write(MOD_CRYPT.encode(password.getSalt() &amp; 0x3f));</span>
<span class="fc" id="L752">        out.write(MOD_CRYPT.encode(password.getSalt() &gt;&gt; 6 &amp; 0x3f));</span>
<span class="fc" id="L753">        out.write(ByteIterator.ofBytes(password.getHash()).base64Encode(MOD_CRYPT, false).asUtf8().drain());</span>
<span class="fc" id="L754">    }</span>

    private static void composeBsdCryptBasedPassword(ByteArrayOutputStream out, BSDUnixDESCryptPassword password) throws IOException {

<span class="fc" id="L758">        out.write(MOD_CRYPT.encode(password.getIterationCount() &amp; 0x3f));</span>
<span class="fc" id="L759">        out.write(MOD_CRYPT.encode(password.getIterationCount() &gt;&gt; 6 &amp; 0x3f));</span>
<span class="fc" id="L760">        out.write(MOD_CRYPT.encode(password.getIterationCount() &gt;&gt; 12 &amp; 0x3f));</span>
<span class="fc" id="L761">        out.write(MOD_CRYPT.encode(password.getIterationCount() &gt;&gt; 18 &amp; 0x3f));</span>

<span class="fc" id="L763">        out.write(MOD_CRYPT.encode(password.getSalt() &amp; 0x3f));</span>
<span class="fc" id="L764">        out.write(MOD_CRYPT.encode(password.getSalt() &gt;&gt; 6 &amp; 0x3f));</span>
<span class="fc" id="L765">        out.write(MOD_CRYPT.encode(password.getSalt() &gt;&gt; 12 &amp; 0x3f));</span>
<span class="fc" id="L766">        out.write(MOD_CRYPT.encode(password.getSalt() &gt;&gt; 18 &amp; 0x3f));</span>

<span class="fc" id="L768">        out.write(ByteIterator.ofBytes(password.getHash()).base64Encode(MOD_CRYPT, false).asUtf8().drain());</span>
<span class="fc" id="L769">    }</span>

    /**
     * The modular crypt alphabet, used in various modular crypt password types.
     */
<span class="fc" id="L774">    static final Base64Alphabet MOD_CRYPT = new ModCryptBase64Alphabet(false);</span>

    /**
     * The modular crypt alphabet, used in various modular crypt password types.
     */
<span class="fc" id="L779">    static final Base64Alphabet MOD_CRYPT_LE = new ModCryptBase64Alphabet(true);</span>

    /**
     * The BCrypt alphabet.
     */
<span class="pc bpc" id="L784" title="1 of 2 branches missed.">    static final Base64Alphabet BCRYPT = new Base64Alphabet(false) {</span>
        public int encode(final int val) {
<span class="fc bfc" id="L786" title="All 2 branches covered.">            if (val == 0) {</span>
<span class="fc" id="L787">                return '.';</span>
<span class="fc bfc" id="L788" title="All 2 branches covered.">            } else if (val == 1) {</span>
<span class="fc" id="L789">                return '/';</span>
<span class="fc bfc" id="L790" title="All 2 branches covered.">            } else if (val &lt;= 27) {</span>
<span class="fc" id="L791">                return 'A' + val - 2;</span>
<span class="fc bfc" id="L792" title="All 2 branches covered.">            } else if (val &lt;= 53) {</span>
<span class="fc" id="L793">                return 'a' + val - 28;</span>
            } else {
<span class="pc bpc" id="L795" title="2 of 4 branches missed.">                assert val &lt; 64;</span>
<span class="fc" id="L796">                return '0' + val - 54;</span>
            }
        }

        public int decode(final int codePoint) {
<span class="fc bfc" id="L801" title="All 2 branches covered.">            if (codePoint == '.') {</span>
<span class="fc" id="L802">                return 0;</span>
<span class="fc bfc" id="L803" title="All 2 branches covered.">            } else if (codePoint == '/') {</span>
<span class="fc" id="L804">                return 1;</span>
<span class="fc bfc" id="L805" title="All 4 branches covered.">            } else if ('A' &lt;= codePoint &amp;&amp; codePoint &lt;= 'Z') {</span>
<span class="fc" id="L806">                return codePoint - 'A' + 2;</span>
<span class="pc bpc" id="L807" title="1 of 4 branches missed.">            } else if ('a' &lt;= codePoint &amp;&amp; codePoint &lt;= 'z') {</span>
<span class="fc" id="L808">                return codePoint - 'a' + 28;</span>
<span class="pc bpc" id="L809" title="2 of 4 branches missed.">            } else if ('0' &lt;= codePoint &amp;&amp; codePoint &lt;= '9') {</span>
<span class="fc" id="L810">                return codePoint - '0' + 54;</span>
            } else {
<span class="nc" id="L812">                return -1;</span>
            }
        }
    };

<span class="pc bpc" id="L817" title="1 of 2 branches missed.">    private static class ModCryptBase64Alphabet extends Base64Alphabet {</span>
        ModCryptBase64Alphabet(final boolean littleEndian) {
<span class="fc" id="L819">            super(littleEndian);</span>
<span class="fc" id="L820">        }</span>

        public int encode(final int val) {
<span class="fc bfc" id="L823" title="All 2 branches covered.">            if (val == 0) {</span>
<span class="fc" id="L824">                return '.';</span>
<span class="fc bfc" id="L825" title="All 2 branches covered.">            } else if (val == 1) {</span>
<span class="fc" id="L826">                return '/';</span>
<span class="fc bfc" id="L827" title="All 2 branches covered.">            } else if (val &lt;= 11) {</span>
<span class="fc" id="L828">                return '0' + val - 2;</span>
<span class="fc bfc" id="L829" title="All 2 branches covered.">            } else if (val &lt;= 37) {</span>
<span class="fc" id="L830">                return 'A' + val - 12;</span>
            } else {
<span class="pc bpc" id="L832" title="2 of 4 branches missed.">                assert val &lt; 64;</span>
<span class="fc" id="L833">                return 'a' + val - 38;</span>
            }
        }

        public int decode(final int codePoint) throws IllegalArgumentException {
<span class="fc bfc" id="L838" title="All 2 branches covered.">            if (codePoint == '.') {</span>
<span class="fc" id="L839">                return 0;</span>
<span class="fc bfc" id="L840" title="All 2 branches covered.">            } else if (codePoint == '/') {</span>
<span class="fc" id="L841">                return 1;</span>
<span class="pc bpc" id="L842" title="1 of 4 branches missed.">            } else if ('0' &lt;= codePoint &amp;&amp; codePoint &lt;= '9') {</span>
<span class="fc" id="L843">                return codePoint - '0' + 2;</span>
<span class="pc bpc" id="L844" title="1 of 4 branches missed.">            } else if ('A' &lt;= codePoint &amp;&amp; codePoint &lt;= 'Z') {</span>
<span class="fc" id="L845">                return codePoint - 'A' + 12;</span>
<span class="pc bpc" id="L846" title="2 of 4 branches missed.">            } else if ('a' &lt;= codePoint &amp;&amp; codePoint &lt;= 'z') {</span>
<span class="fc" id="L847">                return codePoint - 'a' + 38;</span>
            } else {
<span class="nc" id="L849">                return -1;</span>
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>