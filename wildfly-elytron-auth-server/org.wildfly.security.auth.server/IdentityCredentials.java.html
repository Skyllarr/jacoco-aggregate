<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>IdentityCredentials.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">WildFly Elytron</a> &gt; <a href="../index.html" class="el_bundle">wildfly-elytron-auth-server</a> &gt; <a href="index.source.html" class="el_package">org.wildfly.security.auth.server</a> &gt; <span class="el_source">IdentityCredentials.java</span></div><h1>IdentityCredentials.java</h1><pre class="source lang-java linenums">/*
 * JBoss, Home of Professional Open Source.
 * Copyright 2016 Red Hat, Inc., and individual contributors
 * as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.wildfly.security.auth.server;

import static org.wildfly.common.math.HashMath.multiHashOrdered;

import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.security.Provider;
import java.security.spec.AlgorithmParameterSpec;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.StreamSupport;

import org.wildfly.common.Assert;
import org.wildfly.security.credential.PasswordCredential;
import org.wildfly.security.credential.source.CredentialSource;
import org.wildfly.security.auth.SupportLevel;
import org.wildfly.security.credential.AlgorithmCredential;
import org.wildfly.security.credential.Credential;
import org.wildfly.security.evidence.Evidence;
import org.wildfly.security.util.EnumerationIterator;

/**
 * The public or private credentials retained by an identity, which can be used for authentication forwarding.  This
 * credentials set can contain zero or one credential of a given type and algorithm name.  If the credential type
 * does not support algorithm names, then the set can contain zero or one credential of that type.  The credential
 * set may be iterated; iteration order is not prescribed and may change if the implementation is changed.
 *
 * @author &lt;a href=&quot;mailto:david.lloyd@redhat.com&quot;&gt;David M. Lloyd&lt;/a&gt;
 */
public abstract class IdentityCredentials implements Iterable&lt;Credential&gt;, CredentialSource {
<span class="fc" id="L59">    IdentityCredentials() {</span>
<span class="fc" id="L60">    }</span>

    /**
     * Determine whether a credential of the given type is present in this set.
     *
     * @param credentialType the credential type class (must not be {@code null})
     * @return {@code true} if a matching credential is contained in this set, {@code false} otherwise
     */
    public final boolean contains(Class&lt;? extends Credential&gt; credentialType) {
<span class="fc" id="L69">        return contains(credentialType, null);</span>
    }

    @Override
    public final SupportLevel getCredentialAcquireSupport(final Class&lt;? extends Credential&gt; credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">        return contains(credentialType, algorithmName, parameterSpec) ? SupportLevel.SUPPORTED : SupportLevel.UNSUPPORTED;</span>
    }

    @Override
    public final SupportLevel getCredentialAcquireSupport(final Class&lt;? extends Credential&gt; credentialType, final String algorithmName) {
<span class="nc bnc" id="L79" title="All 2 branches missed.">        return contains(credentialType, algorithmName) ? SupportLevel.SUPPORTED : SupportLevel.UNSUPPORTED;</span>
    }

    @Override
    public final SupportLevel getCredentialAcquireSupport(final Class&lt;? extends Credential&gt; credentialType) {
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">        return contains(credentialType) ? SupportLevel.SUPPORTED : SupportLevel.UNSUPPORTED;</span>
    }

    /**
     * Determine whether a credential of the given type and algorithm are present in this set.
     *
     * @param credentialType the credential type class (must not be {@code null})
     * @param algorithmName the algorithm name, or {@code null} if any algorithm is acceptable or the credential type
     * does not support algorithm names
     * @param parameterSpec the parameter specification or {@code null} if any parameter specification is acceptable
     * @return {@code true} if a matching credential is contained in this set, {@code false} otherwise
     */
    public abstract boolean contains(Class&lt;? extends Credential&gt; credentialType, String algorithmName, AlgorithmParameterSpec parameterSpec);

    /**
     * Determine whether a credential of the given type and algorithm are present in this set.
     *
     * @param credentialType the credential type class (must not be {@code null})
     * @param algorithmName the algorithm name, or {@code null} if any algorithm is acceptable or the credential type
     * does not support algorithm names
     * @return {@code true} if a matching credential is contained in this set, {@code false} otherwise
     */
    public final boolean contains(Class&lt;? extends Credential&gt; credentialType, String algorithmName) {
<span class="fc" id="L107">        Assert.checkNotNullParam(&quot;credentialType&quot;, credentialType);</span>
<span class="fc" id="L108">        return contains(credentialType, algorithmName, null);</span>
    }

    /**
     * Determine whether a credential of the type, algorithm, and parameters of the given credential is present in this set.
     *
     * @param credential the credential to check against (must not be {@code null})
     * @return {@code true} if a matching credential is contained in this set, {@code false} otherwise
     */
    public final boolean containsMatching(Credential credential) {
<span class="nc" id="L118">        Assert.checkNotNullParam(&quot;credential&quot;, credential);</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">        if (credential instanceof AlgorithmCredential) {</span>
<span class="nc" id="L120">            final AlgorithmCredential algorithmCredential = (AlgorithmCredential) credential;</span>
<span class="nc" id="L121">            return contains(credential.getClass(), algorithmCredential.getAlgorithm(), algorithmCredential.getParameters());</span>
        } else {
<span class="nc" id="L123">            return contains(credential.getClass(), null, null);</span>
        }
    }

    /**
     * Acquire a credential of the given type.
     *
     * @param credentialType the credential type class (must not be {@code null})
     * @param &lt;C&gt; the credential type
     * @return the credential, or {@code null} if no such credential exists
     */
    @Override
    public final &lt;C extends Credential&gt; C getCredential(Class&lt;C&gt; credentialType) {
<span class="fc" id="L136">        return getCredential(credentialType, null, null);</span>
    }

    /**
     * Acquire a credential of the given type and algorithm name.
     *
     * @param credentialType the credential type class (must not be {@code null})
     * @param algorithmName the algorithm name, or {@code null} if any algorithm is acceptable or the credential type
     * does not support algorithm names
     * @param &lt;C&gt; the credential type
     * @return the credential, or {@code null} if no such credential exists
     */
    @Override
    public final &lt;C extends Credential&gt; C getCredential(final Class&lt;C&gt; credentialType, final String algorithmName) {
<span class="fc" id="L150">        return getCredential(credentialType, algorithmName, null);</span>
    }

    /**
     * Acquire a credential of the given type and algorithm name.
     *
     * @param credentialType the credential type class (must not be {@code null})
     * @param algorithmName the algorithm name, or {@code null} if any algorithm is acceptable or the credential type
     * does not support algorithm names
     * @param parameterSpec the parameter specification or {@code null} if any parameter specification is acceptable
     * @param &lt;C&gt; the credential type
     *
     * @return the credential, or {@code null} if no such credential exists
     */
    @Override
    public abstract &lt;C extends Credential&gt; C getCredential(Class&lt;C&gt; credentialType, String algorithmName, AlgorithmParameterSpec parameterSpec);

    /**
     * Apply the given function to the acquired credential, if it is set and of the given type.
     *
     * @param credentialType the credential type class (must not be {@code null})
     * @param function the function to apply (must not be {@code null})
     * @param &lt;C&gt; the credential type
     * @param &lt;R&gt; the return type
     * @return the result of the function, or {@code null} if the criteria are not met
     */
    @Override
    public final &lt;C extends Credential, R&gt; R applyToCredential(Class&lt;C&gt; credentialType, Function&lt;C, R&gt; function) {
<span class="fc" id="L178">        final Credential credential = getCredential(credentialType);</span>
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">        return credential == null ? null : credential.castAndApply(credentialType, function);</span>
    }


    /**
     * Apply the given function to the acquired credential, if it is set and of the given type and algorithm.
     *
     * @param credentialType the credential type class (must not be {@code null})
     * @param algorithmName the algorithm name
     * @param function the function to apply (must not be {@code null})
     * @param &lt;C&gt; the credential type
     * @param &lt;R&gt; the return type
     * @return the result of the function, or {@code null} if the criteria are not met
     */
    @Override
    public final &lt;C extends Credential, R&gt; R applyToCredential(Class&lt;C&gt; credentialType, String algorithmName, Function&lt;C, R&gt; function) {
<span class="nc" id="L195">        final Credential credential = getCredential(credentialType, algorithmName);</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">        return credential == null ? null : credential.castAndApply(credentialType, algorithmName, function);</span>
    }

    /**
     * Apply the given function to the acquired credential, if it is set and of the given type and algorithm.
     *
     * @param credentialType the credential type class (must not be {@code null})
     * @param algorithmName the algorithm name
     * @param function the function to apply (must not be {@code null})
     * @param &lt;C&gt; the credential type
     * @param &lt;R&gt; the return type
     * @return the result of the function, or {@code null} if the criteria are not met
     */
    @Override
    public &lt;C extends Credential, R&gt; R applyToCredential(final Class&lt;C&gt; credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec, final Function&lt;C, R&gt; function) {
<span class="nc" id="L211">        final Credential credential = getCredential(credentialType, algorithmName, parameterSpec);</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">        return credential == null ? null : credential.castAndApply(credentialType, algorithmName, parameterSpec, function);</span>
    }

    /**
     * Return a copy of this credential set, but with the given credential added to it.
     *
     * @param credential the credential to append (must not be {@code null})
     * @return the new credential set (not {@code null})
     */
    public abstract IdentityCredentials withCredential(Credential credential);

    /**
     * Return a copy of this credential set with the given credential set added to it.
     *
     * @param other the credential set to append (must not be {@code null})
     * @return the new credential set (not {@code null})
     */
    public abstract IdentityCredentials with(IdentityCredentials other);

    /**
     * Return a copy of this credential set without any credentials with a type, algorithm name, and parameters matching that of the
     * given credential.  If the credential type, algorithm name, and parameters are not found in this set, return this instance.
     *
     * @param credential the credential to match against (must not be {@code null})
     * @return the new credential set (not {@code null})
     */
    public IdentityCredentials withoutMatching(Credential credential) {
<span class="nc" id="L239">        Assert.checkNotNullParam(&quot;credential&quot;, credential);</span>
<span class="nc" id="L240">        return without(credential::matches);</span>
    }

    /**
     * Return a copy of this credential set without any credentials of the given type.  If the credential type is not
     * found in this set, return this instance.
     *
     * @param credentialType the credential type to remove (must not be {@code null})
     * @return the new credential set (not {@code null})
     */
    public final IdentityCredentials without(Class&lt;? extends Credential&gt; credentialType) {
<span class="fc" id="L251">        Assert.checkNotNullParam(&quot;credentialType&quot;, credentialType);</span>
<span class="fc" id="L252">        return without(credentialType::isInstance);</span>
    }

    /**
     * Return a copy of this credential set without any credentials of the given type and algorithm name.  If the
     * credential type and algorithm name is not found in this set, return this instance.
     *
     * @param credentialType the credential type to remove (must not be {@code null})
     * @param algorithmName the algorithm name to remove, or {@code null} to match any algorithm name
     * @return the new credential set (not {@code null})
     */
    public final IdentityCredentials without(final Class&lt;? extends Credential&gt; credentialType, final String algorithmName) {
<span class="nc" id="L264">        Assert.checkNotNullParam(&quot;credentialType&quot;, credentialType);</span>
<span class="nc" id="L265">        return without(credentialType, algorithmName, null);</span>
    }

    /**
     * Return a copy of this credential set without any credentials of the given type, algorithm name and
     * parameter spec.  If the credential type and algorithm name is not found in this set, return this instance.
     *
     * @param credentialType the credential type to remove (must not be {@code null})
     * @param algorithmName the algorithm name to remove, or {@code null} to match any algorithm name
     * @param parameterSpec the parameter spec to remove, or {@code null} to match any parameter spec
     * @return the new credential set (not {@code null})
     */
    public IdentityCredentials without(final Class&lt;? extends Credential&gt; credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {
<span class="nc" id="L278">        Assert.checkNotNullParam(&quot;credentialType&quot;, credentialType);</span>
<span class="nc" id="L279">        return without(c -&gt; c.matches(credentialType, algorithmName, parameterSpec));</span>
    }

    /**
     * Return a copy of this credential set without any credentials that match the predicate.  If no credentials match
     * the predicate, return this instance.
     *
     * @param predicate the predicate to test (must not be {@code null})
     * @return the new credential set (not {@code null})
     */
    public abstract IdentityCredentials without(Predicate&lt;? super Credential&gt; predicate);

    /**
     * Return a copy of this credential set without any credentials of the given type that match the predicate.  If no credentials match
     * the predicate, return this instance.
     *
     * @param credentialType the credential type class
     * @param predicate the predicate to test (must not be {@code null})
     * @param &lt;C&gt; the credential type
     * @return the new credential set (not {@code null})
     */
    public final &lt;C extends Credential&gt; IdentityCredentials without(Class&lt;C&gt; credentialType, Predicate&lt;? super C&gt; predicate) {
<span class="nc bnc" id="L301" title="All 4 branches missed.">        return without(c -&gt; credentialType.isInstance(c) &amp;&amp; predicate.test(credentialType.cast(c)));</span>
    }

    /**
     * Get a {@link Spliterator} for this credential set.
     *
     * @return the spliterator (not {@code null})
     */
    public Spliterator&lt;Credential&gt; spliterator() {
<span class="fc" id="L310">        return Spliterators.spliterator(iterator(), size(), Spliterator.IMMUTABLE | Spliterator.DISTINCT | Spliterator.NONNULL | Spliterator.ORDERED | Spliterator.SIZED);</span>
    }

    /**
     * Test whether some of the credentials in this set can verify an evidence of given class and algorithm name.
     *
     * @param evidenceClass the class of the evidence (must not be {@code null})
     * @param algorithmName the algorithm name (may be {@code null} if the type of evidence does not support algorithm names)
     * @return {@code true} if the evidence can be verified
     */
    public boolean canVerify(Class&lt;? extends Evidence&gt; evidenceClass, String algorithmName) {
<span class="nc" id="L321">        return StreamSupport.stream(spliterator(), false)</span>
<span class="nc" id="L322">                .filter(credential -&gt; credential.canVerify(evidenceClass, algorithmName))</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">                .count() != 0;</span>
    }

    /**
     * Test whether some of the credentials in this set can verify an evidence.
     *
     * @param evidence the evidence (must not be {@code null})
     * @return {@code true} if the evidence can be verified
     */
    public boolean canVerify(Evidence evidence) {
<span class="nc" id="L333">        return StreamSupport.stream(spliterator(), false)</span>
<span class="nc" id="L334">                .filter(credential -&gt; credential.canVerify(evidence))</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">                .count() != 0;</span>
    }

    /**
     * Verify the given evidence.
     *
     * @param evidence the evidence to verify (must not be {@code null})
     * @return {@code true} if the evidence is verified, {@code false} otherwise
     */
    public boolean verify(Evidence evidence) {
<span class="nc" id="L345">        return verify(evidence, StandardCharsets.UTF_8);</span>
    }

    /**
     * Verify the given evidence.
     *
     * @param providerSupplier the provider supplier to use for verification purposes (must not be {@code null})
     * @param evidence the evidence to verify (must not be {@code null})
     * @return {@code true} if the evidence is verified, {@code false} otherwise
     */
    public boolean verify(Supplier&lt;Provider[]&gt; providerSupplier, Evidence evidence) {
<span class="nc" id="L356">        return verify(providerSupplier, evidence, StandardCharsets.UTF_8);</span>
    }

    /**
     * Verify the given evidence.
     *
     * @param evidence the evidence to verify (must not be {@code null})
     * @oaram hashCharset the name of the character set (must not be {@code null})
     * @return {@code true} if the evidence is verified, {@code false} otherwise
     * @deprecated use {@link #verify(Supplier, Evidence, Charset)} instead
     */
    @Deprecated
    public boolean verify(Evidence evidence, Charset hashCharset) {
<span class="nc" id="L369">        return StreamSupport.stream(spliterator(), false)</span>
<span class="nc" id="L370">                .filter(credential -&gt; credential.canVerify(evidence))</span>
<span class="nc" id="L371">                .filter(credential -&gt;</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">                        credential instanceof PasswordCredential ?</span>
<span class="nc" id="L373">                                ((PasswordCredential)credential).verify(evidence, hashCharset) : credential.verify(evidence))</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">                .count() != 0;</span>
    }

    /**
     * Verify the given evidence.
     *
     * @param providerSupplier the provider supplier to use for verification purposes (must not be {@code null})
     * @param evidence the evidence to verify (must not be {@code null})
     * @oaram hashCharset the name of the character set (must not be {@code null})
     * @return {@code true} if the evidence is verified, {@code false} otherwise
     */
    public boolean verify(Supplier&lt;Provider[]&gt; providerSupplier, Evidence evidence, Charset hashCharset) {
<span class="fc" id="L386">        return StreamSupport.stream(spliterator(), false)</span>
<span class="fc" id="L387">                .filter(credential -&gt; credential.canVerify(evidence))</span>
<span class="fc" id="L388">                .filter(credential -&gt;</span>
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">                        credential instanceof PasswordCredential ?</span>
<span class="pc" id="L390">                                ((PasswordCredential)credential).verify(providerSupplier, evidence, hashCharset) : credential.verify(providerSupplier, evidence))</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">                .count() != 0;</span>
    }

    /**
     * Get the size of this credential set.
     *
     * @return the size of this credential set
     */
    public abstract int size();

    /**
     * The empty credentials object.
     */
<span class="fc" id="L404">    public static final IdentityCredentials NONE = new IdentityCredentials() {</span>
        public boolean contains(final Class&lt;? extends Credential&gt; credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {
<span class="nc" id="L406">            Assert.checkNotNullParam(&quot;credentialType&quot;, credentialType);</span>
<span class="nc" id="L407">            return false;</span>
        }

        public &lt;C extends Credential&gt; C getCredential(final Class&lt;C&gt; credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {
<span class="fc" id="L411">            Assert.checkNotNullParam(&quot;credentialType&quot;, credentialType);</span>
<span class="fc" id="L412">            return null;</span>
        }

        public IdentityCredentials with(final IdentityCredentials other) {
<span class="nc" id="L416">            Assert.checkNotNullParam(&quot;other&quot;, other);</span>
<span class="nc" id="L417">            return other;</span>
        }

        public IdentityCredentials withCredential(final Credential credential) {
<span class="fc" id="L421">            Assert.checkNotNullParam(&quot;credential&quot;, credential);</span>
<span class="fc" id="L422">            return new One(credential);</span>
        }

        public CredentialSource with(final CredentialSource other) {
<span class="nc" id="L426">            Assert.checkNotNullParam(&quot;other&quot;, other);</span>
<span class="nc" id="L427">            return other;</span>
        }

        public Iterator&lt;Credential&gt; iterator() {
<span class="nc" id="L431">            return Collections.emptyIterator();</span>
        }

        public &lt;C extends Credential, R&gt; R applyToCredential(final Class&lt;C&gt; credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec, final Function&lt;C, R&gt; function) {
<span class="nc" id="L435">            Assert.checkNotNullParam(&quot;credentialType&quot;, credentialType);</span>
<span class="nc" id="L436">            return null;</span>
        }

        public IdentityCredentials withoutMatching(final Credential credential) {
<span class="nc" id="L440">            Assert.checkNotNullParam(&quot;credential&quot;, credential);</span>
<span class="nc" id="L441">            return this;</span>
        }

        public IdentityCredentials without(final Class&lt;? extends Credential&gt; credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {
<span class="nc" id="L445">            Assert.checkNotNullParam(&quot;credentialType&quot;, credentialType);</span>
<span class="nc" id="L446">            return this;</span>
        }

        public IdentityCredentials without(final Predicate&lt;? super Credential&gt; predicate) {
<span class="fc" id="L450">            Assert.checkNotNullParam(&quot;predicate&quot;, predicate);</span>
<span class="fc" id="L451">            return this;</span>
        }

        public Spliterator&lt;Credential&gt; spliterator() {
<span class="nc" id="L455">            return Spliterators.emptySpliterator();</span>
        }

        public void forEach(final Consumer&lt;? super Credential&gt; action) {
<span class="nc" id="L459">            Assert.checkNotNullParam(&quot;action&quot;, action);</span>
<span class="nc" id="L460">        }</span>

        public int size() {
<span class="nc" id="L463">            return 0;</span>
        }

        public int hashCode() {
<span class="fc" id="L467">            return 0;</span>
        }

        public boolean equals(Object o) {
<span class="pc bpc" id="L471" title="1 of 2 branches missed.">            return o == this;</span>
        }
    };

    static class One extends IdentityCredentials {
        private final Credential credential;

<span class="fc" id="L478">        One(final Credential credential) {</span>
<span class="fc" id="L479">            this.credential = credential;</span>
<span class="fc" id="L480">        }</span>

        public boolean contains(final Class&lt;? extends Credential&gt; credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {
<span class="fc" id="L483">            Assert.checkNotNullParam(&quot;credentialType&quot;, credentialType);</span>
<span class="fc" id="L484">            return credential.matches(credentialType, algorithmName, parameterSpec);</span>
        }

        public &lt;C extends Credential&gt; C getCredential(final Class&lt;C&gt; credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {
<span class="fc" id="L488">            Assert.checkNotNullParam(&quot;credentialType&quot;, credentialType);</span>
<span class="pc bpc" id="L489" title="1 of 2 branches missed.">            return credential.matches(credentialType, algorithmName, parameterSpec) ? credentialType.cast(credential.clone()) : null;</span>
        }

        public IdentityCredentials withCredential(final Credential credential) {
<span class="nc" id="L493">            Assert.checkNotNullParam(&quot;credential&quot;, credential);</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">            if (this.credential.matches(credential)) {</span>
<span class="nc" id="L495">                return new One(credential);</span>
            } else {
<span class="nc" id="L497">                return new Two(this.credential, credential);</span>
            }
        }

        public IdentityCredentials with(final IdentityCredentials other) {
<span class="nc" id="L502">            Assert.checkNotNullParam(&quot;other&quot;, other);</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">            if (other == NONE) {</span>
<span class="nc" id="L504">                return this;</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">            } else if (other instanceof One) {</span>
<span class="nc" id="L506">                return withCredential(((One) other).credential);</span>
            } else {
<span class="nc" id="L508">                return other.with(this);</span>
            }
        }

        public CredentialSource with(final CredentialSource other) {
<span class="nc" id="L513">            Assert.checkNotNullParam(&quot;other&quot;, other);</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">            if (other instanceof IdentityCredentials) {</span>
<span class="nc" id="L515">                return with((IdentityCredentials) other);</span>
            } else {
<span class="nc" id="L517">                return super.with(other);</span>
            }
        }

        public Iterator&lt;Credential&gt; iterator() {
<span class="fc" id="L522">            return EnumerationIterator.over(credential);</span>
        }

        public &lt;C extends Credential, R&gt; R applyToCredential(final Class&lt;C&gt; credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec, final Function&lt;C, R&gt; function) {
<span class="nc" id="L526">            Assert.checkNotNullParam(&quot;credentialType&quot;, credentialType);</span>
<span class="nc" id="L527">            return credential.castAndApply(credentialType, algorithmName, parameterSpec, function);</span>
        }

        public IdentityCredentials withoutMatching(final Credential credential) {
<span class="nc" id="L531">            Assert.checkNotNullParam(&quot;credential&quot;, credential);</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">            return this.credential.matches(credential) ? NONE : this;</span>
        }

        public IdentityCredentials without(final Class&lt;? extends Credential&gt; credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {
<span class="fc" id="L536">            Assert.checkNotNullParam(&quot;credentialType&quot;, credentialType);</span>
<span class="pc bpc" id="L537" title="1 of 2 branches missed.">            return credential.matches(credentialType, algorithmName, parameterSpec) ? NONE : this;</span>
        }

        public IdentityCredentials without(final Predicate&lt;? super Credential&gt; predicate) {
<span class="nc" id="L541">            Assert.checkNotNullParam(&quot;predicate&quot;, predicate);</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">            return predicate.test(credential) ? NONE : this;</span>
        }

        public void forEach(final Consumer&lt;? super Credential&gt; action) {
<span class="nc" id="L546">            Assert.checkNotNullParam(&quot;action&quot;, action);</span>
<span class="nc" id="L547">            action.accept(credential);</span>
<span class="nc" id="L548">        }</span>

        public int size() {
<span class="fc" id="L551">            return 1;</span>
        }

        public int hashCode() {
<span class="fc" id="L555">            return typeHash(credential);</span>
        }

        public boolean equals(final Object obj) {
<span class="pc bpc" id="L559" title="1 of 4 branches missed.">            return obj instanceof One &amp;&amp; ((One) obj).credential.equals(credential);</span>
        }
    }

    static class Two extends IdentityCredentials {
        private final Credential credential1;
        private final Credential credential2;

<span class="nc" id="L567">        Two(final Credential credential1, final Credential credential2) {</span>
<span class="nc" id="L568">            this.credential1 = credential1;</span>
<span class="nc" id="L569">            this.credential2 = credential2;</span>
<span class="nc" id="L570">        }</span>

        public boolean contains(final Class&lt;? extends Credential&gt; credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {
<span class="nc" id="L573">            Assert.checkNotNullParam(&quot;credentialType&quot;, credentialType);</span>
<span class="nc bnc" id="L574" title="All 4 branches missed.">            return credential1.matches(credentialType, algorithmName, parameterSpec) || credential2.matches(credentialType, algorithmName, parameterSpec);</span>
        }

        public &lt;C extends Credential&gt; C getCredential(final Class&lt;C&gt; credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {
<span class="nc" id="L578">            Assert.checkNotNullParam(&quot;credentialType&quot;, credentialType);</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">            return credential1.matches(credentialType, algorithmName, parameterSpec) ? credentialType.cast(credential1.clone()) :</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">                   credential2.matches(credentialType, algorithmName, parameterSpec) ? credentialType.cast(credential2.clone()) : null;</span>
        }

        public IdentityCredentials withCredential(final Credential credential) {
<span class="nc" id="L584">            Assert.checkNotNullParam(&quot;credential&quot;, credential);</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">            if (credential.matches(credential1)) {</span>
<span class="nc" id="L586">                return new Two(credential2, credential);</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">            } else if (credential.matches(credential2)) {</span>
<span class="nc" id="L588">                return new Two(credential1, credential);</span>
            } else {
<span class="nc" id="L590">                return new Many(credential1, credential2, credential);</span>
            }
        }

        public IdentityCredentials with(final IdentityCredentials other) {
<span class="nc" id="L595">            Assert.checkNotNullParam(&quot;other&quot;, other);</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">            if (other == NONE) {</span>
<span class="nc" id="L597">                return this;</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">            } else if (other instanceof One) {</span>
<span class="nc" id="L599">                return withCredential(((One) other).credential);</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">            } else if (other instanceof Two) {</span>
<span class="nc" id="L601">                final Two otherTwo = (Two) other;</span>
<span class="nc" id="L602">                return withCredential(otherTwo.credential1).withCredential(otherTwo.credential2);</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">            } else if (other instanceof Many) {</span>
<span class="nc" id="L604">                Many otherMany = (Many) other;</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">                if (otherMany.containsMatching(credential1)) {</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">                    if (otherMany.containsMatching(credential2)) {</span>
<span class="nc" id="L607">                        return otherMany;</span>
                    } else {
<span class="nc" id="L609">                        return new Many(credential2, otherMany);</span>
                    }
<span class="nc bnc" id="L611" title="All 2 branches missed.">                } else if (otherMany.containsMatching(credential2)) {</span>
<span class="nc" id="L612">                    return new Many(credential1, otherMany);</span>
                } else {
<span class="nc" id="L614">                    return new Many(credential1, credential2, otherMany);</span>
                }
            } else {
<span class="nc" id="L617">                throw Assert.unreachableCode();</span>
            }
        }

        public CredentialSource with(final CredentialSource other) {
<span class="nc" id="L622">            Assert.checkNotNullParam(&quot;other&quot;, other);</span>
<span class="nc bnc" id="L623" title="All 2 branches missed.">            if (other instanceof IdentityCredentials) {</span>
<span class="nc" id="L624">                return with((IdentityCredentials) other);</span>
            } else {
<span class="nc" id="L626">                return super.with(other);</span>
            }
        }

        public Iterator&lt;Credential&gt; iterator() {
<span class="nc" id="L631">            return EnumerationIterator.over(credential1);</span>
        }

        public &lt;C extends Credential, R&gt; R applyToCredential(final Class&lt;C&gt; credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec, final Function&lt;C, R&gt; function) {
<span class="nc" id="L635">            Assert.checkNotNullParam(&quot;credentialType&quot;, credentialType);</span>
<span class="nc" id="L636">            return credential1.castAndApply(credentialType, algorithmName, parameterSpec, function);</span>
        }

        public IdentityCredentials withoutMatching(final Credential credential) {
<span class="nc" id="L640">            Assert.checkNotNullParam(&quot;credential&quot;, credential);</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">            return this.credential1.matches(credential) ? NONE : this;</span>
        }

        public IdentityCredentials without(final Class&lt;? extends Credential&gt; credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {
<span class="nc" id="L645">            Assert.checkNotNullParam(&quot;credentialType&quot;, credentialType);</span>
<span class="nc bnc" id="L646" title="All 2 branches missed.">            return credential1.matches(credentialType, algorithmName, parameterSpec) ? NONE : this;</span>
        }

        public IdentityCredentials without(final Predicate&lt;? super Credential&gt; predicate) {
<span class="nc" id="L650">            Assert.checkNotNullParam(&quot;predicate&quot;, predicate);</span>
<span class="nc bnc" id="L651" title="All 6 branches missed.">            return predicate.test(credential1) ? predicate.test(credential2) ? NONE : new One(credential2) : predicate.test(credential2) ? new One(credential1) : this;</span>
        }

        public void forEach(final Consumer&lt;? super Credential&gt; action) {
<span class="nc" id="L655">            Assert.checkNotNullParam(&quot;action&quot;, action);</span>
<span class="nc" id="L656">            action.accept(credential1);</span>
<span class="nc" id="L657">            action.accept(credential2);</span>
<span class="nc" id="L658">        }</span>

        public int size() {
<span class="nc" id="L661">            return 2;</span>
        }

        public int hashCode() {
<span class="nc" id="L665">            return typeHash(credential1) ^ typeHash(credential2);</span>
        }

        public boolean equals(final Object obj) {
<span class="nc bnc" id="L669" title="All 2 branches missed.">            if (! (obj instanceof Two)) {</span>
<span class="nc" id="L670">                return false;</span>
            }
<span class="nc" id="L672">            final Two two = (Two) obj;</span>
<span class="nc bnc" id="L673" title="All 8 branches missed.">            return credential1.equals(two.credential1) &amp;&amp; credential2.equals(two.credential2) || credential1.equals(two.credential2) &amp;&amp; credential2.equals(two.credential1);</span>
        }
    }

    /**
     * A (hopefully) unique hash code for the kind of credential.
     *
     * @param credential the credential
     * @return the type hash
     */
    static int typeHash(Credential credential) {
<span class="fc" id="L684">        int ch = credential.getClass().hashCode();</span>
<span class="pc bpc" id="L685" title="1 of 2 branches missed.">        if (credential instanceof AlgorithmCredential) {</span>
<span class="fc" id="L686">            final AlgorithmCredential algorithmCredential = (AlgorithmCredential) credential;</span>
<span class="fc" id="L687">            return multiHashOrdered(multiHashOrdered(ch, 42979, Objects.hashCode(algorithmCredential.getAlgorithm())), 62861, Objects.hashCode(algorithmCredential.getParameters()));</span>
        } else {
<span class="nc" id="L689">            return ch;</span>
        }
    }

<span class="nc bnc" id="L693" title="All 2 branches missed.">    static class Many extends IdentityCredentials {</span>
        private final LinkedHashMap&lt;Key, Credential&gt; map;
        private final int hashCode;

<span class="nc" id="L697">        Many(final Credential c1, final Many subsequent) {</span>
<span class="nc" id="L698">            LinkedHashMap&lt;Key, Credential&gt; map = new LinkedHashMap&lt;&gt;(subsequent.map.size() + 1);</span>
<span class="nc" id="L699">            addCredential(c1, map);</span>
<span class="nc" id="L700">            map.putAll(subsequent.map);</span>
<span class="nc" id="L701">            this.map = map;</span>
<span class="nc" id="L702">            int hc = 0;</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">            for (Credential credential : map.values()) {</span>
<span class="nc" id="L704">                hc ^= typeHash(credential);</span>
<span class="nc" id="L705">            }</span>
<span class="nc" id="L706">            hashCode = hc;</span>
<span class="nc bnc" id="L707" title="All 4 branches missed.">            assert size() &gt; 2;</span>
<span class="nc" id="L708">        }</span>

<span class="nc" id="L710">        Many(final Credential c1, final Credential c2, final Many subsequent) {</span>
<span class="nc" id="L711">            LinkedHashMap&lt;Key, Credential&gt; map = new LinkedHashMap&lt;&gt;(subsequent.map.size() + 2);</span>
<span class="nc" id="L712">            addCredential(c1, map);</span>
<span class="nc" id="L713">            addCredential(c2, map);</span>
<span class="nc" id="L714">            map.putAll(subsequent.map);</span>
<span class="nc" id="L715">            this.map = map;</span>
<span class="nc" id="L716">            int hc = 0;</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">            for (Credential credential : map.values()) {</span>
<span class="nc" id="L718">                hc ^= typeHash(credential);</span>
<span class="nc" id="L719">            }</span>
<span class="nc" id="L720">            hashCode = hc;</span>
<span class="nc bnc" id="L721" title="All 4 branches missed.">            assert size() &gt; 2;</span>
<span class="nc" id="L722">        }</span>

<span class="nc" id="L724">        Many(final LinkedHashMap&lt;Key, Credential&gt; map) {</span>
<span class="nc" id="L725">            this.map = map;</span>
<span class="nc" id="L726">            int hc = 0;</span>
<span class="nc bnc" id="L727" title="All 2 branches missed.">            for (Credential credential : map.values()) {</span>
<span class="nc" id="L728">                hc ^= typeHash(credential);</span>
<span class="nc" id="L729">            }</span>
<span class="nc" id="L730">            hashCode = hc;</span>
<span class="nc bnc" id="L731" title="All 4 branches missed.">            assert size() &gt; 2;</span>
<span class="nc" id="L732">        }</span>

<span class="nc" id="L734">        Many(final Credential credential1, final Credential credential2, final Credential credential3) {</span>
<span class="nc" id="L735">            LinkedHashMap&lt;Key, Credential&gt; map = new LinkedHashMap&lt;&gt;(3);</span>
<span class="nc" id="L736">            addCredential(credential1, map);</span>
<span class="nc" id="L737">            addCredential(credential2, map);</span>
<span class="nc" id="L738">            addCredential(credential3, map);</span>
<span class="nc" id="L739">            this.map = map;</span>
<span class="nc" id="L740">            int hc = 0;</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">            for (Credential credential : map.values()) {</span>
<span class="nc" id="L742">                hc ^= typeHash(credential);</span>
<span class="nc" id="L743">            }</span>
<span class="nc" id="L744">            hashCode = hc;</span>
<span class="nc bnc" id="L745" title="All 4 branches missed.">            assert size() &gt; 2;</span>
<span class="nc" id="L746">        }</span>

        public boolean contains(final Class&lt;? extends Credential&gt; credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {
<span class="nc" id="L749">            return map.containsKey(new Key(credentialType, algorithmName, parameterSpec));</span>
        }

        public &lt;C extends Credential&gt; C getCredential(final Class&lt;C&gt; credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {
<span class="nc" id="L753">            return credentialType.cast(map.get(new Key(credentialType, algorithmName, parameterSpec)).clone());</span>
        }

        public IdentityCredentials withoutMatching(final Credential credential) {
<span class="nc" id="L757">            final Key key = Key.of(credential);</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">            if (map.containsKey(key)) {</span>
<span class="nc" id="L759">                final LinkedHashMap&lt;Key, Credential&gt; clone = new LinkedHashMap&lt;&gt;(map);</span>
<span class="nc" id="L760">                clone.remove(key);</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">                if (clone.size() == 2) {</span>
<span class="nc" id="L762">                    final Iterator&lt;Credential&gt; iterator = clone.values().iterator();</span>
<span class="nc" id="L763">                    return new Two(iterator.next(), iterator.next());</span>
                } else {
<span class="nc" id="L765">                    return new Many(clone);</span>
                }
            } else {
<span class="nc" id="L768">                return this;</span>
            }
        }

        public void forEach(final Consumer&lt;? super Credential&gt; action) {
<span class="nc" id="L773">            map.values().forEach(action);</span>
<span class="nc" id="L774">        }</span>

        public int size() {
<span class="nc" id="L777">            return map.size();</span>
        }

        public IdentityCredentials withCredential(final Credential credential) {
<span class="nc" id="L781">            final LinkedHashMap&lt;Key, Credential&gt; clone = new LinkedHashMap&lt;&gt;(map);</span>
<span class="nc" id="L782">            addCredential(credential, clone);</span>
<span class="nc" id="L783">            return new Many(clone);</span>
        }

        public IdentityCredentials with(final IdentityCredentials other) {
<span class="nc" id="L787">            final LinkedHashMap&lt;Key, Credential&gt; clone = new LinkedHashMap&lt;&gt;(map);</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">            for (Credential credential : other) {</span>
<span class="nc" id="L789">                addCredential(credential, clone);</span>
<span class="nc" id="L790">            }</span>
<span class="nc" id="L791">            return new Many(clone);</span>
        }

        private void addCredential(Credential credential, LinkedHashMap&lt;Key, Credential&gt; map) {
<span class="nc" id="L795">            final Key key = Key.of(credential);</span>
            // do this as two steps so it's added to the end
<span class="nc" id="L797">            map.remove(key);</span>
<span class="nc" id="L798">            map.put(key, credential);</span>
            // add an alternate entry without algorithm and parameter spec to allow for loose matches
<span class="nc bnc" id="L800" title="All 2 branches missed.">            if (key.getAlgorithm() != null) {</span>
<span class="nc" id="L801">                Key altKey = new Key(key.getClazz(), null, null);</span>
<span class="nc" id="L802">                map.remove(altKey);</span>
<span class="nc" id="L803">                map.put(altKey, credential);</span>
            }
            // add an alternate entry without parameter spec to allow for loose matches
<span class="nc bnc" id="L806" title="All 2 branches missed.">            if (key.getParameterSpec() != null) {</span>
<span class="nc" id="L807">                Key altKey = new Key(key.getClazz(), key.getAlgorithm(), null);</span>
<span class="nc" id="L808">                map.remove(altKey);</span>
<span class="nc" id="L809">                map.put(altKey, credential);</span>
            }
<span class="nc" id="L811">        }</span>

        public CredentialSource with(final CredentialSource other) {
<span class="nc bnc" id="L814" title="All 2 branches missed.">            return other instanceof IdentityCredentials ? with((IdentityCredentials) other) : super.with(other);</span>
        }

        public Iterator&lt;Credential&gt; iterator() {
<span class="nc" id="L818">            return Collections.unmodifiableCollection(map.values()).iterator();</span>
        }

        public &lt;C extends Credential, R&gt; R applyToCredential(final Class&lt;C&gt; credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec, final Function&lt;C, R&gt; function) {
<span class="nc" id="L822">            final Key key = new Key(credentialType, algorithmName, parameterSpec);</span>
<span class="nc" id="L823">            final Credential credential = map.get(key);</span>
<span class="nc bnc" id="L824" title="All 2 branches missed.">            if (credential != null) {</span>
<span class="nc" id="L825">                return function.apply(credentialType.cast(credential));</span>
            }
<span class="nc" id="L827">            return null;</span>
        }

        public IdentityCredentials without(final Predicate&lt;? super Credential&gt; predicate) {
<span class="nc" id="L831">            final LinkedHashMap&lt;Key, Credential&gt; clone = new LinkedHashMap&lt;&gt;(map);</span>
<span class="nc" id="L832">            final Collection&lt;Credential&gt; values = clone.values();</span>
<span class="nc" id="L833">            values.removeIf(predicate);</span>
<span class="nc" id="L834">            final Iterator&lt;Credential&gt; iterator = values.iterator();</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">            if (iterator.hasNext()) {</span>
<span class="nc" id="L836">                final Credential c1 = iterator.next();</span>
<span class="nc bnc" id="L837" title="All 2 branches missed.">                if (iterator.hasNext()) {</span>
<span class="nc" id="L838">                    final Credential c2 = iterator.next();</span>
<span class="nc bnc" id="L839" title="All 2 branches missed.">                    if (iterator.hasNext()) {</span>
<span class="nc" id="L840">                        return new Many(clone);</span>
                    } else {
<span class="nc" id="L842">                        return new Two(c1, c2);</span>
                    }
                } else {
<span class="nc" id="L845">                    return new One(c1);</span>
                }
            } else {
<span class="nc" id="L848">                return NONE;</span>
            }
        }

        public int hashCode() {
<span class="nc" id="L853">            return hashCode;</span>
        }

        public boolean equals(final Object obj) {
<span class="nc bnc" id="L857" title="All 2 branches missed.">            if (! (obj instanceof Many)) {</span>
<span class="nc" id="L858">                return false;</span>
            }
<span class="nc" id="L860">            Many many = (Many) obj;</span>
            // check is potentially expensive so start here
<span class="nc bnc" id="L862" title="All 2 branches missed.">            if (hashCode != many.hashCode) {</span>
<span class="nc" id="L863">                return false;</span>
            }
<span class="nc bnc" id="L865" title="All 2 branches missed.">            if (map.size() != many.map.size()) {</span>
<span class="nc" id="L866">                return false;</span>
            }
            // now the O(n) part
<span class="nc bnc" id="L869" title="All 2 branches missed.">            for (Map.Entry&lt;Key, Credential&gt; entry : map.entrySet()) {</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">                if (! Objects.equals(many.map.get(entry.getKey()), entry.getValue())) {</span>
<span class="nc" id="L871">                    return false;</span>
                }
<span class="nc" id="L873">            }</span>
<span class="nc" id="L874">            return true;</span>
        }
    }

    static final class Key {
        private final Class&lt;? extends Credential&gt; clazz;
        private final String algorithm;
        private final AlgorithmParameterSpec parameterSpec;
        private final int hashCode;

<span class="nc" id="L884">        Key(final Class&lt;? extends Credential&gt; clazz, final String algorithm, final AlgorithmParameterSpec parameterSpec) {</span>
<span class="nc" id="L885">            this.clazz = clazz;</span>
<span class="nc" id="L886">            this.algorithm = algorithm;</span>
<span class="nc" id="L887">            this.parameterSpec = parameterSpec;</span>
<span class="nc" id="L888">            hashCode = multiHashOrdered(multiHashOrdered(clazz.hashCode(), 42979, Objects.hashCode(algorithm)), 62861, Objects.hashCode(parameterSpec));</span>
<span class="nc" id="L889">        }</span>

        static Key of(Credential c) {
<span class="nc bnc" id="L892" title="All 2 branches missed.">            if (c instanceof AlgorithmCredential) {</span>
<span class="nc" id="L893">                final AlgorithmCredential ac = (AlgorithmCredential) c;</span>
<span class="nc" id="L894">                return new Key(ac.getClass(), ac.getAlgorithm(), ac.getParameters());</span>
            } else {
<span class="nc" id="L896">                return new Key(c.getClass(), null, null);</span>
            }
        }

        public int hashCode() {
<span class="nc" id="L901">            return hashCode;</span>
        }

        public boolean equals(final Object obj) {
<span class="nc bnc" id="L905" title="All 4 branches missed.">            return obj instanceof Key &amp;&amp; equals((Key) obj);</span>
        }

        private boolean equals(final Key key) {
<span class="nc bnc" id="L909" title="All 6 branches missed.">            return clazz == key.clazz &amp;&amp; Objects.equals(algorithm, key.algorithm) &amp;&amp; Objects.equals(parameterSpec, key.parameterSpec);</span>
        }

        Class&lt;? extends Credential&gt; getClazz() {
<span class="nc" id="L913">            return clazz;</span>
        }

        String getAlgorithm() {
<span class="nc" id="L917">            return algorithm;</span>
        }

        AlgorithmParameterSpec getParameterSpec() {
<span class="nc" id="L921">            return parameterSpec;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>