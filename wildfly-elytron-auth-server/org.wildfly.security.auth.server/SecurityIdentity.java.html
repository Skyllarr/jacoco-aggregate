<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SecurityIdentity.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">WildFly Elytron</a> &gt; <a href="../index.html" class="el_bundle">wildfly-elytron-auth-server</a> &gt; <a href="index.source.html" class="el_package">org.wildfly.security.auth.server</a> &gt; <span class="el_source">SecurityIdentity.java</span></div><h1>SecurityIdentity.java</h1><pre class="source lang-java linenums">/*
 * JBoss, Home of Professional Open Source.
 * Copyright 2015 Red Hat, Inc., and individual contributors
 * as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.wildfly.security.auth.server;

import static org.wildfly.security.auth.server._private.ElytronMessages.log;

import java.security.Permission;
import java.security.Principal;
import java.security.PrivilegedAction;
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BiPredicate;
import java.util.function.Function;
import java.util.function.ObjIntConsumer;
import java.util.function.Supplier;

import org.wildfly.common.Assert;
import org.wildfly.common.function.ExceptionBiConsumer;
import org.wildfly.common.function.ExceptionBiFunction;
import org.wildfly.common.function.ExceptionBiPredicate;
import org.wildfly.common.function.ExceptionFunction;
import org.wildfly.common.function.ExceptionObjIntConsumer;
import org.wildfly.common.function.ExceptionSupplier;
import org.wildfly.security.ParametricPrivilegedAction;
import org.wildfly.security.ParametricPrivilegedExceptionAction;
import org.wildfly.security.auth.permission.ChangeRoleMapperPermission;
import org.wildfly.security.auth.permission.RunAsPrincipalPermission;
import org.wildfly.security.auth.principal.AnonymousPrincipal;
import org.wildfly.security.auth.principal.NamePrincipal;
import org.wildfly.security.auth.server.event.SecurityPermissionCheckFailedEvent;
import org.wildfly.security.auth.server.event.SecurityPermissionCheckSuccessfulEvent;
import org.wildfly.security.authz.Attributes;
import org.wildfly.security.authz.AuthorizationIdentity;
import org.wildfly.security.authz.PermissionMappable;
import org.wildfly.security.authz.RoleMapper;
import org.wildfly.security.authz.Roles;
import org.wildfly.security.credential.Credential;
import org.wildfly.security.permission.ElytronPermission;
import org.wildfly.security.permission.PermissionVerifier;

/**
 * A loaded and authenticated security identity.
 *
 * @author &lt;a href=&quot;mailto:david.lloyd@redhat.com&quot;&gt;David M. Lloyd&lt;/a&gt;
 */
public final class SecurityIdentity implements PermissionVerifier, PermissionMappable, Supplier&lt;SecurityIdentity&gt;, Scoped {
<span class="fc" id="L71">    private static final Permission SET_RUN_AS_PERMISSION = ElytronPermission.forName(&quot;setRunAsPrincipal&quot;);</span>
<span class="fc" id="L72">    private static final Permission PRIVATE_CREDENTIALS_PERMISSION = ElytronPermission.forName(&quot;getPrivateCredentials&quot;);</span>
<span class="fc" id="L73">    private static final Permission WITH_DEFAULT_ROLE_MAPPER_PERMISSION = ElytronPermission.forName(&quot;withDefaultRoleMapper&quot;);</span>

<span class="fc" id="L75">    private static final SecurityIdentity[] NO_IDENTITIES = new SecurityIdentity[0];</span>

    private final SecurityDomain securityDomain;
    private final Principal principal;
    private final AuthorizationIdentity authorizationIdentity;
    private final RealmInfo realmInfo;
    private final Function&lt;SecurityIdentity, Roles&gt; defaultRoles;
    private final Map&lt;String, RoleMapper&gt; roleMappers;
    private final Instant creationTime;
    private final PermissionVerifier verifier;
    private final IdentityCredentials publicCredentials;
    private final IdentityCredentials privateCredentials;
    private final Supplier&lt;SecurityIdentity[]&gt; withSuppliedIdentities;
    private final SecurityIdentity[] withIdentities;

<span class="fc" id="L90">    SecurityIdentity(final SecurityDomain securityDomain, final Principal principal, final RealmInfo realmInfo, final AuthorizationIdentity authorizationIdentity, final Map&lt;String, RoleMapper&gt; roleMappers, final IdentityCredentials publicCredentials, final IdentityCredentials privateCredentials) {</span>
<span class="fc" id="L91">        this.securityDomain = securityDomain;</span>
<span class="fc" id="L92">        this.principal = principal;</span>
<span class="fc" id="L93">        this.realmInfo = realmInfo;</span>
<span class="fc" id="L94">        this.authorizationIdentity = authorizationIdentity;</span>
<span class="fc" id="L95">        this.defaultRoles = securityDomain::mapRoles;</span>
<span class="fc" id="L96">        this.roleMappers = roleMappers;</span>
<span class="fc" id="L97">        this.creationTime = Instant.now();</span>
<span class="fc" id="L98">        this.verifier = securityDomain.mapPermissions(this);</span>
<span class="fc" id="L99">        this.publicCredentials = publicCredentials;</span>
<span class="fc" id="L100">        this.privateCredentials = privateCredentials;</span>
<span class="fc" id="L101">        this.withSuppliedIdentities = null;</span>
<span class="fc" id="L102">        this.withIdentities = null;</span>
<span class="fc" id="L103">    }</span>

<span class="nc" id="L105">    SecurityIdentity(final SecurityIdentity old, final Map&lt;String, RoleMapper&gt; roleMappers) {</span>
<span class="nc" id="L106">        this.securityDomain = old.securityDomain;</span>
<span class="nc" id="L107">        this.principal = old.principal;</span>
<span class="nc" id="L108">        this.realmInfo = old.realmInfo;</span>
<span class="nc" id="L109">        this.authorizationIdentity = old.authorizationIdentity;</span>
<span class="nc" id="L110">        this.defaultRoles = old.defaultRoles;</span>
<span class="nc" id="L111">        this.roleMappers = roleMappers;</span>
<span class="nc" id="L112">        this.creationTime = old.creationTime;</span>
<span class="nc" id="L113">        this.verifier = old.verifier;</span>
<span class="nc" id="L114">        this.publicCredentials = old.publicCredentials;</span>
<span class="nc" id="L115">        this.privateCredentials = old.privateCredentials;</span>
<span class="nc" id="L116">        this.withSuppliedIdentities = old.withSuppliedIdentities;</span>
<span class="nc" id="L117">        this.withIdentities = old.withIdentities;</span>
<span class="nc" id="L118">    }</span>

<span class="nc" id="L120">    SecurityIdentity(final SecurityIdentity old, final PermissionVerifier verifier) {</span>
<span class="nc" id="L121">        this.securityDomain = old.securityDomain;</span>
<span class="nc" id="L122">        this.principal = old.principal;</span>
<span class="nc" id="L123">        this.realmInfo = old.realmInfo;</span>
<span class="nc" id="L124">        this.authorizationIdentity = old.authorizationIdentity;</span>
<span class="nc" id="L125">        this.defaultRoles = old.defaultRoles;</span>
<span class="nc" id="L126">        this.roleMappers = old.roleMappers;</span>
<span class="nc" id="L127">        this.creationTime = old.creationTime;</span>
<span class="nc" id="L128">        this.verifier = verifier;</span>
<span class="nc" id="L129">        this.publicCredentials = old.publicCredentials;</span>
<span class="nc" id="L130">        this.privateCredentials = old.privateCredentials;</span>
<span class="nc" id="L131">        this.withSuppliedIdentities = old.withSuppliedIdentities;</span>
<span class="nc" id="L132">        this.withIdentities = old.withIdentities;</span>
<span class="nc" id="L133">    }</span>

<span class="fc" id="L135">    SecurityIdentity(final SecurityIdentity old, final Credential credential, final boolean isPrivate) {</span>
<span class="fc" id="L136">        this.securityDomain = old.securityDomain;</span>
<span class="fc" id="L137">        this.principal = old.principal;</span>
<span class="fc" id="L138">        this.realmInfo = old.realmInfo;</span>
<span class="fc" id="L139">        this.authorizationIdentity = old.authorizationIdentity;</span>
<span class="fc" id="L140">        this.defaultRoles = old.defaultRoles;</span>
<span class="fc" id="L141">        this.roleMappers = old.roleMappers;</span>
<span class="fc" id="L142">        this.creationTime = old.creationTime;</span>
<span class="fc" id="L143">        this.verifier = old.verifier;</span>
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">        this.publicCredentials = isPrivate ? old.publicCredentials : old.publicCredentials.withCredential(credential);</span>
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">        this.privateCredentials = isPrivate ? old.privateCredentials.withCredential(credential) : old.privateCredentials;</span>
<span class="fc" id="L146">        this.withSuppliedIdentities = old.withSuppliedIdentities;</span>
<span class="fc" id="L147">        this.withIdentities = old.withIdentities;</span>
<span class="fc" id="L148">    }</span>

<span class="nc" id="L150">    SecurityIdentity(final SecurityIdentity old, final IdentityCredentials credentials, final boolean isPrivate) {</span>
<span class="nc" id="L151">        this.securityDomain = old.securityDomain;</span>
<span class="nc" id="L152">        this.principal = old.principal;</span>
<span class="nc" id="L153">        this.realmInfo = old.realmInfo;</span>
<span class="nc" id="L154">        this.authorizationIdentity = old.authorizationIdentity;</span>
<span class="nc" id="L155">        this.defaultRoles = old.defaultRoles;</span>
<span class="nc" id="L156">        this.roleMappers = old.roleMappers;</span>
<span class="nc" id="L157">        this.creationTime = old.creationTime;</span>
<span class="nc" id="L158">        this.verifier = old.verifier;</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">        this.publicCredentials = isPrivate ? old.publicCredentials : old.publicCredentials.with(credentials);</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">        this.privateCredentials = isPrivate ? old.privateCredentials.with(credentials) : old.privateCredentials;</span>
<span class="nc" id="L161">        this.withSuppliedIdentities = old.withSuppliedIdentities;</span>
<span class="nc" id="L162">        this.withIdentities = old.withIdentities;</span>
<span class="nc" id="L163">    }</span>

<span class="nc" id="L165">    SecurityIdentity(final SecurityIdentity old, final Supplier&lt;SecurityIdentity[]&gt; withSuppliedIdentites) {</span>
<span class="nc" id="L166">        this.securityDomain = old.securityDomain;</span>
<span class="nc" id="L167">        this.principal = old.principal;</span>
<span class="nc" id="L168">        this.realmInfo = old.realmInfo;</span>
<span class="nc" id="L169">        this.authorizationIdentity = old.authorizationIdentity;</span>
<span class="nc" id="L170">        this.defaultRoles = old.defaultRoles;</span>
<span class="nc" id="L171">        this.roleMappers = old.roleMappers;</span>
<span class="nc" id="L172">        this.creationTime = old.creationTime;</span>
<span class="nc" id="L173">        this.verifier = old.verifier;</span>
<span class="nc" id="L174">        this.publicCredentials = old.publicCredentials;</span>
<span class="nc" id="L175">        this.privateCredentials = old.privateCredentials;</span>
<span class="nc" id="L176">        this.withSuppliedIdentities = withSuppliedIdentites;</span>
<span class="nc" id="L177">        this.withIdentities = null;</span>
<span class="nc" id="L178">    }</span>

<span class="nc" id="L180">    SecurityIdentity(final SecurityIdentity old, final SecurityIdentity[] withIdentities) {</span>
<span class="nc" id="L181">        this.securityDomain = old.securityDomain;</span>
<span class="nc" id="L182">        this.principal = old.principal;</span>
<span class="nc" id="L183">        this.realmInfo = old.realmInfo;</span>
<span class="nc" id="L184">        this.authorizationIdentity = old.authorizationIdentity;</span>
<span class="nc" id="L185">        this.defaultRoles = old.defaultRoles;</span>
<span class="nc" id="L186">        this.roleMappers = old.roleMappers;</span>
<span class="nc" id="L187">        this.creationTime = old.creationTime;</span>
<span class="nc" id="L188">        this.verifier = old.verifier;</span>
<span class="nc" id="L189">        this.publicCredentials = old.publicCredentials;</span>
<span class="nc" id="L190">        this.privateCredentials = old.privateCredentials;</span>
<span class="nc" id="L191">        this.withSuppliedIdentities = null;</span>
<span class="nc" id="L192">        this.withIdentities = withIdentities;</span>
<span class="nc" id="L193">    }</span>

<span class="fc" id="L195">    SecurityIdentity(final SecurityIdentity old, final Function&lt;SecurityIdentity, Roles&gt;defaultRoles) {</span>
<span class="fc" id="L196">        this.securityDomain = old.securityDomain;</span>
<span class="fc" id="L197">        this.principal = old.principal;</span>
<span class="fc" id="L198">        this.realmInfo = old.realmInfo;</span>
<span class="fc" id="L199">        this.authorizationIdentity = old.authorizationIdentity;</span>
<span class="fc" id="L200">        this.defaultRoles = defaultRoles;</span>
<span class="fc" id="L201">        this.roleMappers = old.roleMappers;</span>
<span class="fc" id="L202">        this.creationTime = old.creationTime;</span>
<span class="fc" id="L203">        this.verifier = old.verifier;</span>
<span class="fc" id="L204">        this.publicCredentials = old.publicCredentials;</span>
<span class="fc" id="L205">        this.privateCredentials = old.privateCredentials;</span>
<span class="fc" id="L206">        this.withSuppliedIdentities = null;</span>
<span class="fc" id="L207">        this.withIdentities = old.withIdentities;</span>
<span class="fc" id="L208">    }</span>

<span class="nc" id="L210">    SecurityIdentity(final SecurityIdentity old, final Attributes runtimeAttributes) {</span>
<span class="nc" id="L211">        this.securityDomain = old.securityDomain;</span>
<span class="nc" id="L212">        this.principal = old.principal;</span>
<span class="nc" id="L213">        this.realmInfo = old.realmInfo;</span>
<span class="nc" id="L214">        this.authorizationIdentity = AuthorizationIdentity.basicIdentity(old.authorizationIdentity, runtimeAttributes);</span>
<span class="nc" id="L215">        this.defaultRoles = old.defaultRoles;</span>
<span class="nc" id="L216">        this.roleMappers = old.roleMappers;</span>
<span class="nc" id="L217">        this.creationTime = old.creationTime;</span>
<span class="nc" id="L218">        this.verifier = old.verifier;</span>
<span class="nc" id="L219">        this.publicCredentials = old.publicCredentials;</span>
<span class="nc" id="L220">        this.privateCredentials = old.privateCredentials;</span>
<span class="nc" id="L221">        this.withSuppliedIdentities = null;</span>
<span class="nc" id="L222">        this.withIdentities = old.withIdentities;</span>
<span class="nc" id="L223">    }</span>

    SecurityDomain getSecurityDomain() {
<span class="fc" id="L226">        return securityDomain;</span>
    }

    RealmInfo getRealmInfo() {
<span class="fc" id="L230">        return this.realmInfo;</span>
    }

    AuthorizationIdentity getAuthorizationIdentity() {
<span class="fc" id="L234">        return authorizationIdentity;</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private Supplier&lt;SecurityIdentity&gt;[] establishIdentities() {
<span class="pc bpc" id="L239" title="2 of 4 branches missed.">        SecurityIdentity[] withIdentities = this.withIdentities != null ? this.withIdentities : withSuppliedIdentities != null ? withSuppliedIdentities.get() : NO_IDENTITIES;</span>
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">        if (withIdentities.length == 0) {</span>
<span class="fc" id="L241">            return NO_IDENTITIES;</span>
        }

<span class="nc" id="L244">        Supplier&lt;SecurityIdentity&gt;[] oldIdentities = new Supplier[withIdentities.length];</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">        for (int i = 0; i &lt; withIdentities.length; i++) {</span>
<span class="nc" id="L246">            Supplier&lt;SecurityIdentity&gt; securityIdentity = withIdentities[i];</span>
<span class="nc" id="L247">            oldIdentities[i] = securityIdentity.get().getSecurityDomain().getAndSetCurrentSecurityIdentity(securityIdentity);</span>
        }

<span class="nc" id="L250">        return oldIdentities;</span>
    }

    private void restoreIdentities(Supplier&lt;SecurityIdentity&gt;[] securityIdentities) {
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">        for (Supplier&lt;SecurityIdentity&gt; currentIdentity : securityIdentities) {</span>
<span class="nc" id="L255">            currentIdentity.get().securityDomain.setCurrentSecurityIdentity(currentIdentity);</span>
        }
<span class="fc" id="L257">    }</span>

    /**
     * Run an action under this identity.
     *
     * @param action the action to run
     * @param &lt;T&gt; the action return type
     * @return the action result (may be {@code null})
     * @deprecated Use {@link #runAsSupplier(Supplier)} instead.
     */
    @Deprecated
    public &lt;T&gt; T runAs(PrivilegedAction&lt;T&gt; action) {
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">        if (action == null) return null;</span>
<span class="fc" id="L270">        return runAs(action, (ParametricPrivilegedAction&lt;T, PrivilegedAction&lt;T&gt;&gt;) PrivilegedAction::run);</span>
    }

    /**
     * Run an action under this identity.
     *
     * @param action the action to run
     * @param &lt;T&gt; the action return type
     * @return the action result (may be {@code null})
     * @throws PrivilegedActionException if the action fails
     * @deprecated Use {@link #runAsSupplierEx(ExceptionSupplier)} instead.
     */
    @Deprecated
    public &lt;T&gt; T runAs(PrivilegedExceptionAction&lt;T&gt; action) throws PrivilegedActionException {
<span class="nc bnc" id="L284" title="All 2 branches missed.">        if (action == null) return null;</span>
<span class="nc" id="L285">        return runAs(action, (ParametricPrivilegedExceptionAction&lt;T, PrivilegedExceptionAction&lt;T&gt;&gt;) PrivilegedExceptionAction::run);</span>
    }

    /**
     * Run an action under this identity.
     *
     * @param parameter the parameter to pass to the action
     * @param action the action to run
     * @param &lt;T&gt; the action return type
     * @param &lt;P&gt; the action parameter type
     * @return the action result (may be {@code null})
     * @deprecated Use {@link #runAsFunction(Function, Object)} instead.
     */
    @Deprecated
    public &lt;T, P&gt; T runAs(P parameter, ParametricPrivilegedAction&lt;T, P&gt; action) {
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">        if (action == null) return null;</span>
<span class="fc" id="L301">        final Supplier&lt;SecurityIdentity&gt;[] oldWithIdentities = establishIdentities();</span>
<span class="fc" id="L302">        final Supplier&lt;SecurityIdentity&gt; oldIdentity = securityDomain.getAndSetCurrentSecurityIdentity(this);</span>
        try {
<span class="fc" id="L304">            return action.run(parameter);</span>
        } finally {
<span class="fc" id="L306">            securityDomain.setCurrentSecurityIdentity(oldIdentity);</span>
<span class="fc" id="L307">            restoreIdentities(oldWithIdentities);</span>
        }
    }

    /**
     * Run an action under this identity.
     *
     * @param parameter the parameter to pass to the action
     * @param action the action to run
     * @param &lt;T&gt; the action return type
     * @param &lt;P&gt; the action parameter type
     * @return the action result (may be {@code null})
     * @throws PrivilegedActionException if the action fails
     * @deprecated Use {@link #runAsFunctionEx(ExceptionFunction, Object)} instead.
     */
    @Deprecated
    public &lt;T, P&gt; T runAs(P parameter, ParametricPrivilegedExceptionAction&lt;T, P&gt; action) throws PrivilegedActionException {
<span class="nc bnc" id="L324" title="All 2 branches missed.">        if (action == null) return null;</span>
<span class="nc" id="L325">        final Supplier&lt;SecurityIdentity&gt;[] oldWithIdentities = establishIdentities();</span>
<span class="nc" id="L326">        final Supplier&lt;SecurityIdentity&gt; oldIdentity = securityDomain.getAndSetCurrentSecurityIdentity(this);</span>
        try {
<span class="nc" id="L328">            return action.run(parameter);</span>
<span class="nc" id="L329">        } catch (RuntimeException | PrivilegedActionException e) {</span>
<span class="nc" id="L330">            throw e;</span>
<span class="nc" id="L331">        } catch (Exception e) {</span>
<span class="nc" id="L332">            throw new PrivilegedActionException(e);</span>
        } finally {
<span class="nc" id="L334">            securityDomain.setCurrentSecurityIdentity(oldIdentity);</span>
<span class="nc" id="L335">            restoreIdentities(oldWithIdentities);</span>
        }
    }

    /**
     * Run an action under this identity.
     *
     * @param parameter1 the first parameter to pass to the action
     * @param parameter2 the second parameter to pass to the action
     * @param action the action to run
     * @param &lt;R&gt; the action return type
     * @param &lt;T&gt; the action first parameter type
     * @param &lt;U&gt; the action second parameter type
     * @return the action result (may be {@code null})
     */
    public &lt;T, U, R&gt; R runAsFunction(BiFunction&lt;T, U, R&gt; action, T parameter1, U parameter2) {
<span class="nc bnc" id="L351" title="All 2 branches missed.">        if (action == null) return null;</span>
<span class="nc" id="L352">        final Supplier&lt;SecurityIdentity&gt;[] oldWithIdentities = establishIdentities();</span>
<span class="nc" id="L353">        final Supplier&lt;SecurityIdentity&gt; oldIdentity = securityDomain.getAndSetCurrentSecurityIdentity(this);</span>
        try {
<span class="nc" id="L355">            return action.apply(parameter1, parameter2);</span>
        } finally {
<span class="nc" id="L357">            securityDomain.setCurrentSecurityIdentity(oldIdentity);</span>
<span class="nc" id="L358">            restoreIdentities(oldWithIdentities);</span>
        }
    }

    /**
     * Run an action under this identity.
     *
     * @param parameter1 the first parameter to pass to the action
     * @param parameter2 the second parameter to pass to the action
     * @param action the action to run
     * @param &lt;T&gt; the action first parameter type
     * @param &lt;U&gt; the action second parameter type
     */
    public &lt;T, U&gt; void runAsConsumer(BiConsumer&lt;T, U&gt; action, T parameter1, U parameter2) {
<span class="nc bnc" id="L372" title="All 2 branches missed.">        if (action == null) return;</span>
<span class="nc" id="L373">        final Supplier&lt;SecurityIdentity&gt;[] oldWithIdentities = establishIdentities();</span>
<span class="nc" id="L374">        final Supplier&lt;SecurityIdentity&gt; oldIdentity = securityDomain.getAndSetCurrentSecurityIdentity(this);</span>
        try {
<span class="nc" id="L376">            action.accept(parameter1, parameter2);</span>
        } finally {
<span class="nc" id="L378">            securityDomain.setCurrentSecurityIdentity(oldIdentity);</span>
<span class="nc" id="L379">            restoreIdentities(oldWithIdentities);</span>
        }
<span class="nc" id="L381">    }</span>

    /**
     * Run an action under this identity.
     *
     * @param parameter1 the first parameter to pass to the action
     * @param parameter2 the second parameter to pass to the action
     * @param action the action to run
     * @param &lt;T&gt; the action first parameter type
     */
    public &lt;T&gt; void runAsObjIntConsumer(ObjIntConsumer&lt;T&gt; action, T parameter1, int parameter2) {
<span class="nc bnc" id="L392" title="All 2 branches missed.">        if (action == null) return;</span>
<span class="nc" id="L393">        final Supplier&lt;SecurityIdentity&gt;[] oldWithIdentities = establishIdentities();</span>
<span class="nc" id="L394">        final Supplier&lt;SecurityIdentity&gt; oldIdentity = securityDomain.getAndSetCurrentSecurityIdentity(this);</span>
        try {
<span class="nc" id="L396">            action.accept(parameter1, parameter2);</span>
        } finally {
<span class="nc" id="L398">            securityDomain.setCurrentSecurityIdentity(oldIdentity);</span>
<span class="nc" id="L399">            restoreIdentities(oldWithIdentities);</span>
        }
<span class="nc" id="L401">    }</span>

    /**
     * Run an action under this identity.
     *
     * @param parameter1 the first parameter to pass to the action
     * @param parameter2 the second parameter to pass to the action
     * @param action the action to run
     * @param &lt;R&gt; the action return type
     * @param &lt;T&gt; the action first parameter type
     * @param &lt;U&gt; the action second parameter type
     * @param &lt;E&gt; the action exception type
     * @return the action result (may be {@code null})
     * @throws E if the action throws this exception
     */
    public &lt;T, U, R, E extends Exception&gt; R runAsFunctionEx(ExceptionBiFunction&lt;T, U, R, E&gt; action, T parameter1, U parameter2) throws E {
<span class="nc bnc" id="L417" title="All 2 branches missed.">        if (action == null) return null;</span>
<span class="nc" id="L418">        final Supplier&lt;SecurityIdentity&gt;[] oldWithIdentities = establishIdentities();</span>
<span class="nc" id="L419">        final Supplier&lt;SecurityIdentity&gt; oldIdentity = securityDomain.getAndSetCurrentSecurityIdentity(this);</span>
        try {
<span class="nc" id="L421">            return action.apply(parameter1, parameter2);</span>
        } finally {
<span class="nc" id="L423">            securityDomain.setCurrentSecurityIdentity(oldIdentity);</span>
<span class="nc" id="L424">            restoreIdentities(oldWithIdentities);</span>
        }
    }

    /**
     * Run an action under this identity.
     *
     * @param parameter1 the first parameter to pass to the action
     * @param parameter2 the second parameter to pass to the action
     * @param action the action to run
     * @param &lt;T&gt; the action first parameter type
     * @param &lt;U&gt; the action second parameter type
     * @param &lt;E&gt; the action exception type
     * @throws E if the action throws this exception
     */
    public &lt;T, U, E extends Exception&gt; void runAsConsumerEx(ExceptionBiConsumer&lt;T, U, E&gt; action, T parameter1, U parameter2) throws E {
<span class="nc bnc" id="L440" title="All 2 branches missed.">        if (action == null) return;</span>
<span class="nc" id="L441">        final Supplier&lt;SecurityIdentity&gt;[] oldWithIdentities = establishIdentities();</span>
<span class="nc" id="L442">        final Supplier&lt;SecurityIdentity&gt; oldIdentity = securityDomain.getAndSetCurrentSecurityIdentity(this);</span>
        try {
<span class="nc" id="L444">            action.accept(parameter1, parameter2);</span>
        } finally {
<span class="nc" id="L446">            securityDomain.setCurrentSecurityIdentity(oldIdentity);</span>
<span class="nc" id="L447">            restoreIdentities(oldWithIdentities);</span>
        }
<span class="nc" id="L449">    }</span>

    /**
     * Run an action under this identity.
     *
     * @param parameter1 the first parameter to pass to the action
     * @param parameter2 the second parameter to pass to the action
     * @param action the action to run
     * @param &lt;T&gt; the action first parameter type
     * @param &lt;E&gt; the action exception type
     * @throws E if the action throws this exception
     */
    public &lt;T, E extends Exception&gt; void runAsObjIntConsumerEx(ExceptionObjIntConsumer&lt;T, E&gt; action, T parameter1, int parameter2) throws E {
<span class="nc bnc" id="L462" title="All 2 branches missed.">        if (action == null) return;</span>
<span class="nc" id="L463">        final Supplier&lt;SecurityIdentity&gt;[] oldWithIdentities = establishIdentities();</span>
<span class="nc" id="L464">        final Supplier&lt;SecurityIdentity&gt; oldIdentity = securityDomain.getAndSetCurrentSecurityIdentity(this);</span>
        try {
<span class="nc" id="L466">            action.accept(parameter1, parameter2);</span>
        } finally {
<span class="nc" id="L468">            securityDomain.setCurrentSecurityIdentity(oldIdentity);</span>
<span class="nc" id="L469">            restoreIdentities(oldWithIdentities);</span>
        }
<span class="nc" id="L471">    }</span>

    /**
     * Run an action under this identity.
     *
     * @param parameter1 the first parameter to pass to the action
     * @param parameter2 the second parameter to pass to the action
     * @param action the action to run
     * @param &lt;T&gt; the action first parameter type
     * @param &lt;U&gt; the action second parameter type
     * @return the action result (may be {@code null})
     */
    public &lt;T, U&gt; boolean runAsBiPredicate(BiPredicate&lt;T, U&gt; action, T parameter1, U parameter2) {
<span class="nc bnc" id="L484" title="All 2 branches missed.">        if (action == null) return false;</span>
<span class="nc" id="L485">        final Supplier&lt;SecurityIdentity&gt;[] oldWithIdentities = establishIdentities();</span>
<span class="nc" id="L486">        final Supplier&lt;SecurityIdentity&gt; oldIdentity = securityDomain.getAndSetCurrentSecurityIdentity(this);</span>
        try {
<span class="nc" id="L488">            return action.test(parameter1, parameter2);</span>
        } finally {
<span class="nc" id="L490">            securityDomain.setCurrentSecurityIdentity(oldIdentity);</span>
<span class="nc" id="L491">            restoreIdentities(oldWithIdentities);</span>
        }
    }

    /**
     * Run an action under this identity.
     *
     * @param parameter1 the first parameter to pass to the action
     * @param parameter2 the second parameter to pass to the action
     * @param action the action to run
     * @param &lt;T&gt; the action first parameter type
     * @param &lt;U&gt; the action second parameter type
     * @param &lt;E&gt; the action exception type
     * @return the action result (may be {@code null})
     * @throws E if the action throws this exception
     */
    public &lt;T, U, E extends Exception&gt; boolean runAsExBiPredicate(ExceptionBiPredicate&lt;T, U, E&gt; action, T parameter1, U parameter2) throws E {
<span class="nc bnc" id="L508" title="All 2 branches missed.">        if (action == null) return false;</span>
<span class="nc" id="L509">        final Supplier&lt;SecurityIdentity&gt;[] oldWithIdentities = establishIdentities();</span>
<span class="nc" id="L510">        final Supplier&lt;SecurityIdentity&gt; oldIdentity = securityDomain.getAndSetCurrentSecurityIdentity(this);</span>
        try {
<span class="nc" id="L512">            return action.test(parameter1, parameter2);</span>
        } finally {
<span class="nc" id="L514">            securityDomain.setCurrentSecurityIdentity(oldIdentity);</span>
<span class="nc" id="L515">            restoreIdentities(oldWithIdentities);</span>
        }
    }

    /**
     * Run an action under a series of identities.
     *
     * @param action the action to run
     * @param identities the identities to set up
     * @param &lt;T&gt; the action return type
     * @return the action result (may be {@code null})
     * @throws PrivilegedActionException if the action fails
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    public static &lt;T&gt; T runAsAll(PrivilegedExceptionAction&lt;T&gt; action, SecurityIdentity... identities) throws PrivilegedActionException {
<span class="nc bnc" id="L530" title="All 2 branches missed.">        if (action == null) return null;</span>
<span class="nc" id="L531">        int length = identities.length;</span>
<span class="nc" id="L532">        Supplier&lt;SecurityIdentity&gt;[] oldIdentities = new Supplier[length];</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L534">            Supplier&lt;SecurityIdentity&gt; securityIdentity = identities[i];</span>
<span class="nc" id="L535">            SecurityDomain securityDomain = securityIdentity.get().getSecurityDomain();</span>
<span class="nc" id="L536">            oldIdentities[i] = securityDomain.getAndSetCurrentSecurityIdentity(securityIdentity);</span>
        }
        try {
<span class="nc" id="L539">            return action.run();</span>
<span class="nc" id="L540">        } catch (RuntimeException | PrivilegedActionException e) {</span>
<span class="nc" id="L541">            throw e;</span>
<span class="nc" id="L542">        } catch (Exception e) {</span>
<span class="nc" id="L543">            throw new PrivilegedActionException(e);</span>
        } finally {
<span class="nc bnc" id="L545" title="All 2 branches missed.">            for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L546">                Supplier&lt;SecurityIdentity&gt; oldIdentity = oldIdentities[i];</span>
<span class="nc" id="L547">                SecurityDomain securityDomain = oldIdentity.get().getSecurityDomain();</span>
<span class="nc" id="L548">                securityDomain.setCurrentSecurityIdentity(oldIdentity);</span>
            }
        }
    }

    /**
     * Get the roles associated with this identity.
     *
     * @return the roles associated with this identity
     */
    public Roles getRoles() {
<span class="fc" id="L559">        return defaultRoles.apply(this);</span>
    }

    /**
     * Get the mapped roles associated with this identity.  If no role mapping exists for the given category, an
     * empty role set is returned.
     *
     * @param category the role mapping category
     * @return the category roles
     */
    public Roles getRoles(String category) {
<span class="nc" id="L570">        return getRoles(category, false);</span>
    }


    /**
     * Attempt to create a new identity that is the same as this identity but with a {@link Supplier Supplier&lt;SecurityIdentity[]&gt;} to supply identities that will be associated with all 'run' calls.
     *
     * Any existing individual identities associated with this identity will be dropped.
     *
     * The supplier will be called for each run call so were possible should handle it's own optimisation.
     *
     * @param securityIdentities a {@link Supplier Supplier&lt;SecurityIdentity[]&gt;} for identities to be associated with every run call.
     * @return the new identity
     * @throws IllegalArgumentException if the supplied identity
     */
    public SecurityIdentity withSecurityIdentitySupplier(Supplier&lt;SecurityIdentity[]&gt; securityIdentities) {
<span class="nc" id="L586">        Assert.checkNotNullParam(&quot;securityIdentities&quot;, securityIdentities);</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">        if (this.withSuppliedIdentities == securityIdentities) {</span>
<span class="nc" id="L588">            return this;</span>
        }

<span class="nc" id="L591">        return new SecurityIdentity(this, securityIdentities);</span>
    }

    /**
     * Attempt to create a new identity that is the same as this identity but with an additional identity from a different
     * security domain that will be associated with all 'run' calls.
     *
     * If a {@link Supplier Supplier&lt;SecurityIdentity[]&gt;} has previously been associated with this identity it will be dropped.
     *
     * @param securityIdentity the {@link SecurityIdentity} to also be associated with all run calls made to this identity.
     * @return the new identity
     * @throws IllegalArgumentException if the supplied identity
     */
    public SecurityIdentity withSecurityIdentity(SecurityIdentity securityIdentity) {
<span class="nc" id="L605">        Assert.checkNotNullParam(&quot;securityIdentity&quot;, securityIdentity);</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">        if (securityIdentity == this) {</span>
<span class="nc" id="L607">            return this;</span>
        }

<span class="nc bnc" id="L610" title="All 2 branches missed.">        if (securityDomain == securityIdentity.securityDomain) {</span>
<span class="nc" id="L611">            throw log.cantWithSameSecurityDomainDomain();</span>
        }

<span class="nc bnc" id="L614" title="All 2 branches missed.">        int oldCapacity = this.withIdentities == null ? 0 : this.withIdentities.length;</span>
<span class="nc" id="L615">        List&lt;SecurityIdentity&gt; withIdentities = new ArrayList&lt;&gt;(oldCapacity + 1);</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">        if (oldCapacity != 0) {</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">            for (SecurityIdentity currentIdentity : this.withIdentities) {</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">                if (currentIdentity == securityIdentity) {</span>
<span class="nc" id="L619">                    return this; // already added</span>
                }

<span class="nc bnc" id="L622" title="All 2 branches missed.">                if (currentIdentity.securityDomain != securityIdentity.securityDomain) {</span>
<span class="nc" id="L623">                    withIdentities.add(currentIdentity); // re-add identities from other domains</span>
                }
            }
        }
<span class="nc" id="L627">        withIdentities.add(securityIdentity);</span>

<span class="nc" id="L629">        return new SecurityIdentity(this, withIdentities.toArray(new SecurityIdentity[0]));</span>
    }

    /**
     * Get the mapped roles associated with this identity.
     *
     * @param category the role mapping category
     * @param fallbackToDefault {@code true} if the default roles associated with this identity should be returned if no
     *                          role mapping exists for the given category, {@code false} otherwise
     * @return the category roles
     */
    public Roles getRoles(String category, boolean fallbackToDefault) {
<span class="nc" id="L641">        final RoleMapper roleMapper = roleMappers.get(category);</span>
<span class="nc bnc" id="L642" title="All 4 branches missed.">        return roleMapper == null ? (fallbackToDefault ? getRoles() : Roles.NONE) : roleMapper.mapRoles(getRoles());</span>
    }

    /**
     * Attempt to create a new identity which replaces a role mapper category on the current identity.  If the given role
     * mapper is already set on the current identity, the current identity is returned.
     *
     * @param category the category name
     * @param roleMapper the role mapper to use
     * @return the new identity
     * @throws SecurityException if the calling class is not granted the {@link ChangeRoleMapperPermission} for the given
     *      category name
     */
    public SecurityIdentity withRoleMapper(String category, RoleMapper roleMapper) {
<span class="nc" id="L656">        Assert.checkNotNullParam(&quot;category&quot;, category);</span>
<span class="nc" id="L657">        Assert.checkNotNullParam(&quot;roleMapper&quot;, roleMapper);</span>
<span class="nc" id="L658">        final Map&lt;String, RoleMapper&gt; roleMappers = this.roleMappers;</span>
<span class="nc" id="L659">        final RoleMapper existingRoleMapper = roleMappers.get(category);</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">        if (existingRoleMapper == roleMapper) {</span>
            // identical
<span class="nc" id="L662">            return this;</span>
        }
        // it's a change of some sort
<span class="nc" id="L665">        final SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">        if (sm != null) {</span>
<span class="nc" id="L667">            sm.checkPermission(new ChangeRoleMapperPermission(category));</span>
        }
        // authorized; next see if we can use a memory-efficient collection
        final Map&lt;String, RoleMapper&gt; newMap;
<span class="nc bnc" id="L671" title="All 6 branches missed.">        if (roleMappers.isEmpty() || roleMappers.size() == 1 &amp;&amp; roleMappers.keySet().iterator().next().equals(category)) {</span>
<span class="nc" id="L672">            newMap = Collections.singletonMap(category, roleMapper);</span>
        } else {
<span class="nc" id="L674">            newMap = new HashMap&lt;&gt;(roleMappers);</span>
<span class="nc" id="L675">            newMap.put(category, roleMapper);</span>
        }
<span class="nc" id="L677">        return new SecurityIdentity(this, newMap);</span>
    }

    /**
     * Attempt to create a new identity which wraps the default roles with a default role mapper.
     *
     * @param roleMapper the roleMapper to map the roles.
     * @return the new identity
     * @throws SecurityException if the calling class is not granted the withDefaultRoleMapper permission.
     */
    public SecurityIdentity withDefaultRoleMapper(final RoleMapper roleMapper) {
<span class="fc" id="L688">        final SecurityManager sm = System.getSecurityManager();</span>
<span class="pc bpc" id="L689" title="1 of 2 branches missed.">        if (sm != null) {</span>
<span class="nc" id="L690">            sm.checkPermission(WITH_DEFAULT_ROLE_MAPPER_PERMISSION);</span>
        }

<span class="fc" id="L693">        return new SecurityIdentity(this, (SecurityIdentity si) -&gt; roleMapper.mapRoles(this.getRoles()));</span>
    }

    /**
     * Attempt to create a new identity that can be used to run as a user with the given name. If the
     * current identity is not authorized to run as a user with the given name, an exception is thrown.
     *
     * Calling with enabled security manager requires {@code setRunAsPrincipal} {@link ElytronPermission}.
     * Regardless security manager is enabled, {@link RunAsPrincipalPermission} for given name is required.
     *
     * @param name the name to attempt to run as
     * @return the new security identity
     * @throws SecurityException if the operation authorization failed for any reason
     */
    public SecurityIdentity createRunAsIdentity(String name) throws SecurityException {
<span class="fc" id="L708">        return createRunAsIdentity(name, true);</span>
    }

    /**
     * Attempt to create a new identity that can be used to run as a user with the given name.
     *
     * Calling with enabled security manager requires {@code setRunAsPrincipal} {@link ElytronPermission}.
     *
     * @param name the name to attempt to run as
     * @param authorize whether to check the current identity is authorized to run as a user
     *        with the given principal (has {@link RunAsPrincipalPermission})
     * @return the new security identity
     * @throws SecurityException if the caller does not have the {@code setRunAsPrincipal}
     *         {@link ElytronPermission} or if the operation authorization failed for any other reason
     */
    public SecurityIdentity createRunAsIdentity(String name, boolean authorize) throws SecurityException {
<span class="fc" id="L724">        Assert.checkNotNullParam(&quot;name&quot;, name);</span>
<span class="fc" id="L725">        return createRunAsIdentity(new NamePrincipal(name), authorize);</span>
    }

    /**
     * Attempt to create a new identity that can be used to run as a user with the given principal.
     *
     * Calling with enabled security manager requires {@code setRunAsPrincipal} {@link ElytronPermission}.
     *
     * @param principal the principal to attempt to run as
     * @param authorize whether to check the current identity is authorized to run as a user
     *        with the given principal (has {@link RunAsPrincipalPermission})
     * @return the new security identity
     * @throws SecurityException if the caller does not have the {@code setRunAsPrincipal}
     *         {@link ElytronPermission} or if the operation authorization failed for any other reason
     */
    public SecurityIdentity createRunAsIdentity(Principal principal, boolean authorize) throws SecurityException {
<span class="fc" id="L741">        Assert.checkNotNullParam(&quot;principal&quot;, principal);</span>

<span class="fc" id="L743">        final SecurityManager sm = System.getSecurityManager();</span>
<span class="pc bpc" id="L744" title="1 of 2 branches missed.">        if (sm != null) {</span>
<span class="nc" id="L745">            sm.checkPermission(SET_RUN_AS_PERMISSION);</span>
        }

<span class="fc" id="L748">        try (final ServerAuthenticationContext context = securityDomain.createNewAuthenticationContext(this, MechanismConfigurationSelector.constantSelector(MechanismConfiguration.EMPTY))) {</span>
<span class="pc bpc" id="L749" title="2 of 4 branches missed.">            if (! (context.importIdentity(this) &amp;&amp; context.authorize(principal, authorize))) {</span>
<span class="nc" id="L750">                throw log.runAsAuthorizationFailed(this.principal, principal, null);</span>
            }
<span class="fc" id="L752">            return context.getAuthorizedIdentity();</span>
<span class="nc" id="L753">        } catch (RealmUnavailableException e) {</span>
<span class="nc" id="L754">            throw log.runAsAuthorizationFailed(this.principal, principal, e);</span>
        }
    }

    /**
     * Attempt to create a new identity that can be used to run as an anonymous user. If the
     * current identity is not authorized to run as an anonymous user, an exception is thrown.
     *
     * Calling with enabled security manager requires {@code setRunAsPrincipal} {@link ElytronPermission}.
     * {@link org.wildfly.security.auth.permission.LoginPermission} granted to the anonymous identity will be required.
     *
     * @return the new security identity
     * @throws SecurityException if the operation authorization failed for any reason
     */
    public SecurityIdentity createRunAsAnonymous() throws SecurityException {
<span class="nc" id="L769">        return createRunAsAnonymous(true);</span>
    }

    /**
     * Attempt to create a new identity that can be used to run as an anonymous user
     *
     * Calling with enabled security manager requires {@code setRunAsPrincipal} {@link ElytronPermission}.
     *
     * @param authorize whether to check the anonymous identity is authorized to log in
     *                  (has {@link org.wildfly.security.auth.permission.LoginPermission})
     * @return the new security identity
     * @throws SecurityException if the caller does not have the {@code setRunAsPrincipal}
     *         {@link ElytronPermission} or if the operation authorization failed for any other reason
     */
    public SecurityIdentity createRunAsAnonymous(boolean authorize) throws SecurityException {
<span class="nc" id="L784">        final SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">        if (sm != null) {</span>
<span class="nc" id="L786">            sm.checkPermission(SET_RUN_AS_PERMISSION);</span>
        }

<span class="nc" id="L789">        try (final ServerAuthenticationContext context = securityDomain.createNewAuthenticationContext(this, MechanismConfigurationSelector.constantSelector(MechanismConfiguration.EMPTY))) {</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">            if (! context.authorizeAnonymous(authorize)) {</span>
<span class="nc" id="L791">                throw log.runAsAuthorizationFailed(principal, AnonymousPrincipal.getInstance(), null);</span>
            }
<span class="nc" id="L793">            return context.getAuthorizedIdentity();</span>
        }
    }

    /**
     * Create a new security identity which is the same as this one, but which limits authorization privileges to the
     * intersection of the current privileges and the given verifier.
     *
     * @param verifier the restricted verifier (must not be {@code null})
     * @return the restricted identity
     */
    public SecurityIdentity intersectWith(PermissionVerifier verifier) {
<span class="nc" id="L805">        Assert.checkNotNullParam(&quot;verifier&quot;, verifier);</span>
<span class="nc" id="L806">        return new SecurityIdentity(this, this.verifier.and(verifier));</span>
    }

    public boolean implies(final Permission permission) {
<span class="fc" id="L810">        final boolean result = verifier.implies(permission);</span>
<span class="fc" id="L811">        SecurityDomain.safeHandleSecurityEvent(securityDomain,</span>
<span class="fc bfc" id="L812" title="All 2 branches covered.">                result ? new SecurityPermissionCheckSuccessfulEvent(this, permission) : new SecurityPermissionCheckFailedEvent(this, permission));</span>
<span class="fc" id="L813">        return result;</span>
    }

    /**
     * Get the attributes associated with this identity.
     *
     * @return a read-only instance of {@link Attributes} with all attributes associated with this identity
     */
    public Attributes getAttributes() {
<span class="nc" id="L822">        return this.authorizationIdentity.getAttributes().asReadOnly();</span>
    }

    /**
     * Get the principal of this identity.
     *
     * @return the principal of this identity
     */
    public Principal getPrincipal() {
<span class="fc" id="L831">        return principal;</span>
    }

    /**
     * Get the creation time of this identity, which is the time that the initial authentication occurred.
     *
     * @return the creation time of this identity (not {@code null})
     */
    public Instant getCreationTime() {
<span class="nc" id="L840">        return creationTime;</span>
    }

    /**
     * Get the public credentials of this identity.
     *
     * @return the public credentials of this identity (not {@code null})
     */
    public IdentityCredentials getPublicCredentials() {
<span class="nc" id="L849">        return publicCredentials;</span>
    }

    /**
     * Convenience method to determine if this identity is anonymous.
     *
     * @return {@code true} if the identity is anonymous, {@code false} otherwise
     */
    public boolean isAnonymous() {
<span class="fc" id="L858">        return principal instanceof AnonymousPrincipal;</span>
    }

    /**
     * Create a new security identity which is the same as this one, but which includes the given credential as a
     * public credential.
     *
     * @param credential the credential (must not be {@code null})
     * @return the new identity
     */
    public SecurityIdentity withPublicCredential(Credential credential) {
<span class="nc" id="L869">        Assert.checkNotNullParam(&quot;credential&quot;, credential);</span>
<span class="nc" id="L870">        return new SecurityIdentity(this, credential, false);</span>
    }

    /**
     * Create a new security identity which is the same as this one, but which includes the given credentials as
     * public credentials.
     *
     * @param credentials the credential set (must not be {@code null})
     * @return the new identity
     */
    public SecurityIdentity withPublicCredentials(final IdentityCredentials credentials) {
<span class="fc" id="L881">        Assert.checkNotNullParam(&quot;credentials&quot;, credentials);</span>
<span class="pc bpc" id="L882" title="1 of 2 branches missed.">        return credentials == IdentityCredentials.NONE ? this : new SecurityIdentity(this, credentials, false);</span>
    }

    /**
     * Create a new security identity which is the same as this one, but which includes the given credential as a
     * private credential.
     *
     * @param credential the credential (must not be {@code null})
     * @return the new identity
     */
    public SecurityIdentity withPrivateCredential(Credential credential) {
<span class="fc" id="L893">        Assert.checkNotNullParam(&quot;credential&quot;, credential);</span>
<span class="fc" id="L894">        return new SecurityIdentity(this, credential, true);</span>
    }

    /**
     * Create a new security identity which is the same as this one, but which includes the given credentials as
     * private credentials.
     *
     * @param credentials the credential set (must not be {@code null})
     * @return the new identity
     */
    public SecurityIdentity withPrivateCredentials(final IdentityCredentials credentials) {
<span class="fc" id="L905">        Assert.checkNotNullParam(&quot;credentials&quot;, credentials);</span>
<span class="pc bpc" id="L906" title="1 of 2 branches missed.">        return credentials == IdentityCredentials.NONE ? this : new SecurityIdentity(this, credentials, true);</span>
    }

    /**
     * Create a new security identity which is the same as this one, but which includes the given runtime attributes.
     *
     * @param runtimeAttributes the runtime attributes (must not be {@code null})
     * @return the new identity
     */
    public SecurityIdentity withRuntimeAttributes(final Attributes runtimeAttributes) {
<span class="nc" id="L916">        Assert.checkNotNullParam(&quot;runtimeAttributes&quot;, runtimeAttributes);</span>
<span class="nc bnc" id="L917" title="All 2 branches missed.">        return runtimeAttributes == Attributes.EMPTY ? this : new SecurityIdentity(this, runtimeAttributes);</span>
    }

    /**
     * Get the private credentials of this identity.  The caller must have the {@code getPrivateCredentials} {@link ElytronPermission}.
     *
     * @return the private credentials of this identity (not {@code null})
     */
    public IdentityCredentials getPrivateCredentials() {
<span class="nc" id="L926">        final SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L927" title="All 2 branches missed.">        if (sm != null) {</span>
<span class="nc" id="L928">            sm.checkPermission(PRIVATE_CREDENTIALS_PERMISSION);</span>
        }
<span class="nc" id="L930">        return getPrivateCredentialsPrivate();</span>
    }

    /**
     * Get this identity.
     *
     * @return this identity
     */
    public SecurityIdentity get() {
<span class="fc" id="L939">        return this;</span>
    }

    /**
     * Create a new flexible identity association, initializing it with this identity.
     *
     * @return the new flexible identity association (not {@code null})
     */
    public FlexibleIdentityAssociation createFlexibleAssociation() {
<span class="nc" id="L948">        return new FlexibleIdentityAssociation(securityDomain, this);</span>
    }

    IdentityCredentials getPrivateCredentialsPrivate() {
<span class="nc" id="L952">        return privateCredentials;</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L957">        return &quot;SecurityIdentity{&quot; +</span>
                &quot;principal=&quot; + principal +
                &quot;, securityDomain=&quot; + securityDomain +
                &quot;, authorizationIdentity=&quot; + authorizationIdentity +
                &quot;, realmInfo=&quot; + realmInfo +
                &quot;, creationTime=&quot; + creationTime +
                '}';
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>