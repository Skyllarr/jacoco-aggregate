<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>KeyStoreCredentialStore.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">WildFly Elytron</a> &gt; <a href="../index.html" class="el_bundle">wildfly-elytron-credential-store</a> &gt; <a href="index.source.html" class="el_package">org.wildfly.security.credential.store.impl</a> &gt; <span class="el_source">KeyStoreCredentialStore.java</span></div><h1>KeyStoreCredentialStore.java</h1><pre class="source lang-java linenums">/*
 * JBoss, Home of Professional Open Source.
 * Copyright 2016 Red Hat, Inc., and individual contributors
 * as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.wildfly.security.credential.store.impl;

import static org.wildfly.security.credential.store._private.ElytronMessages.log;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.AlgorithmParameters;
import java.security.GeneralSecurityException;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.Provider;
import java.security.PublicKey;
import java.security.Security;
import java.security.UnrecoverableEntryException;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.spec.AlgorithmParameterSpec;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.InvalidParameterSpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Arrays;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import org.wildfly.common.Assert;
import org.wildfly.common.codec.Base32Alphabet;
import org.wildfly.common.iteration.ByteIterator;
import org.wildfly.common.iteration.CodePointIterator;
import org.wildfly.security.EmptyProvider;
import org.wildfly.security.asn1.ASN1Exception;
import org.wildfly.security.asn1.DERDecoder;
import org.wildfly.security.asn1.DEREncoder;
import org.wildfly.security.credential.AlgorithmCredential;
import org.wildfly.security.credential.BearerTokenCredential;
import org.wildfly.security.credential.Credential;
import org.wildfly.security.credential.KeyPairCredential;
import org.wildfly.security.credential.PasswordCredential;
import org.wildfly.security.credential.PublicKeyCredential;
import org.wildfly.security.credential.SecretKeyCredential;
import org.wildfly.security.credential.X509CertificateChainPrivateCredential;
import org.wildfly.security.credential.X509CertificateChainPublicCredential;
import org.wildfly.security.credential.source.CredentialSource;
import org.wildfly.security.credential.store.CredentialStore;
import org.wildfly.security.credential.store.CredentialStoreException;
import org.wildfly.security.credential.store.CredentialStoreSpi;
import org.wildfly.security.key.KeyUtil;
import org.wildfly.security.password.Password;
import org.wildfly.security.password.PasswordFactory;
import org.wildfly.security.password.interfaces.BCryptPassword;
import org.wildfly.security.password.interfaces.BSDUnixDESCryptPassword;
import org.wildfly.security.password.interfaces.ClearPassword;
import org.wildfly.security.password.interfaces.DigestPassword;
import org.wildfly.security.password.interfaces.MaskedPassword;
import org.wildfly.security.password.interfaces.OneTimePassword;
import org.wildfly.security.password.interfaces.SaltedSimpleDigestPassword;
import org.wildfly.security.password.interfaces.ScramDigestPassword;
import org.wildfly.security.password.interfaces.SimpleDigestPassword;
import org.wildfly.security.password.interfaces.SunUnixMD5CryptPassword;
import org.wildfly.security.password.interfaces.UnixDESCryptPassword;
import org.wildfly.security.password.interfaces.UnixMD5CryptPassword;
import org.wildfly.security.password.interfaces.UnixSHACryptPassword;
import org.wildfly.security.password.spec.ClearPasswordSpec;
import org.wildfly.security.password.spec.DigestPasswordSpec;
import org.wildfly.security.password.spec.HashPasswordSpec;
import org.wildfly.security.password.spec.IteratedSaltedHashPasswordSpec;
import org.wildfly.security.password.spec.MaskedPasswordSpec;
import org.wildfly.security.password.spec.OneTimePasswordSpec;
import org.wildfly.security.password.spec.PasswordSpec;
import org.wildfly.security.password.spec.SaltedHashPasswordSpec;
import org.wildfly.security.util.AtomicFileOutputStream;
import org.wildfly.security.x500.X500;

/**
 * A flexible credential store which is backed by a key store.  The key store holds the credentials, encoding identifying
 * information into the alias to allow multiple credentials to be stored under each alias (something keystores generally
 * do not support).
 * &lt;p&gt;
 * This credential store cannot convert an arbitrary key store into a credential store; it can only understand entries that
 * it itself has added.  Entries not understood by this credential store will be ignored (and a log message will be
 * generated indicating the presence of unknown credentials).
 * &lt;p&gt;
 * The following configuration parameters are supported:
 * &lt;ul&gt;
 *     &lt;li&gt;{@code location}: specifies the location of the key store (none means, use an in-memory store and do not store changes)&lt;/li&gt;
 *     &lt;li&gt;{@code modifiable}: specifies whether the credential store should be modifiable&lt;/li&gt;
 *     &lt;li&gt;{@code create}: specifies to automatically create storage file for this credential store (defaults to {@code false}).
 *          &lt;p&gt;
 *          If {@code external} is true, the storage file will be created calling the {@link #flush} method. If {@code external} is false and the storage file does not exist yet,
 *          then an empty credential store is created when {@link #initialize} method is invoked.&lt;/li&gt;
 *     &lt;li&gt;{@code keyStoreType}: specifies the key store type to use (defaults to {@link KeyStore#getDefaultType()})&lt;/li&gt;
 *     &lt;li&gt;{@code keyAlias}: specifies the secret key alias within the key store to use for encrypt/decrypt of data in external storage (defaults to {@code cs_key})&lt;/li&gt;
 *     &lt;li&gt;{@code external}: specifies whether to store data to external storage and encrypted by {@code keyAlias} key (defaults to {@code false})&lt;/li&gt;
 *     &lt;li&gt;{@code externalPath}: specifies path to the external storage. It has to be used in conjunction with {@code external=true}&lt;/li&gt;
 *     &lt;li&gt;{@code cryptoAlg}: cryptographic algorithm name to be used to encrypt decrypt entries at external storage ({@code external} has to be set to {@code true})&lt;/li&gt;
 * &lt;/ul&gt;
 */
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">public final class KeyStoreCredentialStore extends CredentialStoreSpi {</span>

    private static final String DATA_OID = &quot;1.2.840.113549.1.7.1&quot;;

    /**
     * The name of this credential store implementation.
     */
<span class="fc" id="L157">    public static final String KEY_STORE_CREDENTIAL_STORE = KeyStoreCredentialStore.class.getSimpleName();</span>

    private static final String X_509 = &quot;X.509&quot;;
    private static final String CREATE = &quot;create&quot;;
    private static final String CRYPTOALG = &quot;cryptoAlg&quot;;
    private static final String EXTERNAL = &quot;external&quot;;
    private static final String EXTERNALPATH = &quot;externalPath&quot;;
    private static final String KEYALIAS = &quot;keyAlias&quot;;
    private static final String KEYSTORETYPE = &quot;keyStoreType&quot;;
    private static final String LOCATION = &quot;location&quot;;
    private static final String MODIFIABLE = &quot;modifiable&quot;;

<span class="fc" id="L169">    private static final List&lt;String&gt; validAttribtues = Arrays.asList(CREATE, CRYPTOALG, EXTERNAL, EXTERNALPATH, KEYALIAS,</span>
            KEYSTORETYPE, LOCATION, MODIFIABLE);

<span class="fc" id="L172">    private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();</span>
<span class="fc" id="L173">    private final HashMap&lt;String, TopEntry&gt; cache = new HashMap&lt;&gt;();</span>
    private volatile boolean modifiable;
    private KeyStore keyStore;
    private Path location;
    private Path externalPath;
    private boolean create;
    private CredentialStore.ProtectionParameter protectionParameter;
    private Provider[] providers;
    private String encryptionKeyAlias;
<span class="fc" id="L182">    private boolean useExternalStorage = false;</span>
    private ExternalStorage externalStorage;
    private String cryptographicAlgorithm;

    public void initialize(final Map&lt;String, String&gt; attributes, final CredentialStore.ProtectionParameter protectionParameter, final Provider[] providers) throws CredentialStoreException {
<span class="fc" id="L187">        try (Hold hold = lockForWrite()) {</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">            if (protectionParameter == null) {</span>
<span class="nc" id="L189">                throw log.protectionParameterRequired();</span>
            }
<span class="fc" id="L191">            validateAttribute(attributes, validAttribtues);</span>
<span class="fc" id="L192">            cache.clear();</span>
<span class="fc" id="L193">            this.protectionParameter = protectionParameter;</span>
<span class="fc" id="L194">            modifiable = Boolean.parseBoolean(attributes.getOrDefault(MODIFIABLE, &quot;true&quot;));</span>
<span class="fc" id="L195">            create = Boolean.parseBoolean(attributes.getOrDefault(CREATE, &quot;false&quot;));</span>
<span class="fc" id="L196">            this.providers = providers;</span>
<span class="fc" id="L197">            String keyStoreType = attributes.getOrDefault(KEYSTORETYPE, KeyStore.getDefaultType());</span>
<span class="fc" id="L198">            final String locationName = attributes.get(LOCATION);</span>
<span class="fc" id="L199">            final String externalPathName = attributes.get(EXTERNALPATH);</span>
            try {
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">               location = locationName == null ? null : Paths.get(locationName);</span>
<span class="pc bpc" id="L202" title="1 of 4 branches missed.">               if (location != null &amp;&amp; Files.isSymbolicLink(location)) {</span>
<span class="fc" id="L203">                  location = location.toRealPath();</span>
               }
<span class="fc" id="L205">               useExternalStorage = Boolean.parseBoolean(attributes.getOrDefault(EXTERNAL, &quot;false&quot;));</span>
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">               if (useExternalStorage) {</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">                   if (externalPathName == null) {</span>
<span class="nc" id="L208">                       throw log.externalPathMissing(keyStoreType);</span>
                   } else {
<span class="nc" id="L210">                       externalPath = Paths.get(externalPathName);</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">                       if (Files.isSymbolicLink(externalPath)) {</span>
<span class="nc" id="L212">                          externalPath = externalPath.toRealPath();</span>
                       }
<span class="nc bnc" id="L214" title="All 2 branches missed.">                       if (externalPath.equals(location)) {</span>
<span class="nc" id="L215">                           throw log.locationAndExternalPathAreIdentical(location.toString(), externalPath.toString());</span>
                       }
                   }
               }
<span class="nc" id="L219">            } catch (IOException e) {</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">               throw log.credentialStoreFileDoesNotExist(useExternalStorage ? externalPathName : locationName);</span>
<span class="fc" id="L221">            }</span>
<span class="fc" id="L222">            encryptionKeyAlias = attributes.getOrDefault(KEYALIAS, &quot;cs_key&quot;);</span>
<span class="fc" id="L223">            cryptographicAlgorithm = attributes.get(CRYPTOALG);</span>
<span class="fc" id="L224">            load(keyStoreType);</span>
<span class="pc bpc" id="L225" title="2 of 8 branches missed.">            if ( create  &amp;&amp; !useExternalStorage &amp;&amp; location != null &amp;&amp; !Files.exists(location) ){</span>
                //Only in this case, flush the data to the file allowing the credential store creation independently of modifiable flag
<span class="fc" id="L227">                flush();</span>
            }
<span class="fc" id="L229">            initialized = true;</span>
        }
<span class="fc" id="L231">    }</span>

    public boolean isModifiable() {
<span class="nc" id="L234">        return modifiable;</span>
    }

    public void store(final String credentialAlias, final Credential credential, final CredentialStore.ProtectionParameter protectionParameter) throws CredentialStoreException {
        try {
            // first, attempt to encode the credential into a keystore entry
<span class="fc" id="L240">            final Class&lt;? extends Credential&gt; credentialClass = credential.getClass();</span>
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">            final String algorithmName = credential instanceof AlgorithmCredential ? ((AlgorithmCredential) credential).getAlgorithm() : null;</span>
<span class="fc" id="L242">            final AlgorithmParameterSpec parameterSpec = credential.castAndApply(AlgorithmCredential.class, AlgorithmCredential::getParameters);</span>
            final KeyStore.Entry entry;
<span class="fc bfc" id="L244" title="All 2 branches covered.">            if (credentialClass == SecretKeyCredential.class) {</span>
<span class="fc" id="L245">                entry = new KeyStore.SecretKeyEntry(credential.castAndApply(SecretKeyCredential.class, SecretKeyCredential::getSecretKey));</span>
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">            } else if (credentialClass == PublicKeyCredential.class) {</span>
<span class="nc" id="L247">                final PublicKey publicKey = credential.castAndApply(PublicKeyCredential.class, PublicKeyCredential::getPublicKey);</span>
<span class="nc" id="L248">                final KeyFactory keyFactory = KeyFactory.getInstance(publicKey.getAlgorithm());</span>
<span class="nc" id="L249">                final X509EncodedKeySpec keySpec = keyFactory.getKeySpec(keyFactory.translateKey(publicKey), X509EncodedKeySpec.class);</span>
<span class="nc" id="L250">                final byte[] encoded = keySpec.getEncoded();</span>
<span class="nc" id="L251">                entry = new KeyStore.SecretKeyEntry(new SecretKeySpec(encoded, DATA_OID));</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">            } else if (credentialClass == KeyPairCredential.class) {</span>
<span class="nc" id="L253">                final KeyPair keyPair = credential.castAndApply(KeyPairCredential.class, KeyPairCredential::getKeyPair);</span>
<span class="nc" id="L254">                final PublicKey publicKey = keyPair.getPublic();</span>
<span class="nc" id="L255">                final PrivateKey privateKey = keyPair.getPrivate();</span>
<span class="nc" id="L256">                final KeyFactory keyFactory = KeyFactory.getInstance(publicKey.getAlgorithm());</span>
                // ensured by KeyPairCredential
<span class="nc bnc" id="L258" title="All 4 branches missed.">                assert privateKey.getAlgorithm().equals(publicKey.getAlgorithm());</span>
<span class="nc" id="L259">                final X509EncodedKeySpec publicSpec = keyFactory.getKeySpec(keyFactory.translateKey(publicKey), X509EncodedKeySpec.class);</span>
<span class="nc" id="L260">                final PKCS8EncodedKeySpec privateSpec = keyFactory.getKeySpec(keyFactory.translateKey(privateKey), PKCS8EncodedKeySpec.class);</span>
<span class="nc" id="L261">                final DEREncoder encoder = new DEREncoder();</span>
<span class="nc" id="L262">                encoder.startSequence();</span>
<span class="nc" id="L263">                encoder.writeEncoded(publicSpec.getEncoded());</span>
<span class="nc" id="L264">                encoder.writeEncoded(privateSpec.getEncoded());</span>
<span class="nc" id="L265">                encoder.endSequence();</span>
<span class="nc" id="L266">                entry = new KeyStore.SecretKeyEntry(new SecretKeySpec(encoder.getEncoded(), DATA_OID));</span>
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">            } else if (credentialClass == X509CertificateChainPublicCredential.class) {</span>
<span class="nc" id="L268">                final X509Certificate[] x509Certificates = credential.castAndApply(X509CertificateChainPublicCredential.class, X509CertificateChainPublicCredential::getCertificateChain);</span>
<span class="nc" id="L269">                final DEREncoder encoder = new DEREncoder();</span>
<span class="nc" id="L270">                encoder.encodeInteger(x509Certificates.length);</span>
<span class="nc" id="L271">                encoder.startSequence();</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">                for (X509Certificate x509Certificate : x509Certificates) {</span>
<span class="nc" id="L273">                    encoder.writeEncoded(x509Certificate.getEncoded());</span>
                }
<span class="nc" id="L275">                encoder.endSequence();</span>
<span class="nc" id="L276">                entry = new KeyStore.SecretKeyEntry(new SecretKeySpec(encoder.getEncoded(), DATA_OID));</span>
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">            } else if (credentialClass == X509CertificateChainPrivateCredential.class) {</span>
                @SuppressWarnings(&quot;ConstantConditions&quot;)
<span class="nc" id="L279">                X509CertificateChainPrivateCredential cred = (X509CertificateChainPrivateCredential) credential;</span>
<span class="nc" id="L280">                entry = new KeyStore.PrivateKeyEntry(cred.getPrivateKey(), cred.getCertificateChain());</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">            } else if (credentialClass == BearerTokenCredential.class) {</span>
<span class="nc" id="L282">                entry = new KeyStore.SecretKeyEntry(new SecretKeySpec(credential.castAndApply(BearerTokenCredential.class, c -&gt; c.getToken().getBytes(StandardCharsets.UTF_8)), DATA_OID));</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">            } else if (credentialClass == PasswordCredential.class) {</span>
<span class="fc" id="L284">                final Password password = credential.castAndApply(PasswordCredential.class, PasswordCredential::getPassword);</span>
<span class="fc" id="L285">                final String algorithm = password.getAlgorithm();</span>
<span class="fc" id="L286">                final DEREncoder encoder = new DEREncoder();</span>
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">                final PasswordFactory passwordFactory = providers != null ? PasswordFactory.getInstance(algorithm, () -&gt; providers) : PasswordFactory.getInstance(algorithm);</span>
<span class="pc bpc" id="L288" title="6 of 7 branches missed.">                switch (algorithm) {</span>
                    case BCryptPassword.ALGORITHM_BCRYPT:
                    case BSDUnixDESCryptPassword.ALGORITHM_BSD_CRYPT_DES:
                    case ScramDigestPassword.ALGORITHM_SCRAM_SHA_1:
                    case ScramDigestPassword.ALGORITHM_SCRAM_SHA_256:
                    case ScramDigestPassword.ALGORITHM_SCRAM_SHA_384:
                    case ScramDigestPassword.ALGORITHM_SCRAM_SHA_512:
                    case SunUnixMD5CryptPassword.ALGORITHM_SUN_CRYPT_MD5:
                    case SunUnixMD5CryptPassword.ALGORITHM_SUN_CRYPT_MD5_BARE_SALT:
                    case UnixSHACryptPassword.ALGORITHM_CRYPT_SHA_256:
                    case UnixSHACryptPassword.ALGORITHM_CRYPT_SHA_512: {
<span class="nc" id="L299">                        IteratedSaltedHashPasswordSpec passwordSpec = passwordFactory.getKeySpec(passwordFactory.translate(password), IteratedSaltedHashPasswordSpec.class);</span>
<span class="nc" id="L300">                        encoder.startSequence();</span>
<span class="nc" id="L301">                        encoder.encodeOctetString(passwordSpec.getHash());</span>
<span class="nc" id="L302">                        encoder.encodeOctetString(passwordSpec.getSalt());</span>
<span class="nc" id="L303">                        encoder.encodeInteger(passwordSpec.getIterationCount());</span>
<span class="nc" id="L304">                        encoder.endSequence();</span>
<span class="nc" id="L305">                        break;</span>
                    }
                    case ClearPassword.ALGORITHM_CLEAR: {
<span class="fc" id="L308">                        final ClearPasswordSpec passwordSpec = passwordFactory.getKeySpec(passwordFactory.translate(password), ClearPasswordSpec.class);</span>
<span class="fc" id="L309">                        encoder.encodeOctetString(new String(passwordSpec.getEncodedPassword()));</span>
<span class="fc" id="L310">                        break;</span>
                    }
                    case DigestPassword.ALGORITHM_DIGEST_MD5:
                    case DigestPassword.ALGORITHM_DIGEST_SHA:
                    case DigestPassword.ALGORITHM_DIGEST_SHA_256:
                    case DigestPassword.ALGORITHM_DIGEST_SHA_384:
                    case DigestPassword.ALGORITHM_DIGEST_SHA_512:
                    case DigestPassword.ALGORITHM_DIGEST_SHA_512_256: {
<span class="nc" id="L318">                        final DigestPasswordSpec passwordSpec = passwordFactory.getKeySpec(passwordFactory.translate(password), DigestPasswordSpec.class);</span>
<span class="nc" id="L319">                        encoder.startSequence();</span>
<span class="nc" id="L320">                        encoder.encodeOctetString(passwordSpec.getUsername());</span>
<span class="nc" id="L321">                        encoder.encodeOctetString(passwordSpec.getRealm());</span>
<span class="nc" id="L322">                        encoder.encodeOctetString(passwordSpec.getDigest());</span>
<span class="nc" id="L323">                        encoder.endSequence();</span>
<span class="nc" id="L324">                        break;</span>
                    }
                    case OneTimePassword.ALGORITHM_OTP_MD5:
                    case OneTimePassword.ALGORITHM_OTP_SHA1:
                    case OneTimePassword.ALGORITHM_OTP_SHA_256:
                    case OneTimePassword.ALGORITHM_OTP_SHA_384:
                    case OneTimePassword.ALGORITHM_OTP_SHA_512: {
<span class="nc" id="L331">                        final OneTimePasswordSpec passwordSpec = passwordFactory.getKeySpec(passwordFactory.translate(password), OneTimePasswordSpec.class);</span>
<span class="nc" id="L332">                        encoder.startSequence();</span>
<span class="nc" id="L333">                        encoder.encodeOctetString(passwordSpec.getHash());</span>
<span class="nc" id="L334">                        encoder.encodeIA5String(passwordSpec.getSeed());</span>
<span class="nc" id="L335">                        encoder.encodeInteger(passwordSpec.getSequenceNumber());</span>
<span class="nc" id="L336">                        encoder.endSequence();</span>
<span class="nc" id="L337">                        break;</span>
                    }
                    case SaltedSimpleDigestPassword.ALGORITHM_PASSWORD_SALT_DIGEST_MD5:
                    case SaltedSimpleDigestPassword.ALGORITHM_PASSWORD_SALT_DIGEST_SHA_1:
                    case SaltedSimpleDigestPassword.ALGORITHM_PASSWORD_SALT_DIGEST_SHA_256:
                    case SaltedSimpleDigestPassword.ALGORITHM_PASSWORD_SALT_DIGEST_SHA_384:
                    case SaltedSimpleDigestPassword.ALGORITHM_PASSWORD_SALT_DIGEST_SHA_512:
                    case SaltedSimpleDigestPassword.ALGORITHM_SALT_PASSWORD_DIGEST_MD5:
                    case SaltedSimpleDigestPassword.ALGORITHM_SALT_PASSWORD_DIGEST_SHA_1:
                    case SaltedSimpleDigestPassword.ALGORITHM_SALT_PASSWORD_DIGEST_SHA_256:
                    case SaltedSimpleDigestPassword.ALGORITHM_SALT_PASSWORD_DIGEST_SHA_384:
                    case SaltedSimpleDigestPassword.ALGORITHM_SALT_PASSWORD_DIGEST_SHA_512:
                    case UnixDESCryptPassword.ALGORITHM_CRYPT_DES:
                    case UnixMD5CryptPassword.ALGORITHM_CRYPT_MD5: {
<span class="nc" id="L351">                        final SaltedHashPasswordSpec passwordSpec = passwordFactory.getKeySpec(passwordFactory.translate(password), SaltedHashPasswordSpec.class);</span>
<span class="nc" id="L352">                        encoder.startSequence();</span>
<span class="nc" id="L353">                        encoder.encodeOctetString(passwordSpec.getHash());</span>
<span class="nc" id="L354">                        encoder.encodeOctetString(passwordSpec.getSalt());</span>
<span class="nc" id="L355">                        encoder.endSequence();</span>
<span class="nc" id="L356">                        break;</span>
                    }
                    case SimpleDigestPassword.ALGORITHM_SIMPLE_DIGEST_MD2:
                    case SimpleDigestPassword.ALGORITHM_SIMPLE_DIGEST_MD5:
                    case SimpleDigestPassword.ALGORITHM_SIMPLE_DIGEST_SHA_1:
                    case SimpleDigestPassword.ALGORITHM_SIMPLE_DIGEST_SHA_256:
                    case SimpleDigestPassword.ALGORITHM_SIMPLE_DIGEST_SHA_384:
                    case SimpleDigestPassword.ALGORITHM_SIMPLE_DIGEST_SHA_512: {
<span class="nc" id="L364">                        final HashPasswordSpec passwordSpec = passwordFactory.getKeySpec(passwordFactory.translate(password), HashPasswordSpec.class);</span>
<span class="nc" id="L365">                        encoder.startSequence();</span>
<span class="nc" id="L366">                        encoder.encodeOctetString(passwordSpec.getDigest());</span>
<span class="nc" id="L367">                        encoder.endSequence();</span>
<span class="nc" id="L368">                        break;</span>
                    }
                    default: {
<span class="nc bnc" id="L371" title="All 2 branches missed.">                        if (MaskedPassword.isMaskedAlgorithm(algorithmName)) {</span>
<span class="nc" id="L372">                            final MaskedPasswordSpec passwordSpec = passwordFactory.getKeySpec(passwordFactory.translate(password), MaskedPasswordSpec.class);</span>
<span class="nc" id="L373">                            encoder.startSequence();</span>
<span class="nc" id="L374">                            encoder.encodeOctetString(new String(passwordSpec.getInitialKeyMaterial()));</span>
<span class="nc" id="L375">                            encoder.encodeInteger(passwordSpec.getIterationCount());</span>
<span class="nc" id="L376">                            encoder.encodeOctetString(passwordSpec.getSalt());</span>
<span class="nc" id="L377">                            encoder.encodeOctetString(passwordSpec.getMaskedPasswordBytes());</span>
<span class="nc" id="L378">                            encoder.endSequence();</span>
<span class="nc" id="L379">                            break;</span>
                        } else {
<span class="nc" id="L381">                            throw log.unsupportedCredentialType(credentialClass);</span>
                        }
                    }
                }
<span class="fc" id="L385">                entry = new KeyStore.SecretKeyEntry(new SecretKeySpec(encoder.getEncoded(), DATA_OID));</span>
<span class="fc" id="L386">            } else {</span>
<span class="nc" id="L387">                throw log.unsupportedCredentialType(credentialClass);</span>
            }
            // now, store it under a unique alias
<span class="fc" id="L390">            final String ksAlias = calculateNewAlias(credentialAlias, credentialClass, algorithmName, parameterSpec);</span>
<span class="fc" id="L391">            try (Hold hold = lockForWrite()) {</span>
<span class="fc" id="L392">                keyStore.setEntry(ksAlias, entry, convertParameter(protectionParameter));</span>
<span class="fc" id="L393">                final TopEntry topEntry = cache.computeIfAbsent(toLowercase(credentialAlias), TopEntry::new);</span>
<span class="fc" id="L394">                final MidEntry midEntry = topEntry.getMap().computeIfAbsent(credentialClass, c -&gt; new MidEntry(topEntry, c));</span>
                final BottomEntry bottomEntry;
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">                if (algorithmName != null) {</span>
<span class="fc" id="L397">                    bottomEntry = midEntry.getMap().computeIfAbsent(algorithmName, n -&gt; new BottomEntry(midEntry, n));</span>
                } else {
<span class="nc" id="L399">                    bottomEntry = midEntry.getOrCreateNoAlgorithm();</span>
                }
                final String oldAlias;
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">                if (parameterSpec != null) {</span>
<span class="nc" id="L403">                    oldAlias = bottomEntry.getMap().put(new ParamKey(parameterSpec), ksAlias);</span>
                } else {
<span class="fc" id="L405">                    oldAlias = bottomEntry.setNoParams(ksAlias);</span>
                }
<span class="pc bpc" id="L407" title="3 of 4 branches missed.">                if (oldAlias != null &amp;&amp; ! oldAlias.equals(ksAlias)) {</span>
                    // unlikely but possible
<span class="nc" id="L409">                    keyStore.deleteEntry(oldAlias);</span>
                }
            }
<span class="nc" id="L412">        } catch (KeyStoreException | NoSuchAlgorithmException | InvalidKeySpecException | InvalidKeyException | CertificateException e) {</span>
<span class="nc" id="L413">            throw log.cannotWriteCredentialToStore(e);</span>
<span class="fc" id="L414">        }</span>
<span class="fc" id="L415">    }</span>

    public &lt;C extends Credential&gt; C retrieve(final String credentialAlias, final Class&lt;C&gt; credentialType, final String credentialAlgorithm, final AlgorithmParameterSpec parameterSpec, final CredentialStore.ProtectionParameter protectionParameter) throws CredentialStoreException {
        final KeyStore.Entry entry;
        final MidEntry midEntry;
        final BottomEntry bottomEntry;
        final String ksAlias;
<span class="fc" id="L422">        try (Hold hold = lockForRead()) {</span>
<span class="fc" id="L423">            final TopEntry topEntry = cache.get(toLowercase(credentialAlias));</span>
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">            if (topEntry == null) {</span>
<span class="nc" id="L425">                log.trace(&quot;KeyStoreCredentialStore: alias not found in cache&quot;);</span>
<span class="nc" id="L426">                return null;</span>
            }
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">            if (topEntry.getMap().containsKey(credentialType)) {</span>
<span class="fc" id="L429">                log.trace(&quot;KeyStoreCredentialStore: contains exact type&quot;);</span>
<span class="fc" id="L430">                midEntry = topEntry.getMap().get(credentialType);</span>
            } else {
                // loose (slow) match
<span class="nc" id="L433">                final Iterator&lt;MidEntry&gt; iterator = topEntry.getMap().values().iterator();</span>
                for (;;) {
<span class="nc bnc" id="L435" title="All 2 branches missed.">                    if (! iterator.hasNext()) {</span>
<span class="nc" id="L436">                        log.trace(&quot;KeyStoreCredentialStore: no assignable found&quot;);</span>
<span class="nc" id="L437">                        return null;</span>
                    }
<span class="nc" id="L439">                    MidEntry item = iterator.next();</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">                    if (credentialType.isAssignableFrom(item.getCredentialType())) {</span>
<span class="nc" id="L441">                        log.trace(&quot;KeyStoreCredentialStore: assignable found&quot;);</span>
<span class="nc" id="L442">                        midEntry = item;</span>
<span class="nc" id="L443">                        break;</span>
                    }
<span class="nc" id="L445">                }</span>
            }
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">            if (credentialAlgorithm != null) {</span>
<span class="nc" id="L448">                bottomEntry = midEntry.getMap().get(credentialAlgorithm);</span>
            } else {
                // match any
<span class="fc" id="L451">                final Iterator&lt;BottomEntry&gt; iterator = midEntry.getMap().values().iterator();</span>
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">                if (iterator.hasNext()) {</span>
<span class="fc" id="L453">                    bottomEntry = iterator.next();</span>
                } else {
<span class="nc" id="L455">                    bottomEntry = midEntry.getNoAlgorithm();</span>
                }
            }
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">            if (bottomEntry == null) {</span>
<span class="nc" id="L459">                log.tracef(&quot;KeyStoreCredentialStore: no entry for algorithm %s&quot;, credentialAlgorithm);</span>
<span class="nc" id="L460">                return null;</span>
            }
<span class="pc bpc" id="L462" title="1 of 2 branches missed.">            if (parameterSpec != null) {</span>
<span class="nc" id="L463">                ksAlias = bottomEntry.getMap().get(new ParamKey(parameterSpec));</span>
            } else {
                // match any
<span class="fc" id="L466">                final Iterator&lt;String&gt; iterator = bottomEntry.getMap().values().iterator();</span>
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">                if (iterator.hasNext()) {</span>
<span class="nc" id="L468">                    ksAlias = iterator.next();</span>
                } else {
<span class="fc" id="L470">                    ksAlias = bottomEntry.getNoParams();</span>
                }
            }
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">            if (ksAlias == null) {</span>
<span class="nc" id="L474">                log.tracef(&quot;KeyStoreCredentialStore: no entry for parameterSpec %s&quot;, parameterSpec);</span>
<span class="nc" id="L475">                return null;</span>
            }
<span class="fc" id="L477">            entry = keyStore.getEntry(ksAlias, convertParameter(protectionParameter));</span>
<span class="nc bnc" id="L478" title="All 8 branches missed.">        } catch (NoSuchAlgorithmException | UnrecoverableEntryException | KeyStoreException e) {</span>
<span class="nc" id="L479">            throw log.cannotAcquireCredentialFromStore(e);</span>
<span class="fc" id="L480">        }</span>
<span class="pc bpc" id="L481" title="1 of 2 branches missed.">        if (entry == null) {</span>
            // odd, but we can handle it
<span class="nc" id="L483">            log.trace(&quot;KeyStoreCredentialStore: null entry&quot;);</span>
<span class="nc" id="L484">            return null;</span>
        }
<span class="fc" id="L486">        final Class&lt;? extends Credential&gt; matchedCredentialType = midEntry.getCredentialType();</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">        if (matchedCredentialType == SecretKeyCredential.class) {</span>
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">            if (entry instanceof KeyStore.SecretKeyEntry) {</span>
                // simple
<span class="fc" id="L490">                final SecretKey secretKey = ((KeyStore.SecretKeyEntry) entry).getSecretKey();</span>
<span class="fc" id="L491">                return credentialType.cast(new SecretKeyCredential(secretKey));</span>
            } else {
<span class="nc" id="L493">                throw log.invalidCredentialStoreEntryType(KeyStore.SecretKeyEntry.class, entry.getClass());</span>
            }
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">        } else if (matchedCredentialType == PublicKeyCredential.class) {</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">            if (entry instanceof KeyStore.SecretKeyEntry) try {</span>
                // we store as a secret key because we can't store the public key properly...
<span class="nc" id="L498">                final SecretKey secretKey = ((KeyStore.SecretKeyEntry) entry).getSecretKey();</span>
<span class="nc" id="L499">                final byte[] encoded = secretKey.getEncoded();</span>
<span class="nc" id="L500">                final String matchedAlgorithm = bottomEntry.getAlgorithm();</span>
<span class="nc bnc" id="L501" title="All 4 branches missed.">                assert matchedAlgorithm != null; // because PublicKeyCredential is an AlgorithmCredential</span>
<span class="nc" id="L502">                final KeyFactory keyFactory = KeyFactory.getInstance(matchedAlgorithm);</span>
<span class="nc" id="L503">                final PublicKey publicKey = keyFactory.generatePublic(new X509EncodedKeySpec(encoded));</span>
<span class="nc" id="L504">                return credentialType.cast(new PublicKeyCredential(publicKey));</span>
<span class="nc" id="L505">            } catch (InvalidKeySpecException | NoSuchAlgorithmException e) {</span>
<span class="nc" id="L506">                throw log.cannotAcquireCredentialFromStore(e);</span>
            } else {
<span class="nc" id="L508">                throw log.invalidCredentialStoreEntryType(KeyStore.SecretKeyEntry.class, entry.getClass());</span>
            }
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">        } else if (matchedCredentialType == KeyPairCredential.class) {</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">            if (entry instanceof KeyStore.SecretKeyEntry) try {</span>
<span class="nc" id="L512">                final SecretKey secretKey = ((KeyStore.SecretKeyEntry) entry).getSecretKey();</span>
<span class="nc" id="L513">                final byte[] encoded = secretKey.getEncoded();</span>
<span class="nc" id="L514">                final String matchedAlgorithm = bottomEntry.getAlgorithm();</span>
<span class="nc bnc" id="L515" title="All 4 branches missed.">                assert matchedAlgorithm != null; // because KeyPairCredential is an AlgorithmCredential</span>
                // extract public and private segments
<span class="nc" id="L517">                final DERDecoder decoder = new DERDecoder(encoded);</span>
<span class="nc" id="L518">                decoder.startSequence();</span>
<span class="nc" id="L519">                final byte[] publicBytes = decoder.drainElement();</span>
<span class="nc" id="L520">                final byte[] privateBytes = decoder.drainElement();</span>
<span class="nc" id="L521">                decoder.endSequence();</span>
<span class="nc" id="L522">                final KeyFactory keyFactory = KeyFactory.getInstance(matchedAlgorithm);</span>
<span class="nc" id="L523">                final PublicKey publicKey = keyFactory.generatePublic(new X509EncodedKeySpec(publicBytes));</span>
<span class="nc" id="L524">                final PrivateKey privateKey = keyFactory.generatePrivate(new PKCS8EncodedKeySpec(privateBytes));</span>
<span class="nc" id="L525">                final KeyPair keyPair = new KeyPair(publicKey, privateKey);</span>
<span class="nc" id="L526">                return credentialType.cast(new KeyPairCredential(keyPair));</span>
<span class="nc" id="L527">            } catch (InvalidKeySpecException | NoSuchAlgorithmException | ASN1Exception e) {</span>
<span class="nc" id="L528">                throw log.cannotAcquireCredentialFromStore(e);</span>
            } else {
<span class="nc" id="L530">                throw log.invalidCredentialStoreEntryType(KeyStore.SecretKeyEntry.class, entry.getClass());</span>
            }
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">        } else if (matchedCredentialType == X509CertificateChainPublicCredential.class) {</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">            if (entry instanceof KeyStore.SecretKeyEntry) try {</span>
                // OK so this is pretty ugly, but the TrustedCertificateEntry type only holds a single cert so it's no good
<span class="nc" id="L535">                final SecretKey secretKey = ((KeyStore.SecretKeyEntry) entry).getSecretKey();</span>
<span class="nc" id="L536">                final byte[] encoded = secretKey.getEncoded();</span>
<span class="nc" id="L537">                final String matchedAlgorithm = bottomEntry.getAlgorithm();</span>
<span class="nc bnc" id="L538" title="All 4 branches missed.">                assert matchedAlgorithm != null; // because it is an AlgorithmCredential</span>
<span class="nc" id="L539">                final DERDecoder decoder = new DERDecoder(encoded);</span>
<span class="nc" id="L540">                final CertificateFactory certificateFactory = CertificateFactory.getInstance(X_509);</span>
<span class="nc" id="L541">                final int count = decoder.decodeInteger().intValueExact();</span>
<span class="nc" id="L542">                final X509Certificate[] array = new X509Certificate[count];</span>
<span class="nc" id="L543">                decoder.startSequence();</span>
<span class="nc" id="L544">                int i = 0;</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">                while (decoder.hasNextElement()) {</span>
<span class="nc" id="L546">                    final byte[] certBytes = decoder.drainElement();</span>
<span class="nc" id="L547">                    array[i ++] = (X509Certificate) certificateFactory.generateCertificate(new ByteArrayInputStream(certBytes));</span>
<span class="nc" id="L548">                }</span>
<span class="nc" id="L549">                decoder.endSequence();</span>
<span class="nc" id="L550">                return credentialType.cast(new X509CertificateChainPublicCredential(array));</span>
<span class="nc" id="L551">            } catch (ASN1Exception | CertificateException | ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L552">                throw log.cannotAcquireCredentialFromStore(e);</span>
            } else {
<span class="nc" id="L554">                throw log.invalidCredentialStoreEntryType(KeyStore.SecretKeyEntry.class, entry.getClass());</span>
            }
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">        } else if (matchedCredentialType == X509CertificateChainPrivateCredential.class) {</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">            if (entry instanceof KeyStore.PrivateKeyEntry) {</span>
                // an entry type that matches our credential type!
<span class="nc" id="L559">                final KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry) entry;</span>
<span class="nc" id="L560">                final PrivateKey privateKey = privateKeyEntry.getPrivateKey();</span>
<span class="nc" id="L561">                final Certificate[] certificateChain = privateKeyEntry.getCertificateChain();</span>
<span class="nc" id="L562">                final X509Certificate[] x509Certificates = X500.asX509CertificateArray(certificateChain);</span>
<span class="nc" id="L563">                return credentialType.cast(new X509CertificateChainPrivateCredential(privateKey, x509Certificates));</span>
            } else {
<span class="nc" id="L565">                throw log.invalidCredentialStoreEntryType(KeyStore.PrivateKeyEntry.class, entry.getClass());</span>
            }
<span class="pc bpc" id="L567" title="1 of 2 branches missed.">        } else if (matchedCredentialType == BearerTokenCredential.class) {</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">            if (entry instanceof KeyStore.SecretKeyEntry) {</span>
<span class="nc" id="L569">                final SecretKey secretKey = ((KeyStore.SecretKeyEntry) entry).getSecretKey();</span>
<span class="nc" id="L570">                final byte[] encoded = secretKey.getEncoded();</span>
<span class="nc" id="L571">                return credentialType.cast(new BearerTokenCredential(new String(encoded, StandardCharsets.UTF_8)));</span>
            } else {
<span class="nc" id="L573">                throw log.invalidCredentialStoreEntryType(KeyStore.SecretKeyEntry.class, entry.getClass());</span>
            }
<span class="pc bpc" id="L575" title="1 of 2 branches missed.">        } else if (matchedCredentialType == PasswordCredential.class) {</span>
<span class="pc bpc" id="L576" title="1 of 2 branches missed.">            if (entry instanceof KeyStore.SecretKeyEntry) try {</span>
<span class="fc" id="L577">                final SecretKey secretKey = ((KeyStore.SecretKeyEntry) entry).getSecretKey();</span>
<span class="fc" id="L578">                final byte[] encoded = secretKey.getEncoded();</span>
<span class="fc" id="L579">                final String matchedAlgorithm = bottomEntry.getAlgorithm();</span>
<span class="pc bpc" id="L580" title="2 of 4 branches missed.">                assert matchedAlgorithm != null; // because it is an AlgorithmCredential</span>
<span class="fc" id="L581">                final DERDecoder decoder = new DERDecoder(encoded);</span>
                // we use algorithm-based encoding rather than a standard that encompasses all password types.
                final PasswordSpec passwordSpec;
<span class="pc bpc" id="L584" title="6 of 7 branches missed.">                switch (matchedAlgorithm) {</span>
                    case BCryptPassword.ALGORITHM_BCRYPT:
                    case BSDUnixDESCryptPassword.ALGORITHM_BSD_CRYPT_DES:
                    case ScramDigestPassword.ALGORITHM_SCRAM_SHA_1:
                    case ScramDigestPassword.ALGORITHM_SCRAM_SHA_256:
                    case ScramDigestPassword.ALGORITHM_SCRAM_SHA_384:
                    case ScramDigestPassword.ALGORITHM_SCRAM_SHA_512:
                    case SunUnixMD5CryptPassword.ALGORITHM_SUN_CRYPT_MD5:
                    case SunUnixMD5CryptPassword.ALGORITHM_SUN_CRYPT_MD5_BARE_SALT:
                    case UnixSHACryptPassword.ALGORITHM_CRYPT_SHA_256:
                    case UnixSHACryptPassword.ALGORITHM_CRYPT_SHA_512: {
<span class="nc" id="L595">                        decoder.startSequence();</span>
<span class="nc" id="L596">                        final byte[] hash = decoder.decodeOctetString();</span>
<span class="nc" id="L597">                        final byte[] salt = decoder.decodeOctetString();</span>
<span class="nc" id="L598">                        final int iterationCount = decoder.decodeInteger().intValue();</span>
<span class="nc" id="L599">                        decoder.endSequence();</span>
<span class="nc" id="L600">                        passwordSpec = new IteratedSaltedHashPasswordSpec(hash, salt, iterationCount);</span>
<span class="nc" id="L601">                        break;</span>
                    }
                    case ClearPassword.ALGORITHM_CLEAR: {
<span class="fc" id="L604">                        passwordSpec = new ClearPasswordSpec(decoder.decodeOctetStringAsString().toCharArray());</span>
<span class="fc" id="L605">                        break;</span>
                    }
                    case DigestPassword.ALGORITHM_DIGEST_MD5:
                    case DigestPassword.ALGORITHM_DIGEST_SHA:
                    case DigestPassword.ALGORITHM_DIGEST_SHA_256:
                    case DigestPassword.ALGORITHM_DIGEST_SHA_384:
                    case DigestPassword.ALGORITHM_DIGEST_SHA_512:
                    case DigestPassword.ALGORITHM_DIGEST_SHA_512_256: {
<span class="nc" id="L613">                        decoder.startSequence();</span>
<span class="nc" id="L614">                        final String username = decoder.decodeOctetStringAsString();</span>
<span class="nc" id="L615">                        final String realm = decoder.decodeOctetStringAsString();</span>
<span class="nc" id="L616">                        final byte[] digest = decoder.decodeOctetString();</span>
<span class="nc" id="L617">                        decoder.endSequence();</span>
<span class="nc" id="L618">                        passwordSpec = new DigestPasswordSpec(username, realm, digest);</span>
<span class="nc" id="L619">                        break;</span>
                    }
                    case OneTimePassword.ALGORITHM_OTP_MD5:
                    case OneTimePassword.ALGORITHM_OTP_SHA1:
                    case OneTimePassword.ALGORITHM_OTP_SHA_256:
                    case OneTimePassword.ALGORITHM_OTP_SHA_384:
                    case OneTimePassword.ALGORITHM_OTP_SHA_512: {
<span class="nc" id="L626">                        decoder.startSequence();</span>
<span class="nc" id="L627">                        final byte[] hash = decoder.decodeOctetString();</span>
<span class="nc" id="L628">                        final String seed = decoder.decodeIA5String();</span>
<span class="nc" id="L629">                        final int sequenceNumber = decoder.decodeInteger().intValue();</span>
<span class="nc" id="L630">                        decoder.endSequence();</span>
<span class="nc" id="L631">                        passwordSpec = new OneTimePasswordSpec(hash, seed, sequenceNumber);</span>
<span class="nc" id="L632">                        break;</span>
                    }
                    case SaltedSimpleDigestPassword.ALGORITHM_PASSWORD_SALT_DIGEST_MD5:
                    case SaltedSimpleDigestPassword.ALGORITHM_PASSWORD_SALT_DIGEST_SHA_1:
                    case SaltedSimpleDigestPassword.ALGORITHM_PASSWORD_SALT_DIGEST_SHA_256:
                    case SaltedSimpleDigestPassword.ALGORITHM_PASSWORD_SALT_DIGEST_SHA_384:
                    case SaltedSimpleDigestPassword.ALGORITHM_PASSWORD_SALT_DIGEST_SHA_512:
                    case SaltedSimpleDigestPassword.ALGORITHM_SALT_PASSWORD_DIGEST_MD5:
                    case SaltedSimpleDigestPassword.ALGORITHM_SALT_PASSWORD_DIGEST_SHA_1:
                    case SaltedSimpleDigestPassword.ALGORITHM_SALT_PASSWORD_DIGEST_SHA_256:
                    case SaltedSimpleDigestPassword.ALGORITHM_SALT_PASSWORD_DIGEST_SHA_384:
                    case SaltedSimpleDigestPassword.ALGORITHM_SALT_PASSWORD_DIGEST_SHA_512:
                    case UnixDESCryptPassword.ALGORITHM_CRYPT_DES:
                    case UnixMD5CryptPassword.ALGORITHM_CRYPT_MD5: {
<span class="nc" id="L646">                        decoder.startSequence();</span>
<span class="nc" id="L647">                        final byte[] hash = decoder.decodeOctetString();</span>
<span class="nc" id="L648">                        final byte[] salt = decoder.decodeOctetString();</span>
<span class="nc" id="L649">                        decoder.endSequence();</span>
<span class="nc" id="L650">                        passwordSpec = new SaltedHashPasswordSpec(hash, salt);</span>
<span class="nc" id="L651">                        break;</span>
                    }
                    case SimpleDigestPassword.ALGORITHM_SIMPLE_DIGEST_MD2:
                    case SimpleDigestPassword.ALGORITHM_SIMPLE_DIGEST_MD5:
                    case SimpleDigestPassword.ALGORITHM_SIMPLE_DIGEST_SHA_1:
                    case SimpleDigestPassword.ALGORITHM_SIMPLE_DIGEST_SHA_256:
                    case SimpleDigestPassword.ALGORITHM_SIMPLE_DIGEST_SHA_384:
                    case SimpleDigestPassword.ALGORITHM_SIMPLE_DIGEST_SHA_512: {
<span class="nc" id="L659">                        decoder.startSequence();</span>
<span class="nc" id="L660">                        final byte[] hash = decoder.decodeOctetString();</span>
<span class="nc" id="L661">                        decoder.endSequence();</span>
<span class="nc" id="L662">                        passwordSpec = new HashPasswordSpec(hash);</span>
<span class="nc" id="L663">                        break;</span>
                    }
                    default: {
<span class="nc bnc" id="L666" title="All 2 branches missed.">                        if (MaskedPassword.isMaskedAlgorithm(matchedAlgorithm)) {</span>
<span class="nc" id="L667">                            decoder.startSequence();</span>
<span class="nc" id="L668">                            final char[] initialKeyMaterial = decoder.decodeOctetStringAsString().toCharArray();</span>
<span class="nc" id="L669">                            final int iterationCount = decoder.decodeInteger().intValue();</span>
<span class="nc" id="L670">                            final byte[] salt = decoder.decodeOctetString();</span>
<span class="nc" id="L671">                            final byte[] maskedPasswordBytes = decoder.decodeOctetString();</span>
<span class="nc" id="L672">                            decoder.endSequence();</span>
<span class="nc" id="L673">                            passwordSpec = new MaskedPasswordSpec(initialKeyMaterial, iterationCount, salt, maskedPasswordBytes);</span>
<span class="nc" id="L674">                            break;</span>
                        } else {
<span class="nc" id="L676">                            throw log.unsupportedCredentialType(credentialType);</span>
                        }
                    }
                }
<span class="fc bfc" id="L680" title="All 2 branches covered.">                PasswordFactory passwordFactory = providers != null ? PasswordFactory.getInstance(matchedAlgorithm, () -&gt; providers) : PasswordFactory.getInstance(matchedAlgorithm);</span>
<span class="fc" id="L681">                final Password password = passwordFactory.generatePassword(passwordSpec);</span>
<span class="fc" id="L682">                return credentialType.cast(new PasswordCredential(password));</span>
<span class="nc" id="L683">            } catch (InvalidKeySpecException | NoSuchAlgorithmException e) {</span>
<span class="nc" id="L684">                throw log.cannotAcquireCredentialFromStore(e);</span>
            } else {
<span class="nc" id="L686">                throw log.invalidCredentialStoreEntryType(KeyStore.SecretKeyEntry.class, entry.getClass());</span>
            }
        } else {
<span class="nc" id="L689">            throw log.unableToReadCredentialTypeFromStore(matchedCredentialType);</span>
        }
    }

    private KeyStore.ProtectionParameter convertParameter(final CredentialStore.ProtectionParameter protectionParameter) throws CredentialStoreException {
        // only one conversion is really possible.
<span class="fc bfc" id="L695" title="All 2 branches covered.">        if (protectionParameter == null) {</span>
<span class="fc" id="L696">            return convertParameter(this.protectionParameter);</span>
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">        } else if (protectionParameter instanceof CredentialStore.CredentialSourceProtectionParameter) {</span>
<span class="fc" id="L698">            final CredentialSource credentialSource = ((CredentialStore.CredentialSourceProtectionParameter) protectionParameter).getCredentialSource();</span>
            try {
<span class="fc" id="L700">                return credentialSource.applyToCredential(PasswordCredential.class, c -&gt; c.getPassword().castAndApply(ClearPassword.class, p -&gt; new KeyStore.PasswordProtection(p.getPassword())));</span>
<span class="nc" id="L701">            } catch (IOException e) {</span>
<span class="nc" id="L702">                throw log.cannotAcquireCredentialFromStore(e);</span>
            }
        } else {
<span class="nc" id="L705">            throw log.invalidProtectionParameter(protectionParameter);</span>
        }
    }

    public void remove(final String credentialAlias, final Class&lt;? extends Credential&gt; credentialType, final String credentialAlgorithm, final AlgorithmParameterSpec parameterSpec) throws CredentialStoreException {
<span class="fc" id="L710">        String credentialAliasLowerCase = toLowercase(credentialAlias);</span>
<span class="fc" id="L711">        try (Hold hold = lockForWrite()) {</span>
<span class="pc bpc" id="L712" title="1 of 2 branches missed.">            if (! modifiable) {</span>
<span class="nc" id="L713">                throw log.nonModifiableCredentialStore(&quot;remove&quot;);</span>
            }
            // unlike retrieve or store, we want to remove *all* matches
<span class="fc" id="L716">            final TopEntry topEntry = cache.get(credentialAliasLowerCase);</span>
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">            if (topEntry == null) {</span>
<span class="nc" id="L718">                return;</span>
            }
<span class="pc bpc" id="L720" title="1 of 2 branches missed.">            if (topEntry.getMap().containsKey(credentialType)) {</span>
<span class="fc" id="L721">                remove(topEntry.getMap().remove(credentialType), credentialAlgorithm, parameterSpec);</span>
            } else {
                // loose (slow) match
<span class="nc" id="L724">                Iterator&lt;MidEntry&gt; iterator = topEntry.getMap().values().iterator();</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">                while (iterator.hasNext()) {</span>
<span class="nc" id="L726">                    final MidEntry item = iterator.next();</span>
<span class="nc bnc" id="L727" title="All 2 branches missed.">                    if (credentialType.isAssignableFrom(item.getCredentialType())) {</span>
<span class="nc" id="L728">                        remove(item, credentialAlgorithm, parameterSpec);</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">                        if (item.isEmpty()) iterator.remove();</span>
                    }
<span class="nc" id="L731">                }</span>
            }
<span class="fc bfc" id="L733" title="All 2 branches covered.">            if (topEntry.getMap().size() == 0) {</span>
<span class="fc" id="L734">                cache.remove(credentialAliasLowerCase);</span>
            }
            // done!
<span class="nc bnc" id="L737" title="All 2 branches missed.">        } catch (KeyStoreException e) {</span>
<span class="nc" id="L738">            throw log.cannotRemoveCredentialFromStore(e);</span>
<span class="fc" id="L739">        }</span>
<span class="fc" id="L740">    }</span>

    private void remove(final MidEntry midEntry, final String credentialAlgorithm, final AlgorithmParameterSpec parameterSpec) throws KeyStoreException {
<span class="pc bpc" id="L743" title="1 of 2 branches missed.">        if (midEntry != null) {</span>
<span class="pc bpc" id="L744" title="1 of 2 branches missed.">            if (credentialAlgorithm != null) {</span>
<span class="nc" id="L745">                remove(midEntry.getMap().get(credentialAlgorithm), parameterSpec);</span>
            } else {
                // match any
<span class="fc" id="L748">                Iterator&lt;BottomEntry&gt; iterator = midEntry.getMap().values().iterator();</span>
<span class="fc bfc" id="L749" title="All 2 branches covered.">                while (iterator.hasNext()) {</span>
<span class="fc" id="L750">                    final BottomEntry item = iterator.next();</span>
<span class="fc" id="L751">                    remove(item, parameterSpec);</span>
<span class="pc bpc" id="L752" title="1 of 2 branches missed.">                    if (item.isEmpty()) iterator.remove();</span>
<span class="fc" id="L753">                }</span>
<span class="fc" id="L754">                remove(midEntry.removeNoAlgorithm(), parameterSpec);</span>
            }
            // done!
        }
<span class="fc" id="L758">    }</span>

    private void remove(final BottomEntry bottomEntry, final AlgorithmParameterSpec parameterSpec) throws KeyStoreException {
<span class="fc bfc" id="L761" title="All 2 branches covered.">        if (bottomEntry != null) {</span>
<span class="pc bpc" id="L762" title="1 of 2 branches missed.">            if (parameterSpec != null) {</span>
<span class="nc" id="L763">                remove(bottomEntry.getMap().remove(new ParamKey(parameterSpec)));</span>
            } else {
                // match any
<span class="fc" id="L766">                Iterator&lt;String&gt; iterator = bottomEntry.getMap().values().iterator();</span>
<span class="pc bpc" id="L767" title="1 of 2 branches missed.">                while (iterator.hasNext()) {</span>
<span class="nc" id="L768">                    final String item = iterator.next();</span>
<span class="nc" id="L769">                    remove(item);</span>
<span class="nc" id="L770">                    iterator.remove();</span>
<span class="nc" id="L771">                }</span>
<span class="fc" id="L772">                remove(bottomEntry.removeNoParams());</span>
            }
        }
<span class="fc" id="L775">    }</span>

    private void remove(final String ksAlias) throws KeyStoreException {
<span class="pc bpc" id="L778" title="1 of 2 branches missed.">        if (ksAlias != null) {</span>
<span class="fc" id="L779">            keyStore.deleteEntry(ksAlias);</span>
        }
<span class="fc" id="L781">    }</span>

    public void flush() throws CredentialStoreException {
<span class="fc" id="L784">        try (Hold hold = lockForWrite()) {</span>
<span class="pc bpc" id="L785" title="1 of 2 branches missed.">            final Path dataLocation = externalPath == null ? location : externalPath;</span>
<span class="fc" id="L786">            log.tracef(&quot;KeyStoreCredentialStore: flushing into %s&quot;, dataLocation);</span>
<span class="pc bpc" id="L787" title="1 of 2 branches missed.">            if (dataLocation != null) try {</span>
<span class="fc" id="L788">                final char[] storePassword = getStorePassword(protectionParameter);</span>
<span class="fc" id="L789">                try (AtomicFileOutputStream os = new AtomicFileOutputStream(dataLocation)) {</span>
                    try {
<span class="pc bpc" id="L791" title="1 of 2 branches missed.">                        if (useExternalStorage) {</span>
<span class="nc" id="L792">                            externalStorage.store(os);</span>
                        } else {
<span class="fc" id="L794">                            keyStore.store(os, storePassword);</span>
                        }
<span class="nc" id="L796">                    } catch (Throwable t) {</span>
                        try {
<span class="nc" id="L798">                            os.cancel();</span>
<span class="nc" id="L799">                        } catch (IOException e) {</span>
<span class="nc" id="L800">                            e.addSuppressed(t);</span>
<span class="nc" id="L801">                            throw e;</span>
<span class="nc" id="L802">                        }</span>
<span class="fc" id="L803">                    }</span>
                }
<span class="nc" id="L805">            } catch (IOException e) {</span>
<span class="nc" id="L806">                throw log.cannotFlushCredentialStore(e);</span>
<span class="fc" id="L807">            }</span>
        }
<span class="fc" id="L809">    }</span>

    /**
     * Returns credential aliases stored in this store as {@code Set&lt;String&gt;}.
     * &lt;p&gt;
     * It is not mandatory to override this method (throws {@link UnsupportedOperationException} by default).
     *
     * @return {@code Set&lt;String&gt;} of all keys stored in this store
     * @throws UnsupportedOperationException when this method is not supported by the underlying credential store
     * @throws CredentialStoreException      if there is any problem with internal store
     */
    @Override
    public Set&lt;String&gt; getAliases() throws UnsupportedOperationException, CredentialStoreException {
<span class="fc" id="L822">        return cache.keySet();</span>
    }

    @Override
    public Set&lt;String&gt; getCredentialTypesForAlias(final String credentialAlias) {
<span class="nc" id="L827">        final TopEntry topEntry = cache.get(toLowercase(credentialAlias));</span>
<span class="nc bnc" id="L828" title="All 2 branches missed.">        if (topEntry != null) {</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">            if (!topEntry.getMap().isEmpty()) {</span>
<span class="nc" id="L830">                log.trace(&quot;KeyStoreCredentialStore: contains entries for given alias&quot;);</span>
<span class="nc" id="L831">                Set&lt;String&gt; types = new HashSet&lt;&gt;();</span>
<span class="nc" id="L832">                final Iterator&lt;MidEntry&gt; iterator = topEntry.getMap().values().iterator();</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">                while(iterator.hasNext()) {</span>
<span class="nc" id="L834">                    MidEntry item = iterator.next();</span>
<span class="nc" id="L835">                    types.add(item.getCredentialType().getSimpleName());</span>
<span class="nc" id="L836">                }</span>
<span class="nc" id="L837">                return types;</span>
            } else {
<span class="nc" id="L839">                log.trace(&quot;KeyStoreCredentialStore: no entry for given alias found&quot;);</span>
            }
        } else {
<span class="nc" id="L842">            log.trace(&quot;KeyStoreCredentialStore: alias not found in cache&quot;);</span>
        }
<span class="nc" id="L844">        return null;</span>
    }

    private Hold lockForRead() {
<span class="fc" id="L848">        readWriteLock.readLock().lock();</span>
<span class="fc" id="L849">        return () -&gt; readWriteLock.readLock().unlock();</span>
    }

    private Hold lockForWrite() {
<span class="fc" id="L853">        readWriteLock.writeLock().lock();</span>
<span class="fc" id="L854">        return () -&gt; readWriteLock.writeLock().unlock();</span>
    }

<span class="fc" id="L857">    private static final Pattern INDEX_PATTERN = Pattern.compile(&quot;(.+)/([a-z0-9_]+)/([-a-z0-9_]+)?/([2-7a-z]+)?$&quot;);</span>

    private void load(String type) throws CredentialStoreException {
        // lock held
        final Enumeration&lt;String&gt; enumeration;
        // load the KeyStore from file
        final Path dataLocation;
<span class="pc bpc" id="L864" title="1 of 2 branches missed.">        if (useExternalStorage) {</span>
<span class="nc" id="L865">            dataLocation = externalPath;</span>
<span class="nc" id="L866">            setupExternalStorage(type, location);</span>
        } else {
<span class="fc" id="L868">            dataLocation = location;</span>
<span class="fc" id="L869">            keyStore = getKeyStoreInstance(type);</span>
        }
<span class="fc bfc" id="L871" title="All 2 branches covered.">        if (create) {</span>
<span class="fc" id="L872">            log.tracef(&quot;KeyStoreCredentialStore: creating empty backing KeyStore  dataLocation = %s  external = %b&quot;, dataLocation, useExternalStorage);</span>
<span class="pc bpc" id="L873" title="1 of 2 branches missed.">            if (dataLocation == null) {</span>
                try {
<span class="nc" id="L875">                    keyStore.load(null, null);</span>
<span class="nc" id="L876">                } catch (CertificateException | IOException | NoSuchAlgorithmException e) {</span>
<span class="nc" id="L877">                    throw log.cannotInitializeCredentialStore(e);</span>
<span class="nc" id="L878">                }</span>
            }
        } else {
<span class="pc bpc" id="L881" title="2 of 4 branches missed.">            if (dataLocation != null &amp;&amp; !Files.exists(dataLocation)) {</span>
<span class="nc" id="L882">                throw log.automaticStorageCreationDisabled(dataLocation.toString());</span>
            }
        }

        try {
<span class="pc bpc" id="L887" title="1 of 4 branches missed.">            if (dataLocation != null &amp;&amp; Files.exists(dataLocation)) {</span>
<span class="fc" id="L888">                log.tracef(&quot;KeyStoreCredentialStore: loading backing KeyStore %s  external = %b&quot;, dataLocation, useExternalStorage);</span>
<span class="fc" id="L889">                char[] password = getStorePassword(protectionParameter);</span>
<span class="fc" id="L890">                try (InputStream fileStream = Files.newInputStream(dataLocation)) {</span>
<span class="pc bpc" id="L891" title="1 of 2 branches missed.">                    if (useExternalStorage) {</span>
<span class="nc" id="L892">                        externalStorage.load(fileStream);</span>
                    } else {
<span class="fc" id="L894">                        keyStore.load(fileStream, password);</span>
                    }
                }
<span class="fc" id="L897">                enumeration = keyStore.aliases();</span>
<span class="fc" id="L898">            } else {</span>
<span class="fc" id="L899">                keyStore.load(null, null);</span>
<span class="fc" id="L900">                enumeration = Collections.emptyEnumeration();</span>
            }
<span class="nc" id="L902">        } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L903">            throw log.cannotInitializeCredentialStore(</span>
<span class="nc bnc" id="L904" title="All 2 branches missed.">                    log.internalEncryptionProblem(e, dataLocation != null ? dataLocation.toString() : &quot;null&quot;));</span>
<span class="nc" id="L905">        } catch (IOException e) {</span>
<span class="nc" id="L906">            throw log.cannotInitializeCredentialStore(e);</span>
<span class="fc" id="L907">        }</span>

        Matcher matcher;
<span class="fc bfc" id="L910" title="All 2 branches covered.">        while (enumeration.hasMoreElements()) {</span>
<span class="fc" id="L911">            final String ksAlias = enumeration.nextElement().toLowerCase(Locale.ROOT);</span>
            try {
<span class="fc" id="L913">                matcher = INDEX_PATTERN.matcher(ksAlias);</span>
<span class="pc bpc" id="L914" title="1 of 2 branches missed.">                if (matcher.matches()) {</span>
<span class="fc" id="L915">                    final String alias = matcher.group(1); // required</span>
<span class="fc" id="L916">                    final String credTypeName = matcher.group(2); // required</span>
<span class="fc" id="L917">                    final String algName = matcher.group(3); // may be null if not given</span>
<span class="fc" id="L918">                    final String parameters = matcher.group(4); // null if not given</span>
<span class="fc" id="L919">                    final Class&lt;? extends Credential&gt; credentialType = CREDENTIAL_TYPES.get(credTypeName);</span>
<span class="pc bpc" id="L920" title="1 of 2 branches missed.">                    if (credentialType == null) {</span>
<span class="nc" id="L921">                        log.logIgnoredUnrecognizedKeyStoreEntry(ksAlias);</span>
<span class="pc bpc" id="L922" title="1 of 2 branches missed.">                    } else if (algName != null) {</span>
<span class="pc bpc" id="L923" title="1 of 2 branches missed.">                        if (parameters != null) {</span>
<span class="nc" id="L924">                            byte[] encodedParameters = CodePointIterator.ofString(parameters).base32Decode(Base32Alphabet.LOWERCASE, false).drain();</span>
<span class="nc" id="L925">                            final AlgorithmParameters algorithmParameters = AlgorithmParameters.getInstance(algName);</span>
<span class="nc" id="L926">                            algorithmParameters.init(encodedParameters);</span>
<span class="nc" id="L927">                            final AlgorithmParameterSpec parameterSpec = algorithmParameters.getParameterSpec(AlgorithmParameterSpec.class);</span>
<span class="nc" id="L928">                            final TopEntry topEntry = cache.computeIfAbsent(alias, TopEntry::new);</span>
<span class="nc" id="L929">                            final MidEntry midEntry = topEntry.getMap().computeIfAbsent(credentialType, k -&gt; new MidEntry(topEntry, k));</span>
<span class="nc" id="L930">                            final BottomEntry bottomEntry = midEntry.getMap().computeIfAbsent(algName, k -&gt; new BottomEntry(midEntry, k));</span>
<span class="nc" id="L931">                            bottomEntry.getMap().put(new ParamKey(parameterSpec), ksAlias);</span>
<span class="nc" id="L932">                        } else {</span>
                            // algorithm but no parameters
<span class="fc" id="L934">                            final TopEntry topEntry = cache.computeIfAbsent(alias, TopEntry::new);</span>
<span class="fc" id="L935">                            final MidEntry midEntry = topEntry.getMap().computeIfAbsent(credentialType, k -&gt; new MidEntry(topEntry, k));</span>
<span class="fc" id="L936">                            final BottomEntry bottomEntry = midEntry.getMap().computeIfAbsent(algName, k -&gt; new BottomEntry(midEntry, k));</span>
<span class="fc" id="L937">                            bottomEntry.setNoParams(ksAlias);</span>
<span class="fc" id="L938">                        }</span>
                    } else {
                        // no algorithm, no parameters
<span class="nc" id="L941">                        final TopEntry topEntry = cache.computeIfAbsent(alias, TopEntry::new);</span>
<span class="nc" id="L942">                        final MidEntry midEntry = topEntry.getMap().computeIfAbsent(credentialType, k -&gt; new MidEntry(topEntry, k));</span>
<span class="nc" id="L943">                        final BottomEntry bottomEntry = midEntry.getOrCreateNoAlgorithm();</span>
<span class="nc" id="L944">                        bottomEntry.setNoParams(ksAlias);</span>
                    }
<span class="fc" id="L946">                } else {</span>
<span class="nc" id="L947">                    log.logIgnoredUnrecognizedKeyStoreEntry(ksAlias);</span>
                }
<span class="nc" id="L949">            } catch (NoSuchAlgorithmException | InvalidParameterSpecException | IOException e) {</span>
<span class="nc" id="L950">                log.logFailedToReadKeyFromKeyStore(e);</span>
<span class="fc" id="L951">            }</span>
<span class="fc" id="L952">        }</span>
<span class="fc" id="L953">    }</span>

    private KeyStore getKeyStoreInstance(String type) throws CredentialStoreException {
<span class="fc bfc" id="L956" title="All 2 branches covered.">        if (providers != null) {</span>
<span class="pc bpc" id="L957" title="1 of 2 branches missed.">            if (log.isTraceEnabled()) {</span>
<span class="nc" id="L958">               log.tracef(&quot;Obtaining KeyStore instance of type %s, providers: %s&quot;, type, Arrays.toString(providers));</span>
            }
<span class="pc bpc" id="L960" title="1 of 2 branches missed.">            for (Provider p: providers) {</span>
                try {
<span class="fc" id="L962">                    KeyStore ks = KeyStore.getInstance(type, p);</span>
<span class="fc" id="L963">                    log.tracef(&quot;Obtained KeyStore instance: %s, provider: %s&quot;, ks, p.toString());</span>
<span class="fc" id="L964">                    return ks;</span>
<span class="fc" id="L965">                } catch (KeyStoreException e) {</span>
                    // no such keystore type in provider, ignore
                }
            }
        }
        try {
<span class="pc bpc" id="L971" title="1 of 2 branches missed.">            if (log.isTraceEnabled()) {</span>
<span class="nc" id="L972">                log.tracef(&quot;Obtaining KeyStore instance of type %s, providers: %s&quot;, type, Arrays.toString(Security.getProviders()));</span>
            }
<span class="fc" id="L974">            KeyStore ks = KeyStore.getInstance(type);</span>
<span class="fc" id="L975">            log.tracef(&quot;Obtained KeyStore instance: %s&quot;, ks);</span>
<span class="fc" id="L976">            return ks;</span>
<span class="nc" id="L977">        } catch (KeyStoreException e) {</span>
<span class="nc" id="L978">            throw log.cannotInitializeCredentialStore(e);</span>
        }
    }

    /**
     * Sets {@link #keyStore} to JCEKS type keyStore to be used as external storage.
     * Sets {@link #externalStorage} used to dump/load stored secret data.
     */
    private void setupExternalStorage(final String keyContainingKeyStoreType, final Path keyContainingKeyStoreLocation) throws CredentialStoreException {
<span class="nc" id="L987">        KeyStore keyContainingKeyStore = getKeyStoreInstance(keyContainingKeyStoreType);</span>
<span class="nc" id="L988">        keyStore = getKeyStoreInstance(&quot;JCEKS&quot;);</span>
<span class="nc" id="L989">        externalStorage = new ExternalStorage();</span>
        try {
<span class="nc" id="L991">            final char[] storePassword = getStorePassword(protectionParameter);</span>
<span class="nc bnc" id="L992" title="All 2 branches missed.">            if (keyContainingKeyStoreLocation != null) {</span>
<span class="nc" id="L993">                try (InputStream is = Files.newInputStream(keyContainingKeyStoreLocation)) {</span>
<span class="nc" id="L994">                    keyContainingKeyStore.load(is, storePassword);</span>
                }
            } else {
                // keystore without file (e.g. PKCS11)
<span class="nc" id="L998">                synchronized (EmptyProvider.getInstance()) {</span>
<span class="nc" id="L999">                    keyContainingKeyStore.load(null, storePassword);</span>
<span class="nc" id="L1000">                }</span>
            }
<span class="nc" id="L1002">            externalStorage.init(cryptographicAlgorithm, encryptionKeyAlias, keyContainingKeyStore, storePassword, keyStore);</span>
<span class="nc" id="L1003">        } catch(IOException | GeneralSecurityException e) {</span>
<span class="nc" id="L1004">            throw log.cannotInitializeCredentialStore(e);</span>
<span class="nc" id="L1005">        }</span>
<span class="nc" id="L1006">    }</span>


    private static final Map&lt;String, Class&lt;? extends Credential&gt;&gt; CREDENTIAL_TYPES;

    static {
<span class="fc" id="L1012">        Map&lt;String, Class&lt;? extends Credential&gt;&gt; map = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L1013" title="All 2 branches covered.">        for (Class&lt;? extends Credential&gt; type : Arrays.asList(</span>
            PasswordCredential.class,
            X509CertificateChainPublicCredential.class,
            X509CertificateChainPrivateCredential.class,
            KeyPairCredential.class,
            PublicKeyCredential.class,
            SecretKeyCredential.class,
            BearerTokenCredential.class
        )) {
<span class="fc" id="L1022">            map.put(type.getSimpleName().toLowerCase(Locale.ROOT), type);</span>
<span class="fc" id="L1023">        }</span>
<span class="fc" id="L1024">        CREDENTIAL_TYPES = map;</span>
<span class="fc" id="L1025">    }</span>

    private static char[] getStorePassword(final CredentialStore.ProtectionParameter protectionParameter) throws IOException, CredentialStoreException {
        final char[] password;
<span class="pc bpc" id="L1029" title="1 of 2 branches missed.">        if (protectionParameter instanceof CredentialStore.CredentialSourceProtectionParameter) {</span>
<span class="fc" id="L1030">            password = ((CredentialStore.CredentialSourceProtectionParameter) protectionParameter).getCredentialSource().applyToCredential(PasswordCredential.class, c -&gt; c.getPassword().castAndApply(ClearPassword.class, ClearPassword::getPassword));</span>
<span class="nc bnc" id="L1031" title="All 2 branches missed.">        } else if (protectionParameter != null) {</span>
<span class="nc" id="L1032">            throw log.invalidProtectionParameter(protectionParameter);</span>
        } else {
<span class="nc" id="L1034">            password = null;</span>
        }
<span class="fc" id="L1036">        return password;</span>
    }

    interface Hold extends AutoCloseable { void close(); }

    private String calculateNewAlias(String alias, Class&lt;? extends Credential&gt; credentialType, String algorithm, AlgorithmParameterSpec parameterSpec) throws CredentialStoreException {
<span class="fc" id="L1042">        final StringBuilder b = new StringBuilder(64 + alias.length());</span>
<span class="fc" id="L1043">        b.append(alias.toLowerCase(Locale.ROOT));</span>
<span class="fc" id="L1044">        b.append('/');</span>
<span class="fc" id="L1045">        b.append(credentialType.getSimpleName().toLowerCase(Locale.ROOT));</span>
<span class="fc" id="L1046">        b.append('/');</span>
<span class="pc bpc" id="L1047" title="1 of 2 branches missed.">        if (algorithm != null) {</span>
<span class="fc" id="L1048">            b.append(algorithm.toLowerCase(Locale.ROOT));</span>
<span class="fc" id="L1049">            b.append('/');</span>
<span class="pc bpc" id="L1050" title="1 of 2 branches missed.">            if (parameterSpec != null) try {</span>
<span class="nc" id="L1051">                final AlgorithmParameters algorithmParameters = AlgorithmParameters.getInstance(algorithm);</span>
<span class="nc" id="L1052">                algorithmParameters.init(parameterSpec);</span>
<span class="nc" id="L1053">                ByteIterator.ofBytes(algorithmParameters.getEncoded()).base32Encode(Base32Alphabet.LOWERCASE, false).drainTo(b);</span>
<span class="nc" id="L1054">            } catch (NoSuchAlgorithmException | InvalidParameterSpecException | IOException e) {</span>
<span class="nc" id="L1055">                throw log.cannotWriteCredentialToStore(e);</span>
<span class="nc" id="L1056">            }</span>
        } else {
<span class="nc" id="L1058">            b.append('/');</span>
        }
<span class="fc" id="L1060">        return b.toString();</span>
    }

    private static String toLowercase(String str) {
<span class="fc" id="L1064">        return str.toLowerCase(Locale.ROOT);</span>
    }

    static final class TopEntry {
        private final String alias;
<span class="fc" id="L1069">        private final HashMap&lt;Class&lt;? extends Credential&gt;, MidEntry&gt; map = new HashMap&lt;&gt;(0);</span>

<span class="fc" id="L1071">        TopEntry(final String alias) {</span>
<span class="fc" id="L1072">            this.alias = alias;</span>
<span class="fc" id="L1073">        }</span>

        String getAlias() {
<span class="nc" id="L1076">            return alias;</span>
        }

        HashMap&lt;Class&lt;? extends Credential&gt;, MidEntry&gt; getMap() {
<span class="fc" id="L1080">            return map;</span>
        }
    }

    static final class MidEntry {
        private final TopEntry topEntry;
        private final Class&lt;? extends Credential&gt; credentialType;
<span class="fc" id="L1087">        private final HashMap&lt;String, BottomEntry&gt; map = new HashMap&lt;&gt;(0);</span>
        private BottomEntry noAlgorithm;

<span class="fc" id="L1090">        MidEntry(final TopEntry topEntry, final Class&lt;? extends Credential&gt; credentialType) {</span>
<span class="fc" id="L1091">            this.topEntry = topEntry;</span>
<span class="fc" id="L1092">            this.credentialType = credentialType;</span>
<span class="fc" id="L1093">        }</span>

        Class&lt;? extends Credential&gt; getCredentialType() {
<span class="fc" id="L1096">            return credentialType;</span>
        }

        HashMap&lt;String, BottomEntry&gt; getMap() {
<span class="fc" id="L1100">            return map;</span>
        }

        BottomEntry getNoAlgorithm() {
<span class="nc" id="L1104">            return noAlgorithm;</span>
        }

        void setNoAlgorithm(final BottomEntry noAlgorithm) {
<span class="nc" id="L1108">            this.noAlgorithm = noAlgorithm;</span>
<span class="nc" id="L1109">        }</span>

        BottomEntry removeNoAlgorithm() {
            try {
<span class="fc" id="L1113">                return noAlgorithm;</span>
            } finally {
<span class="fc" id="L1115">                noAlgorithm = null;</span>
            }
        }

        boolean isEmpty() {
<span class="nc bnc" id="L1120" title="All 4 branches missed.">            return noAlgorithm == null &amp;&amp; map.isEmpty();</span>
        }

        private BottomEntry getOrCreateNoAlgorithm() {
<span class="nc" id="L1124">            final BottomEntry noAlgorithm = this.noAlgorithm;</span>
<span class="nc bnc" id="L1125" title="All 2 branches missed.">            return noAlgorithm != null ? noAlgorithm : (this.noAlgorithm = new BottomEntry(this, null));</span>
        }
    }

    static final class BottomEntry {
        private final MidEntry midEntry;
        private final String algorithm;
<span class="fc" id="L1132">        private final HashMap&lt;ParamKey, String&gt; map = new HashMap&lt;&gt;(0);</span>
        private String noParams;

<span class="fc" id="L1135">        BottomEntry(final MidEntry midEntry, final String algorithm) {</span>
<span class="fc" id="L1136">            this.midEntry = midEntry;</span>
<span class="fc" id="L1137">            this.algorithm = algorithm;</span>
<span class="fc" id="L1138">        }</span>

        String getAlgorithm() {
<span class="fc" id="L1141">            return algorithm;</span>
        }

        HashMap&lt;ParamKey, String&gt; getMap() {
<span class="fc" id="L1145">            return map;</span>
        }

        String getNoParams() {
<span class="fc" id="L1149">            return noParams;</span>
        }

        String setNoParams(final String noParams) {
            try {
<span class="fc" id="L1154">                return this.noParams;</span>
            } finally {
<span class="fc" id="L1156">                this.noParams = noParams;</span>
            }
        }

        boolean isEmpty() {
<span class="pc bpc" id="L1161" title="2 of 4 branches missed.">            return noParams == null &amp;&amp; map.isEmpty();</span>
        }

        private String removeNoParams() {
            try {
<span class="fc" id="L1166">                return noParams;</span>
            } finally {
<span class="fc" id="L1168">                noParams = null;</span>
            }
        }
    }

    static final class ParamKey {
        private final AlgorithmParameterSpec parameterSpec;
        private final int hashCode;

<span class="nc" id="L1177">        ParamKey(final AlgorithmParameterSpec parameterSpec) {</span>
<span class="nc" id="L1178">            this.parameterSpec = parameterSpec;</span>
<span class="nc" id="L1179">            this.hashCode = KeyUtil.parametersHashCode(parameterSpec);</span>
<span class="nc" id="L1180">        }</span>

        public int hashCode() {
<span class="nc" id="L1183">            return hashCode;</span>
        }

        AlgorithmParameterSpec getParameterSpec() {
<span class="nc" id="L1187">            return parameterSpec;</span>
        }

        int getHashCode() {
<span class="nc" id="L1191">            return hashCode;</span>
        }
    }

    private final class ExternalStorage {

        // version of external storage file, can be used later to enhance functionality and keep backward compatibility
<span class="nc" id="L1198">        private int VERSION = 1;</span>

<span class="nc" id="L1200">        private int SECRET_KEY_ENTRY_TYPE = 100;</span>

        private static final String DEFAULT_CRYPTOGRAPHIC_ALGORITHM = &quot;AES/CBC/NoPadding&quot;;

        private Cipher encrypt;
        private Cipher decrypt;

        private KeyStore dataKeyStore;
        private KeyStore storageSecretKeyStore;
        private SecretKey storageSecretKey;

<span class="nc" id="L1211">        private ExternalStorage() {}</span>

        void init(String cryptographicAlgorithm, String keyAlias, KeyStore keyStore, char[] keyPassword, KeyStore dataKeyStore) throws CredentialStoreException {

<span class="nc bnc" id="L1215" title="All 2 branches missed.">            if (cryptographicAlgorithm == null)</span>
<span class="nc" id="L1216">                cryptographicAlgorithm = DEFAULT_CRYPTOGRAPHIC_ALGORITHM;</span>

<span class="nc" id="L1218">            storageSecretKeyStore = keyStore;</span>
<span class="nc" id="L1219">            this.dataKeyStore = dataKeyStore;</span>

            try {
<span class="nc" id="L1222">                fetchStorageSecretKey(keyAlias, keyPassword);</span>
<span class="nc" id="L1223">                Provider provider = keyStore.getProvider();</span>
                try {
<span class="nc" id="L1225">                    encrypt = Cipher.getInstance(cryptographicAlgorithm, provider);</span>
<span class="nc" id="L1226">                } catch (NoSuchAlgorithmException e) {</span>
                    // fallback to any provider of desired algorithm
<span class="nc" id="L1228">                    encrypt = Cipher.getInstance(cryptographicAlgorithm);</span>
<span class="nc" id="L1229">                }</span>
                try {
<span class="nc" id="L1231">                    decrypt = Cipher.getInstance(cryptographicAlgorithm, provider);</span>
<span class="nc" id="L1232">                } catch (NoSuchAlgorithmException e) {</span>
                    // fallback to any provider of desired algorithm
<span class="nc" id="L1234">                    decrypt = Cipher.getInstance(cryptographicAlgorithm);</span>
<span class="nc" id="L1235">                }</span>
<span class="nc" id="L1236">            } catch (NoSuchAlgorithmException | NoSuchPaddingException | UnrecoverableEntryException |</span>
                    KeyStoreException | IOException | CertificateException e) {
<span class="nc" id="L1238">                throw new CredentialStoreException(e);</span>
<span class="nc" id="L1239">            }</span>
<span class="nc" id="L1240">        }</span>

        private void fetchStorageSecretKey(String keyAlias, char[] keyPassword) throws CertificateException, NoSuchAlgorithmException, IOException, CredentialStoreException, UnrecoverableEntryException, KeyStoreException {
<span class="nc" id="L1243">            KeyStore.Entry entry = storageSecretKeyStore.getEntry(keyAlias, new KeyStore.PasswordProtection(keyPassword));</span>
<span class="nc bnc" id="L1244" title="All 2 branches missed.">            if (entry == null) {</span>
<span class="nc" id="L1245">                throw log.externalStorageKeyDoesNotExist(keyAlias);</span>
            }
<span class="nc bnc" id="L1247" title="All 2 branches missed.">            if (! (entry instanceof KeyStore.SecretKeyEntry)) {</span>
<span class="nc" id="L1248">                throw log.wrongTypeOfExternalStorageKey(keyAlias);</span>
            }
<span class="nc" id="L1250">            storageSecretKey = ((KeyStore.SecretKeyEntry) entry).getSecretKey();</span>
<span class="nc" id="L1251">        }</span>

        /**
         * Load {@link #dataKeyStore} with data from the input stream.
         *
         * @param inputStream to load data from
         * @throws IOException if something goes wrong
         */
        void load(InputStream inputStream) throws IOException, GeneralSecurityException {
<span class="nc" id="L1260">            dataKeyStore.load(null, null);</span>
<span class="nc" id="L1261">            ObjectInputStream ois = new ObjectInputStream(inputStream);</span>
<span class="nc" id="L1262">            int fileVersion = ois.readInt();</span>
<span class="nc bnc" id="L1263" title="All 2 branches missed.">            if (fileVersion == VERSION) {</span>
<span class="nc bnc" id="L1264" title="All 2 branches missed.">                while (ois.available() &gt; 0) {</span>
<span class="nc" id="L1265">                    int entryType = ois.readInt();</span>
<span class="nc bnc" id="L1266" title="All 2 branches missed.">                    if (entryType == SECRET_KEY_ENTRY_TYPE) {</span>
<span class="nc" id="L1267">                        loadSecretKey(ois);</span>
                    } else {
<span class="nc" id="L1269">                        throw log.unrecognizedEntryType(Integer.toString(entryType));</span>
                    }
<span class="nc" id="L1271">                }</span>
            } else {
<span class="nc" id="L1273">                throw log.unexpectedFileVersion(Integer.toString(fileVersion));</span>
            }
<span class="nc" id="L1275">            ois.close();</span>
<span class="nc" id="L1276">        }</span>

        private void loadSecretKey(ObjectInputStream ois) throws IOException, GeneralSecurityException {
<span class="nc" id="L1279">            byte[] encryptedData = readBytes(ois);</span>
<span class="nc" id="L1280">            byte[] iv = readBytes(ois);</span>

<span class="nc" id="L1282">            decrypt.init(Cipher.DECRYPT_MODE, storageSecretKey, new IvParameterSpec(iv));</span>
<span class="nc" id="L1283">            Assert.checkMaximumParameter(&quot;cipher block size&quot;, 256, decrypt.getBlockSize());</span>
<span class="nc" id="L1284">            byte[] unPadded = pkcs7UnPad(decrypt.doFinal(encryptedData));</span>
<span class="nc" id="L1285">            ObjectInputStream entryOis = new ObjectInputStream(new ByteArrayInputStream(unPadded));</span>
<span class="nc" id="L1286">            String ksAlias = entryOis.readUTF();</span>
<span class="nc" id="L1287">            byte[] encodedSecretKey = readBytes(entryOis);</span>
<span class="nc" id="L1288">            KeyStore.Entry entry = new KeyStore.SecretKeyEntry(new SecretKeySpec(encodedSecretKey, DATA_OID));</span>
<span class="nc" id="L1289">            dataKeyStore.setEntry(ksAlias, entry, convertParameter(protectionParameter));</span>
<span class="nc" id="L1290">        }</span>

        private byte[] readBytes(ObjectInputStream ois) throws IOException {
<span class="nc" id="L1293">            int len = ois.readInt();</span>
<span class="nc" id="L1294">            byte[] data = new byte[len];</span>
<span class="nc" id="L1295">            int actualLen = ois.read(data, 0, len);</span>
<span class="nc bnc" id="L1296" title="All 2 branches missed.">            if (len != actualLen) throw log.readBytesMismatch(actualLen, len);</span>
<span class="nc" id="L1297">            return data;</span>
        }

        private int writeBytes(byte[] data, ObjectOutputStream oos) throws IOException {
<span class="nc" id="L1301">            int len = data.length;</span>
<span class="nc" id="L1302">            oos.writeInt(len);</span>
<span class="nc" id="L1303">            oos.write(data, 0, len);</span>
<span class="nc" id="L1304">            return len;</span>
        }

        /**
         * Store data from {@link #dataKeyStore} to output stream.
         *
         * @param outputStream to store data to
         * @throws IOException if something goes wrong
         */
        void store(OutputStream outputStream) throws IOException, GeneralSecurityException {
<span class="nc" id="L1314">            ObjectOutputStream oos = new ObjectOutputStream(outputStream);</span>
<span class="nc" id="L1315">            oos.writeInt(VERSION);</span>
<span class="nc" id="L1316">            Enumeration&lt;String&gt; ksAliases = dataKeyStore.aliases();</span>
<span class="nc bnc" id="L1317" title="All 2 branches missed.">            while(ksAliases.hasMoreElements()) {</span>
<span class="nc" id="L1318">                String alias = ksAliases.nextElement();</span>
<span class="nc" id="L1319">                KeyStore.Entry entry = dataKeyStore.getEntry(alias, convertParameter(protectionParameter));</span>
<span class="nc bnc" id="L1320" title="All 2 branches missed.">                if (entry instanceof KeyStore.SecretKeyEntry) {</span>
<span class="nc" id="L1321">                    saveSecretKey(alias, oos, (KeyStore.SecretKeyEntry)entry);</span>
                } else {
<span class="nc bnc" id="L1323" title="All 2 branches missed.">                    throw log.unrecognizedEntryType(entry != null ? entry.getClass().getCanonicalName() : &quot;null&quot;);</span>
                }
<span class="nc" id="L1325">            }</span>
<span class="nc" id="L1326">            oos.flush();</span>
<span class="nc" id="L1327">            oos.close();</span>
<span class="nc" id="L1328">        }</span>

        private void saveSecretKey(String ksAlias, ObjectOutputStream oos, KeyStore.SecretKeyEntry entry) throws IOException, GeneralSecurityException {
<span class="nc" id="L1331">            ByteArrayOutputStream entryData = new ByteArrayOutputStream(1024);</span>
<span class="nc" id="L1332">            ObjectOutputStream entryOos = new ObjectOutputStream(entryData);</span>
<span class="nc" id="L1333">            entryOos.writeUTF(ksAlias);</span>
<span class="nc" id="L1334">            writeBytes(entry.getSecretKey().getEncoded(), entryOos);</span>
<span class="nc" id="L1335">            entryOos.flush();</span>

<span class="nc" id="L1337">            encrypt.init(Cipher.ENCRYPT_MODE, storageSecretKey, (AlgorithmParameterSpec) null); // ELY-1308: third param need to workaround BouncyCastle bug</span>
<span class="nc" id="L1338">            int blockSize = encrypt.getBlockSize();</span>
<span class="nc bnc" id="L1339" title="All 2 branches missed.">            if (blockSize == 0) throw log.algorithmNotBlockBased(encrypt.getAlgorithm());</span>
<span class="nc" id="L1340">            Assert.checkMaximumParameter(&quot;cipher block size&quot;, 256, blockSize);</span>
<span class="nc" id="L1341">            byte[] padded = pkcs7Pad(entryData.toByteArray(), blockSize);</span>

<span class="nc" id="L1343">            byte[] encrypted = encrypt.doFinal(padded);</span>
<span class="nc" id="L1344">            byte[] iv = encrypt.getIV();</span>
<span class="nc bnc" id="L1345" title="All 2 branches missed.">            if (iv == null) throw log.algorithmNotIV(encrypt.getAlgorithm());</span>

<span class="nc" id="L1347">            oos.writeInt(SECRET_KEY_ENTRY_TYPE);</span>
<span class="nc" id="L1348">            writeBytes(encrypted, oos);</span>
<span class="nc" id="L1349">            writeBytes(iv, oos);</span>
<span class="nc" id="L1350">        }</span>

        private byte[] pkcs7Pad(byte[] buffer, int blockSize) {
<span class="nc" id="L1353">            int len = buffer.length;</span>
<span class="nc" id="L1354">            int toFill = blockSize - (len % blockSize);</span>
<span class="nc" id="L1355">            byte[] padded = Arrays.copyOf(buffer, toFill + len);</span>
<span class="nc" id="L1356">            Arrays.fill(padded, len, padded.length, (byte) toFill);</span>
<span class="nc" id="L1357">            return padded;</span>
        }

        private byte[] pkcs7UnPad(byte[] buffer) throws BadPaddingException {
<span class="nc" id="L1361">            byte last = buffer[buffer.length - 1];</span>
<span class="nc" id="L1362">            int i = buffer.length - 2;</span>
<span class="nc bnc" id="L1363" title="All 2 branches missed.">            while (buffer[i] == last) {</span>
<span class="nc" id="L1364">                i--;</span>
            }
<span class="nc bnc" id="L1366" title="All 2 branches missed.">            if (i + 1 + last != buffer.length) {</span>
<span class="nc" id="L1367">                throw new BadPaddingException();</span>
            }
<span class="nc" id="L1369">            return Arrays.copyOfRange(buffer, 0, i + 1);</span>
        }

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>