<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>BSDUnixDESCryptPasswordImpl.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">WildFly Elytron</a> &gt; <a href="../index.html" class="el_bundle">wildfly-elytron-password-impl</a> &gt; <a href="index.source.html" class="el_package">org.wildfly.security.password.impl</a> &gt; <span class="el_source">BSDUnixDESCryptPasswordImpl.java</span></div><h1>BSDUnixDESCryptPasswordImpl.java</h1><pre class="source lang-java linenums">/*
 * JBoss, Home of Professional Open Source.
 * Copyright 2014 Red Hat, Inc., and individual contributors
 * as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.wildfly.security.password.impl;

import static org.wildfly.common.math.HashMath.multiHashOrdered;
import static org.wildfly.security.password.impl.ElytronMessages.log;

import java.io.NotSerializableException;
import java.io.ObjectInputStream;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.security.InvalidKeyException;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.InvalidParameterSpecException;
import java.security.spec.KeySpec;
import java.util.Arrays;
import java.util.concurrent.ThreadLocalRandom;

import org.wildfly.security.password.interfaces.BSDUnixDESCryptPassword;
import org.wildfly.security.password.spec.ClearPasswordSpec;
import org.wildfly.security.password.spec.IteratedPasswordAlgorithmSpec;
import org.wildfly.security.password.spec.IteratedSaltedPasswordAlgorithmSpec;
import org.wildfly.security.password.spec.IteratedSaltedHashPasswordSpec;
import org.wildfly.security.password.spec.SaltedHashPasswordSpec;
import org.wildfly.security.password.spec.SaltedPasswordAlgorithmSpec;

/**
 * Implementation of the BSD variant of the Unix DES Crypt password.
 *
 * @author &lt;a href=&quot;mailto:fjuma@redhat.com&quot;&gt;Farah Juma&lt;/a&gt;
 */
class BSDUnixDESCryptPasswordImpl extends AbstractPasswordImpl implements BSDUnixDESCryptPassword {

    private static final long serialVersionUID = 4537505177089490619L;
    private final int iterationCount;
    private final int salt;
    private final byte[] hash;

<span class="fc" id="L55">    BSDUnixDESCryptPasswordImpl(int salt, int iterationCount, byte[] hash) throws InvalidKeySpecException {</span>
<span class="fc" id="L56">        this.salt = salt;</span>
<span class="fc" id="L57">        this.iterationCount = iterationCount;</span>

<span class="pc bpc" id="L59" title="1 of 4 branches missed.">        if (hash == null || hash.length != BSDUnixDESCryptPassword.BSD_CRYPT_DES_HASH_SIZE) {</span>
<span class="fc" id="L60">            throw log.invalidKeySpecBsdDesCryptPasswordHashMustBeBytes(BSDUnixDESCryptPassword.BSD_CRYPT_DES_HASH_SIZE);</span>
        }

<span class="fc" id="L63">        this.hash = hash.clone();</span>
<span class="fc" id="L64">    }</span>

    BSDUnixDESCryptPasswordImpl(final IteratedSaltedHashPasswordSpec passwordSpec) throws InvalidKeySpecException, InvalidParameterSpecException {
<span class="nc" id="L67">        this(getSaltValue(passwordSpec.getSalt()), passwordSpec.getIterationCount(), passwordSpec.getHash());</span>
<span class="nc" id="L68">    }</span>

    BSDUnixDESCryptPasswordImpl(final SaltedHashPasswordSpec passwordSpec) throws InvalidKeySpecException, InvalidParameterSpecException {
<span class="nc" id="L71">        this(getSaltValue(passwordSpec.getSalt()), DEFAULT_ITERATION_COUNT, passwordSpec.getHash());</span>
<span class="nc" id="L72">    }</span>

    BSDUnixDESCryptPasswordImpl(final ClearPasswordSpec passwordSpec) throws InvalidKeySpecException {
<span class="nc" id="L75">        this(passwordSpec.getEncodedPassword(), ThreadLocalRandom.current().nextInt() &amp; 0xffffff, DEFAULT_ITERATION_COUNT);</span>
<span class="nc" id="L76">    }</span>

    BSDUnixDESCryptPasswordImpl(final char[] password, final Charset hashCharset) throws InvalidKeySpecException, InvalidParameterSpecException {
<span class="nc" id="L79">        this(password, ThreadLocalRandom.current().nextInt() &amp; 0xffffff, DEFAULT_ITERATION_COUNT, hashCharset);</span>
<span class="nc" id="L80">    }</span>

    BSDUnixDESCryptPasswordImpl(final char[] password, final IteratedSaltedPasswordAlgorithmSpec spec, final Charset hashCharset) throws InvalidKeySpecException, InvalidParameterSpecException {
<span class="fc" id="L83">        this(password, getSaltValue(spec.getSalt()), spec.getIterationCount(), hashCharset);</span>
<span class="fc" id="L84">    }</span>

    BSDUnixDESCryptPasswordImpl(final char[] password, final IteratedPasswordAlgorithmSpec spec, final Charset hashCharset) throws InvalidKeySpecException, InvalidParameterSpecException {
<span class="nc" id="L87">        this(password, ThreadLocalRandom.current().nextInt() &amp; 0xffffff, spec.getIterationCount(), hashCharset);</span>
<span class="nc" id="L88">    }</span>

    BSDUnixDESCryptPasswordImpl(final char[] password, final SaltedPasswordAlgorithmSpec spec, final Charset hashCharset) throws InvalidKeySpecException, InvalidParameterSpecException {
<span class="nc" id="L91">        this(password, getSaltValue(spec.getSalt()), DEFAULT_ITERATION_COUNT, hashCharset);</span>
<span class="nc" id="L92">    }</span>

    BSDUnixDESCryptPasswordImpl(final char[] password, final int salt, final int iterationCount) throws InvalidKeySpecException {
<span class="nc" id="L95">        this(salt, iterationCount, generateHash(salt, iterationCount, password));</span>
<span class="nc" id="L96">    }</span>

    BSDUnixDESCryptPasswordImpl(final char[] password, final int salt, final int iterationCount, final Charset hashCharset) throws InvalidKeySpecException {
<span class="fc" id="L99">        this(salt, iterationCount, generateHash(salt, iterationCount, password, hashCharset));</span>
<span class="fc" id="L100">    }</span>

<span class="fc" id="L102">    BSDUnixDESCryptPasswordImpl(final BSDUnixDESCryptPassword password) throws InvalidKeyException {</span>
<span class="fc" id="L103">        this.salt = password.getSalt();</span>
<span class="fc" id="L104">        this.iterationCount = password.getIterationCount();</span>
<span class="fc" id="L105">        final byte[] hash = password.getHash();</span>
<span class="pc bpc" id="L106" title="2 of 4 branches missed.">        if (hash == null || hash.length != BSDUnixDESCryptPassword.BSD_CRYPT_DES_HASH_SIZE) {</span>
<span class="nc" id="L107">            throw log.invalidKeyBsdDesCryptPasswordHashMustBeBytes(BSDUnixDESCryptPassword.BSD_CRYPT_DES_HASH_SIZE);</span>
        }
<span class="fc" id="L109">        this.hash = hash.clone();</span>
<span class="fc" id="L110">    }</span>

    private static int getSaltValue(final byte[] saltBytes) throws InvalidParameterSpecException {
<span class="pc bpc" id="L113" title="1 of 4 branches missed.">        if (saltBytes == null || saltBytes.length != BSDUnixDESCryptPassword.BSD_CRYPT_DES_SALT_SIZE) {</span>
<span class="fc" id="L114">            throw log.invalidParameterSpecSaltMustBeBytes(BSDUnixDESCryptPassword.BSD_CRYPT_DES_SALT_SIZE);</span>
        }
<span class="fc" id="L116">        return (saltBytes[0] &amp; 0xff) &lt;&lt; 16 | (saltBytes[1] &amp; 0xff) &lt;&lt; 8 | saltBytes[2] &amp; 0xff;</span>
    }

    private static byte[] getSaltBytes(final int saltVal) {
<span class="nc" id="L120">        final byte[] bytes = new byte[3];</span>
<span class="nc" id="L121">        bytes[0] = (byte) (saltVal &gt;&gt;&gt; 16);</span>
<span class="nc" id="L122">        bytes[1] = (byte) (saltVal &gt;&gt;&gt; 8);</span>
<span class="nc" id="L123">        bytes[2] = (byte) saltVal;</span>
<span class="nc" id="L124">        return bytes;</span>
    }

    &lt;S extends KeySpec&gt; S getKeySpec(final Class&lt;S&gt; keySpecType) throws InvalidKeySpecException {
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">        if (keySpecType.isAssignableFrom(IteratedSaltedHashPasswordSpec.class)) {</span>
<span class="nc" id="L129">            return keySpecType.cast(new IteratedSaltedHashPasswordSpec(hash.clone(), getSaltBytes(salt), iterationCount));</span>
        }
<span class="fc" id="L131">        throw new InvalidKeySpecException();</span>
    }

    boolean verify(final char[] guess) throws InvalidKeyException {
<span class="fc" id="L135">        return verify(guess, StandardCharsets.UTF_8);</span>
    }

    @Override
    boolean verify(char[] guess, Charset hashCharset) throws InvalidKeyException {
<span class="fc" id="L140">        return Arrays.equals(hash, generateHash(salt, iterationCount, guess, hashCharset));</span>
    }

    &lt;T extends KeySpec&gt; boolean convertibleTo(final Class&lt;T&gt; keySpecType) {
<span class="fc" id="L144">        return keySpecType.isAssignableFrom(IteratedSaltedHashPasswordSpec.class);</span>
    }

    public String getAlgorithm() {
<span class="fc" id="L148">        return BSDUnixDESCryptPassword.ALGORITHM_BSD_CRYPT_DES;</span>
    }

    @Override
    public int getIterationCount() {
<span class="fc" id="L153">        return iterationCount;</span>
    }

    public int getSalt() {
<span class="fc" id="L157">        return salt;</span>
    }

    public byte[] getHash() {
<span class="fc" id="L161">        return hash.clone();</span>
    }

    private static byte[] generateHash(final int salt, int iterationCount, final char[] password) {
<span class="nc" id="L165">        final byte[] bytes1 = getNormalizedPasswordBytes(password);</span>
<span class="nc" id="L166">        return crypt(bytes1, salt, iterationCount);</span>
    }

    private static byte[] generateHash(final int salt, int iterationCount, final char[] password, final Charset hashCharset) {
<span class="fc" id="L170">        final byte[] bytes1 = getNormalizedPasswordBytes(password, hashCharset);</span>
<span class="fc" id="L171">        return crypt(bytes1, salt, iterationCount);</span>
    }

    // Note that the following DES tables and some of the methods below are based on
    // tables and methods from the C implementation of the algorithm that's used by
    // FreeBSD, NetBSD, and OpenBSD:
    // http://svnweb.freebsd.org/base/head/secure/lib/libcrypt/crypt-des.c?view=markup

<span class="fc" id="L179">    private static boolean tablesInitialized = false;</span>

<span class="fc" id="L181">    private static final byte[] IP = {</span>
        58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4,
        62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8,
        57, 49, 41, 33, 25, 17,  9, 1, 59, 51, 43, 35, 27, 19, 11, 3,
        61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7,
    };
<span class="fc" id="L187">    private static final int[][] ipMaskLeft = new int[8][256];</span>
<span class="fc" id="L188">    private static final int[][] ipMaskRight = new int[8][256];</span>
<span class="fc" id="L189">    private static final int[][] fpMaskLeft = new int[8][256];</span>
<span class="fc" id="L190">    private static final int[][] fpMaskRight = new int[8][256];</span>
<span class="fc" id="L191">    private static final int[] initPerm = new int[64];</span>
<span class="fc" id="L192">    private static final int[] finalPerm = new int[64];</span>

<span class="fc" id="L194">    private static final byte[] keyShifts = {1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1};</span>

<span class="fc" id="L196">    private static final byte[] keyPerm = {</span>
        57, 49, 41, 33, 25, 17,  9,  1, 58, 50, 42, 34, 26, 18,
        10,  2, 59, 51, 43, 35, 27, 19, 11,  3, 60, 52, 44, 36,
        63, 55, 47, 39, 31, 23, 15,  7, 62, 54, 46, 38, 30, 22,
        14,  6, 61, 53, 45, 37, 29, 21, 13,  5, 28, 20, 12,  4
    };
<span class="fc" id="L202">    private static final int[] invKeyPerm = new int[64];</span>
<span class="fc" id="L203">    private static final int[][] keyPermMaskLeft = new int[8][128];</span>
<span class="fc" id="L204">    private static final int[][] keyPermMaskRight = new int[8][128];</span>

<span class="fc" id="L206">    private static final byte[] compPerm = {</span>
        14, 17, 11, 24,  1,  5,  3, 28, 15,  6, 21, 10,
        23, 19, 12,  4, 26,  8, 16,  7, 27, 20, 13,  2,
        41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48,
        44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32
    };
<span class="fc" id="L212">    private static final int[] invCompPerm = new int[56];</span>
<span class="fc" id="L213">    private static final int[][] compPermMaskLeft = new int[8][128];</span>
<span class="fc" id="L214">    private static final int[][] compPermMaskRight = new int[8][128];</span>

<span class="fc" id="L216">    private static final byte[][] SBox = {</span>
        {
            14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7,
             0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8,
             4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0,
            15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13
        },
        {
            15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10,
             3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5,
             0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15,
            13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9
        },
        {
            10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8,
            13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1,
            13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7,
             1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12
        },
        {
             7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15,
            13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9,
            10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4,
             3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14
        },
        {
             2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9,
            14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6,
             4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14,
            11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3
        },
        {
            12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11,
            10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8,
             9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6,
             4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13
        },
        {
             4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1,
            13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6,
             1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2,
             6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12
        },
        {
            13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7,
             1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2,
             7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8,
             2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11
        }
    };
<span class="fc" id="L266">    private static final int[][] mSBox = new int[4][4096];</span>
<span class="fc" id="L267">    private static final byte[][] invSBox = new byte[8][64];</span>

<span class="fc" id="L269">    private static final byte[] PBox = {</span>
        16,  7, 20, 21, 29, 12, 28, 17,  1, 15, 23, 26,  5, 18, 31, 10,
         2,  8, 24, 14, 32, 27,  3,  9, 19, 13, 30,  6, 22, 11,  4, 25
    };
<span class="fc" id="L273">    private static final byte[] invPBox = new byte[32];</span>

<span class="fc" id="L275">    private static final int[][] PSBox = new int[4][256];</span>

<span class="fc" id="L277">    private static final int[] bits32 = {</span>
        0x80000000, 0x40000000, 0x20000000, 0x10000000, 0x08000000, 0x04000000, 0x02000000, 0x01000000,
        0x00800000, 0x00400000, 0x00200000, 0x00100000, 0x00080000, 0x00040000, 0x00020000, 0x00010000,
        0x00008000, 0x00004000, 0x00002000, 0x00001000, 0x00000800, 0x00000400, 0x00000200, 0x00000100,
        0x00000080, 0x00000040, 0x00000020, 0x00000010, 0x00000008, 0x00000004, 0x00000002, 0x00000001
    };

    /**
     * Initializes the DES tables.
     */
    private static void setupTables() {
        int inBit, outBit;
<span class="fc" id="L289">        int bits28Offset = 4;</span>
<span class="fc" id="L290">        int bits24Offset = 8;</span>
<span class="fc" id="L291">        int bits8Offset = 24;</span>

        // Invert the S-boxes and then convert them into 4 arrays
        int b;
<span class="fc bfc" id="L295" title="All 2 branches covered.">        for (int i = 0; i &lt; 8; i++) {</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">            for (int j = 0; j &lt; 64; j++) {</span>
<span class="fc" id="L297">                b = (j &amp; 0x20) | ((j &amp; 1) &lt;&lt; 4) | ((j &gt;&gt;&gt; 1) &amp; 0xf);</span>
<span class="fc" id="L298">                invSBox[i][j] = SBox[i][b];</span>
            }
        }

<span class="fc bfc" id="L302" title="All 2 branches covered.">        for (int i = 0; i &lt; 4; i++) {</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">            for (int j = 0; j &lt; 64; j++) {</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">                for (int k = 0; k &lt; 64; k++) {</span>
<span class="fc" id="L305">                    mSBox[i][(j &lt;&lt; 6) | k] = ((invSBox[(i &lt;&lt; 1)][j] &lt;&lt; 4) | invSBox[(i &lt;&lt; 1) + 1][k]) &amp; 0xff;</span>
                }
            }
        }

        // Compute the initial and final permutations and also initialize the inverted key permutation
<span class="fc bfc" id="L311" title="All 2 branches covered.">        for (int i = 0; i &lt; 64; i++) {</span>
<span class="fc" id="L312">            finalPerm[i] = (IP[i] - 1) &amp; 0xff;</span>
<span class="fc" id="L313">            initPerm[finalPerm[i]] = i;</span>
<span class="fc" id="L314">            invKeyPerm[i] = 255;</span>
        }

        // Invert the key permutation and initialize the inverted key compression permutation
<span class="fc bfc" id="L318" title="All 2 branches covered.">        for (int i = 0; i &lt; 56; i++) {</span>
<span class="fc" id="L319">            invKeyPerm[(keyPerm[i] - 1) &amp; 0xff] = i;</span>
<span class="fc" id="L320">            invCompPerm[i] = 255;</span>
        }

        // Invert the key compression permutation
<span class="fc bfc" id="L324" title="All 2 branches covered.">        for (int i = 0; i &lt; 48; i++) {</span>
<span class="fc" id="L325">            invCompPerm[(compPerm[i] - 1) &amp; 0xff] = i;</span>
        }

        // Set up mask arrays
<span class="fc bfc" id="L329" title="All 2 branches covered.">        for (int i = 0; i &lt; 8; i++) {</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">            for (int j = 0; j &lt; 256; j++) {</span>
<span class="fc" id="L331">                ipMaskLeft[i][j] = 0;</span>
<span class="fc" id="L332">                ipMaskRight[i][j] = 0;</span>
<span class="fc" id="L333">                fpMaskLeft[i][j] = 0;</span>
<span class="fc" id="L334">                fpMaskRight[i][j] = 0;</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">                for (int k = 0; k &lt; 8; k++) {</span>
<span class="fc" id="L336">                    inBit = 8 * i + k;</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">                    if ((j &amp; bits32[bits8Offset + k]) != 0) {</span>
<span class="fc" id="L338">                        outBit = initPerm[inBit];</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">                        if (outBit &lt; 32) {</span>
<span class="fc" id="L340">                            ipMaskLeft[i][j] |= bits32[outBit];</span>
                        } else {
<span class="fc" id="L342">                            ipMaskRight[i][j] |= bits32[outBit - 32];</span>
                        }

<span class="fc" id="L345">                        outBit = finalPerm[inBit];</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">                        if (outBit &lt; 32) {</span>
<span class="fc" id="L347">                            fpMaskLeft[i][j] |= bits32[outBit];</span>
                        } else {
<span class="fc" id="L349">                            fpMaskRight[i][j] |= bits32[outBit - 32];</span>
                        }
                    }
                }
            }
<span class="fc bfc" id="L354" title="All 2 branches covered.">            for (int j = 0; j &lt; 128; j++) {</span>
<span class="fc" id="L355">                keyPermMaskLeft[i][j] = 0;</span>
<span class="fc" id="L356">                keyPermMaskRight[i][j] = 0;</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">                for (int k = 0; k &lt; 7; k++) {</span>
<span class="fc" id="L358">                    inBit = 8 * i + k;</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">                    if ((j &amp; bits32[bits8Offset + k + 1]) != 0) {</span>
<span class="fc" id="L360">                        outBit = invKeyPerm[inBit];</span>
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">                        if (outBit == 255) {</span>
<span class="nc" id="L362">                            continue;</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">                        } else if (outBit &lt; 28) {</span>
<span class="fc" id="L364">                            keyPermMaskLeft[i][j] |= bits32[bits28Offset + outBit];</span>
                        } else {
<span class="fc" id="L366">                            keyPermMaskRight[i][j] |= bits32[bits28Offset + (outBit - 28)];</span>
                        }
                    }
                }

<span class="fc" id="L371">                compPermMaskLeft[i][j] = 0;</span>
<span class="fc" id="L372">                compPermMaskRight[i][j] = 0;</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">                for (int k = 0; k &lt; 7; k++) {</span>
<span class="fc" id="L374">                    inBit = 7 * i + k;</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">                    if ((j &amp; bits32[bits8Offset + k + 1]) != 0) {</span>
<span class="fc" id="L376">                        outBit = invCompPerm[inBit];</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">                        if (outBit == 255) {</span>
<span class="fc" id="L378">                            continue;</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">                        } else if (outBit &lt; 24) {</span>
<span class="fc" id="L380">                            compPermMaskLeft[i][j] |= bits32[bits24Offset + outBit];</span>
                        } else {
<span class="fc" id="L382">                            compPermMaskRight[i][j] |= bits32[bits24Offset + outBit - 24];</span>
                        }
                    }
                }
            }
        }

        // Invert the P-box permutation
<span class="fc bfc" id="L390" title="All 2 branches covered.">        for (int i = 0; i &lt; 32; i++) {</span>
<span class="fc" id="L391">            invPBox[(PBox[i] - 1) &amp; 0xff] = (byte) i;</span>
        }

<span class="fc bfc" id="L394" title="All 2 branches covered.">        for (int i = 0; i &lt; 4; i++) {</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">            for (int j = 0; j &lt; 256; j++) {</span>
<span class="fc" id="L396">                PSBox[i][j] = 0;</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">                for (int k = 0; k &lt; 8; k++) {</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">                    if ((j &amp; bits32[bits8Offset + k]) != 0) {</span>
<span class="fc" id="L399">                        PSBox[i][j] |= bits32[invPBox[8 * i + k] &amp; 0xff];</span>
                    }
                }
            }
        }
<span class="fc" id="L404">        tablesInitialized = true;</span>
<span class="fc" id="L405">    }</span>

    /**
     * Hashes the given password using the BSD variant of the Unix DES Crypt algorithm.
     *
     * @param password the password to be hashed
     * @param salt the 24-bit salt to be used
     * @param iterationCount the number of iterations to use, must be between 1 and 16777215, inclusive
     * @return a {@code byte[]} containing the hashed password
     */
    static byte[] crypt(final byte[] password, final int salt, final int iterationCount) {
        byte[] hash;
        byte[] currentKey;
        byte[] nextGroup;
        int[] currentSchedule;

<span class="pc bpc" id="L421" title="1 of 4 branches missed.">        if (iterationCount &lt; 1 || iterationCount &gt; 16777215) {</span>
<span class="fc" id="L422">            throw log.invalidNumberOfRoundsMustBeIntBetween(1, 16777215);</span>
        }

<span class="fc bfc" id="L425" title="All 2 branches covered.">        if (!tablesInitialized) {</span>
<span class="fc" id="L426">            setupTables();</span>
        }

        // The first group becomes the initial key
<span class="fc" id="L430">        currentKey = getKeyGroup(password, 0);</span>

<span class="fc" id="L432">        int nextStartIndex = 8;</span>
<span class="fc" id="L433">        int passwordLen = password.length;</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">        while (nextStartIndex &lt; passwordLen) {</span>
<span class="fc" id="L435">            currentSchedule = desSetKey(currentKey);</span>

            // Encrypt the current key using itself as the input
<span class="fc" id="L438">            hash = desCipher(currentSchedule, fourBytesToInt(currentKey, 0), fourBytesToInt(currentKey, 4), 0, 1);</span>

            // XOR the result with the next group to get the next key
<span class="fc" id="L441">            nextGroup = getKeyGroup(password, nextStartIndex);</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">            for (int i = 0; i &lt; nextGroup.length; i++) {</span>
<span class="fc" id="L443">                currentKey[i] = (byte)(hash[i] ^ nextGroup[i]);</span>
            }

<span class="fc" id="L446">            nextStartIndex += 8;</span>
        }

<span class="fc" id="L449">        currentSchedule = desSetKey(currentKey);</span>

        // Encrypt the current key using an input of 0
<span class="fc" id="L452">        hash = desCipher(currentSchedule, 0, 0, salt, iterationCount);</span>
<span class="fc" id="L453">        return hash;</span>
    }

    /**
     * Gets the key group from the given password that starts at the given index. The key
     * group contains 8 bytes and is such that the byte at index i contains the lower
     * 7 bits of the byte at {@code password[startIndex + i]}.
     *
     * @param password the password
     * @param startIndex the index where the key group begins
     * @return a {@code byte[]} containing the key group
     */
    private static byte[] getKeyGroup(final byte[] password, int startIndex) {
<span class="fc" id="L466">        final byte[] keyGroup = new byte[8];</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">        for (int i = 0; i &lt; keyGroup.length; i++) {</span>
<span class="fc" id="L468">            keyGroup[i] = 0;</span>
        }

<span class="fc" id="L471">        int index = startIndex;</span>
<span class="fc bfc" id="L472" title="All 4 branches covered.">        for (int i = 0; i &lt; keyGroup.length &amp;&amp; index &lt; password.length; i++) {</span>
<span class="fc" id="L473">            final int iChar = password[index++];</span>
<span class="fc" id="L474">            keyGroup[i] = (byte) (iChar &lt;&lt; 1);</span>
        }
<span class="fc" id="L476">        return keyGroup;</span>
    }

    /**
     * Calculates the key schedule for the given key. The key schedule contains
     * 16 subkeys, each of which can be represented by a pair of integers.
     *
     * @param key the key
     * @return an {@code int[]} of size 32 containing the key schedule
     */
    private static int[] desSetKey(final byte[] key) {
<span class="fc" id="L487">        final int[] schedule = new int[32];</span>
<span class="fc" id="L488">        int key0 = fourBytesToInt(key, 0);</span>
<span class="fc" id="L489">        int key1 = fourBytesToInt(key, 4);</span>

        // Permute the key and split it into two 28-bit subkeys
<span class="fc" id="L492">        int k0 = keyPermMaskLeft[0][key0 &gt;&gt;&gt; 25] | keyPermMaskLeft[1][(key0 &gt;&gt;&gt; 17) &amp; 0x7f]</span>
                | keyPermMaskLeft[2][(key0 &gt;&gt;&gt; 9) &amp; 0x7f] | keyPermMaskLeft[3][(key0 &gt;&gt;&gt; 1) &amp; 0x7f]
                | keyPermMaskLeft[4][key1 &gt;&gt;&gt; 25] | keyPermMaskLeft[5][(key1 &gt;&gt;&gt; 17) &amp; 0x7f]
                | keyPermMaskLeft[6][(key1 &gt;&gt;&gt; 9) &amp; 0x7f] | keyPermMaskLeft[7][(key1 &gt;&gt;&gt; 1) &amp; 0x7f];

<span class="fc" id="L497">        int k1 = keyPermMaskRight[0][key0 &gt;&gt;&gt; 25] | keyPermMaskRight[1][(key0 &gt;&gt;&gt; 17) &amp; 0x7f]</span>
                | keyPermMaskRight[2][(key0 &gt;&gt;&gt; 9) &amp; 0x7f] | keyPermMaskRight[3][(key0 &gt;&gt;&gt; 1) &amp; 0x7f]
                | keyPermMaskRight[4][key1 &gt;&gt;&gt; 25] | keyPermMaskRight[5][(key1 &gt;&gt;&gt; 17) &amp; 0x7f]
                | keyPermMaskRight[6][(key1 &gt;&gt;&gt; 9) &amp; 0x7f] | keyPermMaskRight[7][(key1 &gt;&gt;&gt; 1) &amp; 0x7f];

        // Rotate the subkeys and do the compression permutation
<span class="fc" id="L503">        int shifts = 0;</span>
<span class="fc" id="L504">        int j = 0;</span>
        int t0, t1;
<span class="fc bfc" id="L506" title="All 2 branches covered.">        for (int i = 0; i &lt; 16; i++) {</span>
<span class="fc" id="L507">            shifts += keyShifts[i] &amp; 0xff;</span>
<span class="fc" id="L508">            t0 = (k0 &lt;&lt; shifts) | (k0 &gt;&gt;&gt; (28 - shifts));</span>
<span class="fc" id="L509">            t1 = (k1 &lt;&lt; shifts) | (k1 &gt;&gt;&gt; (28 - shifts));</span>

            // Left half of the subkey
<span class="fc" id="L512">            schedule[j++] = compPermMaskLeft[0][(t0 &gt;&gt;&gt; 21) &amp; 0x7f] | compPermMaskLeft[1][(t0 &gt;&gt;&gt; 14) &amp; 0x7f]</span>
                    | compPermMaskLeft[2][(t0 &gt;&gt;&gt; 7) &amp; 0x7f] | compPermMaskLeft[3][t0 &amp; 0x7f]
                    | compPermMaskLeft[4][(t1 &gt;&gt;&gt; 21) &amp; 0x7f] | compPermMaskLeft[5][(t1 &gt;&gt;&gt; 14) &amp; 0x7f]
                    | compPermMaskLeft[6][(t1 &gt;&gt;&gt; 7) &amp; 0x7f] | compPermMaskLeft[7][t1 &amp; 0x7f];

            // Right half of the subkey
<span class="fc" id="L518">            schedule[j++] = compPermMaskRight[0][(t0 &gt;&gt;&gt; 21) &amp; 0x7f] | compPermMaskRight[1][(t0 &gt;&gt;&gt; 14) &amp; 0x7f]</span>
                    | compPermMaskRight[2][(t0 &gt;&gt;&gt; 7) &amp; 0x7f] | compPermMaskRight[3][t0 &amp; 0x7f]
                    | compPermMaskRight[4][(t1 &gt;&gt;&gt; 21) &amp; 0x7f] | compPermMaskRight[5][(t1 &gt;&gt;&gt; 14) &amp; 0x7f]
                    | compPermMaskRight[6][(t1 &gt;&gt;&gt; 7) &amp; 0x7f] | compPermMaskRight[7][t1 &amp; 0x7f];
        }
<span class="fc" id="L523">        return schedule;</span>
    }

    /**
     * Performs DES encryption using the given key schedule, input block, salt, and iteration count.
     *
     * @param schedule the key schedule
     * @param leftInput the most significant half of the input block
     * @param rightInput the least signicant half of the input block
     * @param salt the 24-bit salt to be used
     * @param iterationCount the number of iterations to use
     * @return a {@code byte[]} containing the hashed password
     */
    private static byte[] desCipher(final int[] schedule, final int leftInput, final int rightInput, final int salt, final int iterationCount) {
        int l, r;
<span class="fc" id="L538">        int f = 0;</span>
<span class="fc" id="L539">        final byte[] hash = new byte[8];</span>

<span class="fc" id="L541">        int rearrangedSalt = setupSalt(salt);</span>

        // Initial permutation
<span class="fc" id="L544">        l = ipMaskLeft[0][leftInput &gt;&gt;&gt; 24] | ipMaskLeft[1][(leftInput &gt;&gt;&gt; 16) &amp; 0xff] | ipMaskLeft[2][(leftInput &gt;&gt;&gt; 8) &amp; 0xff]</span>
                | ipMaskLeft[3][leftInput &amp; 0xff] | ipMaskLeft[4][rightInput &gt;&gt;&gt; 24] | ipMaskLeft[5][(rightInput &gt;&gt;&gt; 16) &amp; 0xff]
                | ipMaskLeft[6][(rightInput &gt;&gt;&gt; 8) &amp; 0xff] | ipMaskLeft[7][rightInput &amp; 0xff];

<span class="fc" id="L548">        r = ipMaskRight[0][leftInput &gt;&gt;&gt; 24] | ipMaskRight[1][(leftInput &gt;&gt;&gt; 16) &amp; 0xff] | ipMaskRight[2][(leftInput &gt;&gt;&gt; 8) &amp; 0xff]</span>
                | ipMaskRight[3][leftInput &amp; 0xff] | ipMaskRight[4][rightInput &gt;&gt;&gt; 24] | ipMaskRight[5][(rightInput &gt;&gt;&gt; 16) &amp; 0xff]
                | ipMaskRight[6][(rightInput &gt;&gt;&gt; 8) &amp; 0xff] | ipMaskRight[7][rightInput &amp; 0xff];

        int rLeft, rRight;
        int k;
<span class="fc bfc" id="L554" title="All 2 branches covered.">        for (int i = 0; i &lt; iterationCount; i++) {</span>
<span class="fc" id="L555">            k = 0;</span>
<span class="fc bfc" id="L556" title="All 2 branches covered.">            for (int j = 0; j &lt; 16; j++) {</span>

                // Expand r to 48 bits (simulates the E-box)
<span class="fc" id="L559">                rLeft = ((r &amp; 0x00000001) &lt;&lt; 23) | ((r &amp; 0xf8000000) &gt;&gt;&gt; 9) | ((r &amp; 0x1f800000) &gt;&gt;&gt; 11)</span>
                        | ((r &amp; 0x01f80000) &gt;&gt;&gt; 13) | ((r &amp; 0x001f8000) &gt;&gt;&gt; 15);
<span class="fc" id="L561">                rRight = ((r &amp; 0x0001f800) &lt;&lt; 7) | ((r &amp; 0x00001f80) &lt;&lt; 5) | ((r &amp; 0x000001f8) &lt;&lt; 3)</span>
                        | ((r &amp; 0x0000001f) &lt;&lt; 1) | ((r &amp; 0x80000000) &gt;&gt;&gt; 31);

                // The salt will flip certain bits
<span class="fc" id="L565">                f = (rLeft ^ rRight) &amp; rearrangedSalt;</span>
<span class="fc" id="L566">                rLeft ^= (f ^ schedule[k++]);</span>
<span class="fc" id="L567">                rRight ^= (f ^ schedule[k++]);</span>

                // Perform S-box lookups and do the P-box permutation
<span class="fc" id="L570">                f = PSBox[0][mSBox[0][rLeft &gt;&gt;&gt; 12]] | PSBox[1][mSBox[1][rLeft &amp; 0xfff]] | PSBox[2][mSBox[2][rRight &gt;&gt;&gt; 12]]</span>
                        | PSBox[3][mSBox[3][rRight &amp; 0xfff]];

<span class="fc" id="L573">                f ^= l;</span>
<span class="fc" id="L574">                l = r;</span>
<span class="fc" id="L575">                r = f;</span>
            }

<span class="fc" id="L578">            r = l;</span>
<span class="fc" id="L579">            l = f;</span>
        }

        // Final permutation
        int leftOutput, rightOutput;
<span class="fc" id="L584">        leftOutput = fpMaskLeft[0][l &gt;&gt;&gt; 24] | fpMaskLeft[1][(l &gt;&gt;&gt; 16) &amp; 0xff] | fpMaskLeft[2][(l &gt;&gt;&gt; 8) &amp; 0xff]</span>
                | fpMaskLeft[3][l &amp; 0xff] | fpMaskLeft[4][r &gt;&gt;&gt; 24] | fpMaskLeft[5][(r &gt;&gt;&gt; 16) &amp; 0xff]
                | fpMaskLeft[6][(r &gt;&gt;&gt; 8) &amp; 0xff] | fpMaskLeft[7][r &amp; 0xff];

<span class="fc" id="L588">        rightOutput = fpMaskRight[0][l &gt;&gt;&gt; 24] | fpMaskRight[1][(l &gt;&gt;&gt; 16) &amp; 0xff] | fpMaskRight[2][(l &gt;&gt;&gt; 8) &amp; 0xff]</span>
                | fpMaskRight[3][l &amp; 0xff] | fpMaskRight[4][r &gt;&gt;&gt; 24] | fpMaskRight[5][(r &gt;&gt;&gt; 16) &amp; 0xff]
                | fpMaskRight[6][(r &gt;&gt;&gt; 8) &amp; 0xff] | fpMaskRight[7][r &amp; 0xff];

<span class="fc" id="L592">        intToFourBytes(leftOutput, hash, 0);</span>
<span class="fc" id="L593">        intToFourBytes(rightOutput, hash, 4);</span>
<span class="fc" id="L594">        return hash;</span>
    }

    /**
     * Rearranges the bits in the 24-bit salt.
     */
    private static int setupSalt(int salt) {
<span class="fc" id="L601">        int resultBit = 0x800000;</span>
<span class="fc" id="L602">        int saltBit = 1;</span>
<span class="fc" id="L603">        int result = 0;</span>

<span class="fc bfc" id="L605" title="All 2 branches covered.">        for (int i = 0; i &lt; 24; i++) {</span>
<span class="fc bfc" id="L606" title="All 2 branches covered.">            if ((salt &amp; saltBit) != 0) {</span>
<span class="fc" id="L607">                result |= resultBit;</span>
            }
<span class="fc" id="L609">            saltBit &lt;&lt;= 1;</span>
<span class="fc" id="L610">            resultBit &gt;&gt;= 1;</span>
        }
<span class="fc" id="L612">        return result;</span>
    }

    private static int fourBytesToInt(final byte[] b, int offset) {
        // Big-endian format
<span class="fc" id="L617">        final byte b4 = b[offset++];</span>
<span class="fc" id="L618">        int value = (b4 &amp; 0xff) &lt;&lt; 24;</span>
<span class="fc" id="L619">        final byte b3 = b[offset++];</span>
<span class="fc" id="L620">        value |= (b3 &amp; 0xff) &lt;&lt; 16;</span>
<span class="fc" id="L621">        final byte b2 = b[offset++];</span>
<span class="fc" id="L622">        value |= (b2 &amp; 0xff) &lt;&lt; 8;</span>
<span class="fc" id="L623">        final byte b1 = b[offset  ];</span>
<span class="fc" id="L624">        value |= b1 &amp; 0xff;</span>
<span class="fc" id="L625">        return value;</span>
    }

    private static void intToFourBytes(final int iValue, final byte[] b, int offset) {
        // Big-endian format
<span class="fc" id="L630">        b[offset++] = (byte) (iValue &gt;&gt;&gt; 24 &amp; 0xff);</span>
<span class="fc" id="L631">        b[offset++] = (byte) (iValue &gt;&gt;&gt; 16 &amp; 0xff);</span>
<span class="fc" id="L632">        b[offset++] = (byte) (iValue &gt;&gt;&gt; 8 &amp; 0xff);</span>
<span class="fc" id="L633">        b[offset  ] = (byte) (iValue &amp; 0xff);</span>
<span class="fc" id="L634">    }</span>

    private void readObject(ObjectInputStream ignored) throws NotSerializableException {
<span class="nc" id="L637">        throw new NotSerializableException();</span>
    }

    public int hashCode() {
<span class="nc" id="L641">        return multiHashOrdered(multiHashOrdered(Arrays.hashCode(hash), salt), iterationCount);</span>
    }

    public boolean equals(final Object obj) {
<span class="nc bnc" id="L645" title="All 2 branches missed.">        if (! (obj instanceof BSDUnixDESCryptPasswordImpl)) {</span>
<span class="nc" id="L646">            return false;</span>
        }
<span class="nc" id="L648">        BSDUnixDESCryptPasswordImpl other = (BSDUnixDESCryptPasswordImpl) obj;</span>
<span class="nc bnc" id="L649" title="All 6 branches missed.">        return iterationCount == other.iterationCount &amp;&amp; salt == other.salt &amp;&amp; Arrays.equals(hash, other.hash);</span>
    }

    Object writeReplace() {
<span class="nc" id="L653">        return BSDUnixDESCryptPassword.createRaw(getAlgorithm(), hash, salt, iterationCount);</span>
    }

    public BSDUnixDESCryptPasswordImpl clone() {
<span class="nc" id="L657">        return this;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>