<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>FileSystemSecurityRealm.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">WildFly Elytron</a> &gt; <a href="../index.html" class="el_bundle">wildfly-elytron-realm</a> &gt; <a href="index.source.html" class="el_package">org.wildfly.security.auth.realm</a> &gt; <span class="el_source">FileSystemSecurityRealm.java</span></div><h1>FileSystemSecurityRealm.java</h1><pre class="source lang-java linenums">/*
 * JBoss, Home of Professional Open Source.
 * Copyright 2015 Red Hat, Inc., and individual contributors
 * as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.wildfly.security.auth.realm;

import static java.nio.file.StandardOpenOption.CREATE_NEW;
import static java.nio.file.StandardOpenOption.DSYNC;
import static java.nio.file.StandardOpenOption.READ;
import static java.nio.file.StandardOpenOption.WRITE;
import static javax.xml.stream.XMLStreamConstants.END_ELEMENT;
import static javax.xml.stream.XMLStreamConstants.START_ELEMENT;
import static org.wildfly.security.provider.util.ProviderUtil.INSTALLED_PROVIDERS;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.DirectoryStream;
import java.nio.file.FileAlreadyExistsException;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;
import java.security.AccessController;
import java.security.GeneralSecurityException;
import java.security.InvalidAlgorithmParameterException;
import java.security.KeyException;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.Principal;
import java.security.PrivateKey;
import java.security.PrivilegedAction;
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;
import java.security.Provider;
import java.security.PublicKey;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.spec.AlgorithmParameterSpec;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.text.Normalizer;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ThreadLocalRandom;
import java.util.function.Consumer;
import java.util.function.Supplier;
import javax.crypto.SecretKey;
import javax.xml.crypto.MarshalException;
import javax.xml.crypto.dsig.CanonicalizationMethod;
import javax.xml.crypto.dsig.DigestMethod;
import javax.xml.crypto.dsig.Reference;
import javax.xml.crypto.dsig.SignedInfo;
import javax.xml.crypto.dsig.Transform;
import javax.xml.crypto.dsig.XMLSignature;
import javax.xml.crypto.dsig.XMLSignatureException;
import javax.xml.crypto.dsig.XMLSignatureFactory;
import javax.xml.crypto.dsig.dom.DOMSignContext;
import javax.xml.crypto.dsig.dom.DOMValidateContext;
import javax.xml.crypto.dsig.keyinfo.KeyInfo;
import javax.xml.crypto.dsig.keyinfo.KeyInfoFactory;
import javax.xml.crypto.dsig.keyinfo.KeyValue;
import javax.xml.crypto.dsig.spec.C14NMethodParameterSpec;
import javax.xml.crypto.dsig.spec.TransformParameterSpec;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.wildfly.common.Assert;
import org.wildfly.common.bytes.ByteStringBuilder;
import org.wildfly.common.codec.Base32Alphabet;
import org.wildfly.common.codec.Base64Alphabet;
import org.wildfly.common.iteration.ByteIterator;
import org.wildfly.common.iteration.CodePointIterator;
import org.wildfly.security.auth.SupportLevel;
import org.wildfly.security.auth.principal.NamePrincipal;
import org.wildfly.security.auth.realm.IdentitySharedExclusiveLock.IdentityLock;
import org.wildfly.security.auth.server.ModifiableRealmIdentity;
import org.wildfly.security.auth.server.ModifiableRealmIdentityIterator;
import org.wildfly.security.auth.server.ModifiableSecurityRealm;
import org.wildfly.security.auth.server.NameRewriter;
import org.wildfly.security.auth.server.RealmIdentity;
import org.wildfly.security.auth.server.RealmUnavailableException;
import org.wildfly.security.authz.Attributes;
import org.wildfly.security.authz.AuthorizationIdentity;
import org.wildfly.security.authz.MapAttributes;
import org.wildfly.security.credential.Credential;
import org.wildfly.security.credential.PasswordCredential;
import org.wildfly.security.credential.PublicKeyCredential;
import org.wildfly.security.credential.X509CertificateChainPublicCredential;
import org.wildfly.security.encryption.CipherUtil;
import org.wildfly.security.evidence.Evidence;
import org.wildfly.security.password.Password;
import org.wildfly.security.password.PasswordFactory;
import org.wildfly.security.password.interfaces.OneTimePassword;
import org.wildfly.security.password.spec.BasicPasswordSpecEncoding;
import org.wildfly.security.password.spec.Encoding;
import org.wildfly.security.password.spec.OneTimePasswordSpec;
import org.wildfly.security.password.spec.PasswordSpec;
import org.wildfly.security.password.util.ModularCrypt;
import org.wildfly.security.permission.ElytronPermission;
import org.xml.sax.SAXException;

/**
 * A simple filesystem-backed security realm.
 *
 * @author &lt;a href=&quot;mailto:david.lloyd@redhat.com&quot;&gt;David M. Lloyd&lt;/a&gt;
 */
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">public final class FileSystemSecurityRealm implements ModifiableSecurityRealm, CacheableSecurityRealm {</span>

<span class="fc" id="L154">    static final ElytronPermission CREATE_SECURITY_REALM = ElytronPermission.forName(&quot;createSecurityRealm&quot;);</span>

    private final Supplier&lt;Provider[]&gt; providers;
    static final Map&lt;String, Version&gt; KNOWN_NAMESPACES;

<span class="fc" id="L159">    private enum Version {</span>

<span class="fc" id="L161">        VERSION_1_0(&quot;urn:elytron:1.0&quot;, null),</span>
<span class="fc" id="L162">        VERSION_1_0_1(&quot;urn:elytron:1.0.1&quot;, VERSION_1_0),</span>
<span class="fc" id="L163">        VERSION_1_1(&quot;urn:elytron:identity:1.1&quot;, VERSION_1_0_1),</span>
<span class="fc" id="L164">        VERSION_1_2(&quot;urn:elytron:identity:1.2&quot;, VERSION_1_1);</span>

        final String namespace;

        /*
         * In the future we could support multiple parents but wait until that becomes a reality before adding it.
         */
        final Version parent;

<span class="fc" id="L173">        Version(String namespace, Version parent) {</span>
<span class="fc" id="L174">            this.namespace = namespace;</span>
<span class="fc" id="L175">            this.parent = parent;</span>
<span class="fc" id="L176">        }</span>

        String getNamespace() {
<span class="fc" id="L179">            return namespace;</span>
        }

        boolean isAtLeast(Version version) {
<span class="nc bnc" id="L183" title="All 6 branches missed.">            return this.equals(version) || (parent != null ? parent.isAtLeast(version) : false);</span>
        }

    }

    static {
<span class="fc" id="L189">        Map&lt;String, Version&gt; knownNamespaces = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">        for (Version version : Version.values()) {</span>
<span class="fc" id="L191">            knownNamespaces.put(version.namespace, version);</span>
        }
<span class="fc" id="L193">        KNOWN_NAMESPACES = Collections.unmodifiableMap(knownNamespaces);</span>
<span class="fc" id="L194">    }</span>

    private final Path root;
    private final NameRewriter nameRewriter;
    private final int levels;
    private final boolean encoded;
    private final Charset hashCharset;
    private final Encoding hashEncoding;
    private final SecretKey secretKey;
    private final PrivateKey privateKey;
    private final PublicKey publicKey;
<span class="fc" id="L205">    private final ConcurrentHashMap&lt;String, IdentitySharedExclusiveLock&gt; realmIdentityLocks = new ConcurrentHashMap&lt;&gt;();</span>

    /**
     * Construct a new instance of the FileSystemSecurityRealmBuilder.
     *
     * @return the new FileSystemSecurityRealmBuilder instance
     */
    public static FileSystemSecurityRealmBuilder builder() {
<span class="nc" id="L213">        return new FileSystemSecurityRealmBuilder();</span>
    }
    /**
     * Construct a new instance.
     *
     * Construction with enabled security manager requires {@code createSecurityRealm} {@link ElytronPermission}.
     *
     * @param root the root path of the identity store
     * @param nameRewriter the name rewriter to apply to looked up names
     * @param levels the number of levels of directory hashing to apply
     * @param encoded whether identity names should be BASE32 encoded before using as filename (only applies if the security realm is unencrypted)
     * @param hashCharset the character set to use when converting password strings to a byte array. Uses UTF-8 by default.
     * @param hashEncoding the string format for the hashed passwords. Uses Base64 by default.
     * @param providers The providers supplier
     * @param secretKey the SecretKey used to encrypt and decrypt the security realm (if {@code null}, the security realm will be unencrypted)
     * @param privateKey the PrivateKey used to verify the integrity of the security realm (if {@code null}, the security realm will not verify integrity)
     * @param publicKey the PublicKey used to verify the integrity of the security realm (if {@code null}, the security realm will not verify integrity)
     *
     */
<span class="fc" id="L232">    public FileSystemSecurityRealm(final Path root, final NameRewriter nameRewriter, final int levels, final boolean encoded, final Encoding hashEncoding, final Charset hashCharset, final Supplier&lt;Provider[]&gt; providers, final SecretKey secretKey, final PrivateKey privateKey, final PublicKey publicKey) {</span>
<span class="fc" id="L233">        final SecurityManager sm = System.getSecurityManager();</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">        if (sm != null) {</span>
<span class="nc" id="L235">            sm.checkPermission(CREATE_SECURITY_REALM);</span>
        }
<span class="fc" id="L237">        this.root = root;</span>
<span class="fc" id="L238">        this.nameRewriter = nameRewriter;</span>
<span class="fc" id="L239">        this.levels = levels;</span>
<span class="pc bpc" id="L240" title="2 of 4 branches missed.">        this.encoded = secretKey == null &amp;&amp; encoded;</span>
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">        this.hashCharset = hashCharset != null ? hashCharset : StandardCharsets.UTF_8;</span>
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">        this.hashEncoding = hashEncoding != null ? hashEncoding : Encoding.BASE64;</span>
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">        this.providers = providers != null ? providers : INSTALLED_PROVIDERS;</span>
<span class="fc" id="L244">        this.secretKey = secretKey;</span>
<span class="fc" id="L245">        this.privateKey = privateKey;</span>
<span class="fc" id="L246">        this.publicKey = publicKey;</span>

<span class="fc" id="L248">    }</span>

    /**
     * Construct a new instance.
     *
     * Construction with enabled security manager requires {@code createSecurityRealm} {@link ElytronPermission}.
     *
     * @param root the root path of the identity store
     * @param nameRewriter the name rewriter to apply to looked up names
     * @param levels the number of levels of directory hashing to apply
     * @param encoded whether identity names should be BASE32 encoded before using as filename
     * @param hashCharset the character set to use when converting password strings to a byte array. Uses UTF-8 by default.
     * @param hashEncoding the string format for the hashed passwords. Uses Base64 by default.
     * @param secretKey the SecretKey used to encrypt and decrypt the security realm (if {@code null}, the security realm will be unencrypted)
     */
    public FileSystemSecurityRealm(final Path root, final NameRewriter nameRewriter, final int levels, final boolean encoded, final Encoding hashEncoding, final Charset hashCharset, final SecretKey secretKey) {
<span class="nc" id="L264">        this(root, nameRewriter, levels, encoded, hashEncoding, hashCharset, INSTALLED_PROVIDERS, secretKey, null, null);</span>
<span class="nc" id="L265">    }</span>

    /**
     * Construct a new instance.
     *
     * Construction with enabled security manager requires {@code createSecurityRealm} {@link ElytronPermission}.
     *
     * @param root the root path of the identity store
     * @param nameRewriter the name rewriter to apply to looked up names
     * @param levels the number of levels of directory hashing to apply
     * @param encoded whether identity names should be BASE32 encoded before using as filename
     * @param hashCharset the character set to use when converting password strings to a byte array. Uses UTF-8 by default.
     * @param hashEncoding the string format for the hashed passwords. Uses Base64 by default.
     */
    public FileSystemSecurityRealm(final Path root, final NameRewriter nameRewriter, final int levels, final boolean encoded, final Encoding hashEncoding, final Charset hashCharset) {
<span class="nc" id="L280">        this(root, nameRewriter, levels, encoded, hashEncoding, hashCharset, INSTALLED_PROVIDERS, null, null, null);</span>
<span class="nc" id="L281">    }</span>

    /**
     * Construct a new instance.
     *
     * Construction with enabled security manager requires {@code createSecurityRealm} {@link ElytronPermission}.
     *
     * @param root the root path of the identity store
     * @param nameRewriter the name rewriter to apply to looked up names
     * @param levels the number of levels of directory hashing to apply
     * @param encoded whether identity names should by BASE32 encoded before using as filename
     */
    public FileSystemSecurityRealm(final Path root, final NameRewriter nameRewriter, final int levels, final boolean encoded) {
<span class="fc" id="L294">        this(root, nameRewriter, levels, encoded, Encoding.BASE64, StandardCharsets.UTF_8, INSTALLED_PROVIDERS, null, null, null);</span>
<span class="fc" id="L295">    }</span>

    /**
     * Construct a new instance.
     *
     * @param root the root path of the identity store
     * @param nameRewriter the name rewriter to apply to looked up names
     * @param levels the number of levels of directory hashing to apply
     */
    public FileSystemSecurityRealm(final Path root, final NameRewriter nameRewriter, final int levels) {
<span class="nc" id="L305">        this(root, nameRewriter, levels, true);</span>
<span class="nc" id="L306">    }</span>

    /**
     * Construct a new instance.
     *
     * @param root the root path of the identity store
     * @param nameRewriter the name rewriter to apply to looked up names
     * @param levels the number of levels of directory hashing to apply
     * @param hashEncoding the string format for hashed passwords. Uses Base64 by default.
     * @param hashCharset the character set to use when converting password strings to a byte array. Uses UTF-8 by default and must not be {@code null}.
     */
    public FileSystemSecurityRealm(final Path root, final NameRewriter nameRewriter, final int levels, final Encoding hashEncoding, final Charset hashCharset) {
<span class="nc" id="L318">        this(root, nameRewriter, levels, true, hashEncoding, hashCharset, INSTALLED_PROVIDERS, null, null, null);</span>
<span class="nc" id="L319">    }</span>



    /**
     * Construct a new instance.
     *
     * @param root the root path of the identity store
     * @param levels the number of levels of directory hashing to apply
     */
    public FileSystemSecurityRealm(final Path root, final int levels) {
<span class="nc" id="L330">        this(root, NameRewriter.IDENTITY_REWRITER, levels, true);</span>
<span class="nc" id="L331">    }</span>


    /**
     * Construct a new instance.
     *
     * @param root the root path of the identity store
     * @param levels the number of levels of directory hashing to apply
     * @param hashEncoding the string format for hashed passwords. Uses Base64 by default.
     * @param hashCharset the character set to use when converting password strings to a byte array. Uses UTF-8 by default and must not be {@code null}.
     */
    public FileSystemSecurityRealm(final Path root, final int levels, final Encoding hashEncoding, final Charset hashCharset) {
<span class="nc" id="L343">        this(root, NameRewriter.IDENTITY_REWRITER, levels, true, hashEncoding, hashCharset, INSTALLED_PROVIDERS, null, null, null);</span>
<span class="nc" id="L344">    }</span>

    /**
     * Construct a new instance with 2 levels of hashing.
     *
     * @param root the root path of the identity store
     */
    public FileSystemSecurityRealm(final Path root) {
<span class="fc" id="L352">        this(root, NameRewriter.IDENTITY_REWRITER, 2, true);</span>
<span class="fc" id="L353">    }</span>

    /**
     * Construct a new instance with 2 levels of hashing.
     *
     * @param root the root path of the identity store
     * @param hashEncoding the string format for hashed passwords. Uses Base64 by default.
     * @param hashCharset the character set to use when converting password strings to a byte array. Uses UTF-8 by default and must not be {@code null}
     */
    public FileSystemSecurityRealm(final Path root, final Encoding hashEncoding, final Charset hashCharset) {
<span class="nc" id="L363">        this(root, NameRewriter.IDENTITY_REWRITER, 2, true, hashEncoding, hashCharset, INSTALLED_PROVIDERS, null, null, null);</span>
<span class="nc" id="L364">    }</span>

    public FileSystemSecurityRealm(Path root, int levels, Supplier&lt;Provider[]&gt; providers) {
<span class="nc" id="L367">        this(root, NameRewriter.IDENTITY_REWRITER, levels, true, Encoding.BASE64, StandardCharsets.UTF_8, providers, null, null, null);</span>
<span class="nc" id="L368">    }</span>

    /**
     * Checks if the FileSystemSecurityRealm has Integrity checking enabled
     * @return {@code true} if Integrity checking is enabled, and {@code false} otherwise
     */
    public boolean hasIntegrityEnabled() {
<span class="pc bpc" id="L375" title="3 of 4 branches missed.">        return privateKey != null &amp;&amp; publicKey != null;</span>
    }
    private Path pathFor(String name) {
<span class="pc bpc" id="L378" title="2 of 4 branches missed.">        assert name.codePointCount(0, name.length()) &gt; 0;</span>
<span class="fc" id="L379">        String normalizedName = name;</span>

<span class="pc bpc" id="L381" title="1 of 2 branches missed.">        if (encoded) {</span>
<span class="fc" id="L382">            normalizedName = Normalizer.normalize(name, Normalizer.Form.NFKC)</span>
<span class="fc" id="L383">                    .toLowerCase(Locale.ROOT)</span>
<span class="fc" id="L384">                    .replaceAll(&quot;[^a-z0-9]&quot;, &quot;_&quot;);</span>
        }
<span class="pc bpc" id="L386" title="2 of 4 branches missed.">        if (secretKey != null || encoded) {</span>
<span class="fc" id="L387">            String base32 = ByteIterator.ofBytes(new ByteStringBuilder().append(name).toArray())</span>
<span class="fc" id="L388">                    .base32Encode(Base32Alphabet.STANDARD, false).drainToString();</span>
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">            normalizedName = secretKey != null ? base32 : normalizedName + &quot;-&quot; + base32;</span>
        }

<span class="fc" id="L392">        Path path = root;</span>
<span class="fc" id="L393">        int idx = 0;</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">        for (int level = 0; level &lt; levels; level ++) {</span>
<span class="fc" id="L395">            int newIdx = normalizedName.offsetByCodePoints(idx, 1);</span>
<span class="fc" id="L396">            path = path.resolve(normalizedName.substring(idx, newIdx));</span>
<span class="fc" id="L397">            idx = newIdx;</span>
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">            if (idx == normalizedName.length()) {</span>
<span class="nc" id="L399">                break;</span>
            }
        }

<span class="fc" id="L403">        return path.resolve(normalizedName + &quot;.xml&quot;);</span>
    }

    public Charset getHashCharset() {
<span class="nc" id="L407">        return this.hashCharset;</span>
    }

    private String nameFor(Path path) {
<span class="nc" id="L411">        String fileName = path.toString();</span>
<span class="nc" id="L412">        fileName = fileName.substring(0, fileName.length() - 4); // remove &quot;.xml&quot;</span>

<span class="nc bnc" id="L414" title="All 2 branches missed.">        if (secretKey != null) {</span>
<span class="nc" id="L415">            CodePointIterator it = CodePointIterator.ofString(fileName);</span>
<span class="nc" id="L416">            fileName = it.base32Decode(Base32Alphabet.STANDARD, false)</span>
<span class="nc" id="L417">                    .asUtf8String().drainToString();</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">        } else if (encoded) {</span>
<span class="nc" id="L419">            CodePointIterator it = CodePointIterator.ofString(fileName);</span>
<span class="nc" id="L420">            it.delimitedBy('-').skipAll();</span>
<span class="nc" id="L421">            it.next(); // skip '-'</span>
<span class="nc" id="L422">            fileName = it.base32Decode(Base32Alphabet.STANDARD, false)</span>
<span class="nc" id="L423">                    .asUtf8String().drainToString();</span>
        }
<span class="nc" id="L425">        return fileName;</span>
    }

    public RealmIdentity getRealmIdentity(final Principal principal) {
<span class="pc bpc" id="L429" title="1 of 2 branches missed.">        return principal instanceof NamePrincipal ? getRealmIdentity(principal.getName(), false) : RealmIdentity.NON_EXISTENT;</span>
    }

    public ModifiableRealmIdentity getRealmIdentityForUpdate(final Principal principal) {
<span class="pc bpc" id="L433" title="1 of 2 branches missed.">        return principal instanceof NamePrincipal ? getRealmIdentity(principal.getName(), true) : ModifiableRealmIdentity.NON_EXISTENT;</span>
    }

    @Override
    public void registerIdentityChangeListener(Consumer&lt;Principal&gt; listener) {
        // no need to register the listener given that changes to identities are done through the realm
<span class="nc" id="L439">    }</span>

    private ModifiableRealmIdentity getRealmIdentity(final String name, final boolean exclusive) {
<span class="fc" id="L442">        final String finalName = nameRewriter.rewriteName(name);</span>
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">        if (finalName == null) {</span>
<span class="nc" id="L444">            throw ElytronMessages.log.invalidName();</span>
        }

        // Acquire the appropriate lock for the realm identity
<span class="fc" id="L448">        IdentitySharedExclusiveLock realmIdentityLock = getRealmIdentityLockForName(finalName);</span>
        IdentityLock lock;
<span class="fc bfc" id="L450" title="All 2 branches covered.">        if (exclusive) {</span>
<span class="fc" id="L451">            lock = realmIdentityLock.lockExclusive();</span>
        } else {
<span class="fc" id="L453">            lock = realmIdentityLock.lockShared();</span>
        }
<span class="fc" id="L455">        return new Identity(finalName, pathFor(finalName), lock, hashCharset, hashEncoding, providers, secretKey, privateKey, publicKey, hasIntegrityEnabled());</span>
    }

    public ModifiableRealmIdentityIterator getRealmIdentityIterator() throws RealmUnavailableException {
<span class="nc" id="L459">        return subIterator(root, levels);</span>
    }

    private ModifiableRealmIdentityIterator subIterator(final Path root, final int levels) {
        final DirectoryStream&lt;Path&gt; stream;
        final Iterator&lt;Path&gt; iterator;
<span class="nc bnc" id="L465" title="All 2 branches missed.">        if (levels == 0) {</span>
            try {
<span class="nc" id="L467">                stream = Files.newDirectoryStream(root, &quot;*.xml&quot;);</span>
<span class="nc" id="L468">                iterator = stream.iterator();</span>
<span class="nc" id="L469">            } catch (IOException e) {</span>
<span class="nc" id="L470">                ElytronMessages.log.debug(&quot;Unable to open directory&quot;, e);</span>
<span class="nc" id="L471">                return ModifiableRealmIdentityIterator.emptyIterator();</span>
<span class="nc" id="L472">            }</span>
<span class="nc" id="L473">            return new ModifiableRealmIdentityIterator() {</span>

                public boolean hasNext() {
<span class="nc bnc" id="L476" title="All 2 branches missed.">                    if ( ! iterator.hasNext()) {</span>
                        try {
<span class="nc" id="L478">                            close();</span>
<span class="nc" id="L479">                        } catch (IOException e) {</span>
<span class="nc" id="L480">                            ElytronMessages.log.debug(&quot;Unable to close the stream&quot;, e);</span>
<span class="nc" id="L481">                        }</span>
                    }
<span class="nc" id="L483">                    return iterator.hasNext();</span>
                }

                public ModifiableRealmIdentity next() {
<span class="nc" id="L487">                    final Path path = iterator.next();</span>
<span class="nc" id="L488">                    final String name = nameFor(path.getFileName());</span>
<span class="nc" id="L489">                    return getRealmIdentityForUpdate(new NamePrincipal(name));</span>
                }

                public void close() throws RealmUnavailableException {
                    try {
<span class="nc" id="L494">                        stream.close();</span>
<span class="nc" id="L495">                    } catch (IOException e) {</span>
<span class="nc" id="L496">                        ElytronMessages.log.debug(&quot;Unable to close the stream&quot;, e);</span>
<span class="nc" id="L497">                    }</span>
<span class="nc" id="L498">                }</span>
            };
        } else {
            try {
<span class="nc" id="L502">                stream = Files.newDirectoryStream(root, entry -&gt; {</span>
<span class="nc" id="L503">                    final String fileName = entry.getFileName().toString();</span>
<span class="nc bnc" id="L504" title="All 6 branches missed.">                    return fileName.length() == 1 &amp;&amp; !fileName.equals(&quot;.&quot;) &amp;&amp; Files.isDirectory(entry);</span>
                });
<span class="nc" id="L506">                iterator = stream.iterator();</span>
<span class="nc" id="L507">            } catch (IOException e) {</span>
<span class="nc" id="L508">                ElytronMessages.log.debug(&quot;Unable to open directory&quot;, e);</span>
<span class="nc" id="L509">                return ModifiableRealmIdentityIterator.emptyIterator();</span>
<span class="nc" id="L510">            }</span>
<span class="nc" id="L511">            return new ModifiableRealmIdentityIterator() {</span>
                private ModifiableRealmIdentityIterator subIterator;

                public boolean hasNext() {
                    for (;;) {
<span class="nc bnc" id="L516" title="All 2 branches missed.">                        if (subIterator == null) {</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">                            if (! iterator.hasNext()) {</span>
                                try {
<span class="nc" id="L519">                                    close();</span>
<span class="nc" id="L520">                                } catch (IOException e) {</span>
<span class="nc" id="L521">                                    ElytronMessages.log.debug(&quot;Unable to close the stream&quot;, e);</span>
<span class="nc" id="L522">                                }</span>
<span class="nc" id="L523">                                return false;</span>
                            }
<span class="nc" id="L525">                            final Path path = iterator.next();</span>
<span class="nc" id="L526">                            subIterator = subIterator(path, levels - 1);</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">                        } else if (subIterator.hasNext()) {</span>
<span class="nc" id="L528">                            return true;</span>
                        } else {
<span class="nc" id="L530">                            subIterator = null;</span>
                        }
                    }
                }

                public ModifiableRealmIdentity next() {
<span class="nc bnc" id="L536" title="All 2 branches missed.">                    if (! hasNext()) {</span>
<span class="nc" id="L537">                        throw new NoSuchElementException();</span>
                    }
<span class="nc" id="L539">                    return subIterator.next();</span>
                }

                public void close() throws RealmUnavailableException {
                    try {
<span class="nc bnc" id="L544" title="All 2 branches missed.">                        if (subIterator != null) subIterator.close();</span>
                    } finally {
                        try {
<span class="nc" id="L547">                            stream.close();</span>
<span class="nc" id="L548">                        } catch (IOException e) {</span>
<span class="nc" id="L549">                            ElytronMessages.log.debug(&quot;Unable to close the stream&quot;, e);</span>
<span class="nc" id="L550">                        }</span>
                    }
<span class="nc" id="L552">                }</span>
            };
        }
    }

    public SupportLevel getCredentialAcquireSupport(final Class&lt;? extends Credential&gt; credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) throws RealmUnavailableException {
<span class="nc" id="L558">        return SupportLevel.POSSIBLY_SUPPORTED;</span>
    }

    public SupportLevel getEvidenceVerifySupport(final Class&lt;? extends Evidence&gt; evidenceType, final String algorithmName) throws RealmUnavailableException {
<span class="nc" id="L562">        return SupportLevel.POSSIBLY_SUPPORTED;</span>
    }

    private IdentitySharedExclusiveLock getRealmIdentityLockForName(final String name) {
<span class="fc" id="L566">        IdentitySharedExclusiveLock realmIdentityLock = realmIdentityLocks.get(name);</span>
<span class="fc bfc" id="L567" title="All 2 branches covered.">        if (realmIdentityLock == null) {</span>
<span class="fc" id="L568">            final IdentitySharedExclusiveLock newRealmIdentityLock = new IdentitySharedExclusiveLock();</span>
<span class="fc" id="L569">            realmIdentityLock = realmIdentityLocks.putIfAbsent(name, newRealmIdentityLock);</span>
<span class="pc bpc" id="L570" title="1 of 2 branches missed.">            if (realmIdentityLock == null) {</span>
<span class="fc" id="L571">                realmIdentityLock = newRealmIdentityLock;</span>
            }
        }
<span class="fc" id="L574">        return realmIdentityLock;</span>
    }

    @FunctionalInterface
    interface CredentialParseFunction {
        void parseCredential(String algorithm, String format, String body) throws RealmUnavailableException, XMLStreamException;
    }

    /**
     * Re-generate the signatures for all the identities in this realm.
     * This method is intended to be called after updating the key pair used by this realm.
     *
     * @throws RealmUnavailableException if the realm is not able to handle requests for any reason
     */
    public void updateRealmKeyPair() throws RealmUnavailableException {
<span class="nc bnc" id="L589" title="All 2 branches missed.">        if (! hasIntegrityEnabled()) {</span>
<span class="nc" id="L590">            throw ElytronMessages.log.integrityNotEnabled(root.toString());</span>
        }
<span class="nc" id="L592">        ModifiableRealmIdentityIterator realmIterator = this.getRealmIdentityIterator();</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">        while (realmIterator.hasNext()) {</span>
<span class="nc" id="L594">            Identity identity = (Identity) realmIterator.next();</span>
            try{
<span class="nc" id="L596">                identity.writeDigitalSignature(identity.path, identity.name);</span>
            } finally {
<span class="nc" id="L598">                identity.dispose();</span>
            }
<span class="nc" id="L600">        }</span>
<span class="nc" id="L601">        realmIterator.close();</span>
<span class="nc" id="L602">    }</span>

    /**
     * Verify the integrity of each identity file in this realm.
     * @return {@code true} if the integrity of all the identity files in the realm is successfully verified and {@code false} otherwise
     *
     */
    public IntegrityResult verifyRealmIntegrity() throws RealmUnavailableException {
<span class="nc bnc" id="L610" title="All 2 branches missed.">        if (! hasIntegrityEnabled()) {</span>
<span class="nc" id="L611">            throw ElytronMessages.log.integrityNotEnabled(root.toString());</span>
        }
<span class="nc" id="L613">        ArrayList&lt;String&gt; failedIdentities = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L614">        ModifiableRealmIdentityIterator realmIterator = this.getRealmIdentityIterator();</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">        while (realmIterator.hasNext()) {</span>
<span class="nc" id="L616">            Identity identity = (Identity) realmIterator.next();</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">            if(! identity.isIntegrityValid()) {</span>
<span class="nc" id="L618">                failedIdentities.add(identity.name);</span>
            }
<span class="nc" id="L620">            identity.dispose();</span>
<span class="nc" id="L621">        }</span>
<span class="nc" id="L622">        realmIterator.close();</span>
<span class="nc" id="L623">        return new IntegrityResult(failedIdentities.isEmpty(), failedIdentities);</span>
    }

    static class Identity implements ModifiableRealmIdentity {

        private static final String ENCRYPTION_FORMAT = &quot;enc_base64&quot;;
        private static final String BASE64_FORMAT = &quot;base64&quot;;
        private static final String MCF_FORMAT = &quot;crypt&quot;;
        private static final String X509_FORMAT = &quot;X.509&quot;;
        private static final String HEX = &quot;hex&quot;;

        private final String name;
        private final Path path;
        private final Supplier&lt;Provider[]&gt; providers;
        private IdentityLock lock;
        private final Charset hashCharset;
        private final Encoding hashEncoding;
        private final SecretKey secretKey;
        private final PrivateKey privateKey;
        private final PublicKey publicKey;
        private final boolean integrityEnabled;

<span class="fc" id="L645">        Identity(final String name, final Path path, final IdentityLock lock, final Charset hashCharset, final Encoding hashEncoding, Supplier&lt;Provider[]&gt; providers, final SecretKey secretKey, final PrivateKey privateKey, final PublicKey publicKey, final boolean integrityEnabled) {</span>
<span class="fc" id="L646">            this.name = name;</span>
<span class="fc" id="L647">            this.path = path;</span>
<span class="fc" id="L648">            this.lock = lock;</span>
<span class="fc" id="L649">            this.hashCharset = hashCharset;</span>
<span class="fc" id="L650">            this.hashEncoding = hashEncoding;</span>
<span class="fc" id="L651">            this.providers = providers;</span>
<span class="fc" id="L652">            this.secretKey = secretKey;</span>
<span class="fc" id="L653">            this.privateKey = privateKey;</span>
<span class="fc" id="L654">            this.publicKey = publicKey;</span>
<span class="fc" id="L655">            this.integrityEnabled = integrityEnabled;</span>
<span class="fc" id="L656">        }</span>

        public Principal getRealmIdentityPrincipal() {
<span class="nc" id="L659">            return new NamePrincipal(name);</span>
        }

        public SupportLevel getCredentialAcquireSupport(final Class&lt;? extends Credential&gt; credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) throws RealmUnavailableException {
<span class="nc" id="L663">            Assert.checkNotNullParam(&quot;credentialType&quot;, credentialType);</span>
<span class="nc" id="L664">            List&lt;Credential&gt; credentials = loadCredentials();</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">            for (Credential credential : credentials) {</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">                if (credential.matches(credentialType, algorithmName, parameterSpec)) {</span>
<span class="nc" id="L667">                    return SupportLevel.SUPPORTED;</span>
                }
<span class="nc" id="L669">            }</span>
<span class="nc" id="L670">            return SupportLevel.UNSUPPORTED;</span>
        }

        public &lt;C extends Credential&gt; C getCredential(final Class&lt;C&gt; credentialType) throws RealmUnavailableException {
<span class="nc" id="L674">            return getCredential(credentialType, null);</span>
        }

        public &lt;C extends Credential&gt; C getCredential(final Class&lt;C&gt; credentialType, final String algorithmName) throws RealmUnavailableException {
<span class="nc" id="L678">            return getCredential(credentialType, algorithmName, null);</span>
        }

        public &lt;C extends Credential&gt; C getCredential(final Class&lt;C&gt; credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) throws RealmUnavailableException {
<span class="nc" id="L682">            Assert.checkNotNullParam(&quot;credentialType&quot;, credentialType);</span>
<span class="nc" id="L683">            List&lt;Credential&gt; credentials = loadCredentials();</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">            for (Credential credential : credentials) {</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">                if (credential.matches(credentialType, algorithmName, parameterSpec)) {</span>
<span class="nc" id="L686">                    return credentialType.cast(credential.clone());</span>
                }
<span class="nc" id="L688">            }</span>
<span class="nc" id="L689">            return null;</span>
        }

        public SupportLevel getEvidenceVerifySupport(final Class&lt;? extends Evidence&gt; evidenceType, final String algorithmName) throws RealmUnavailableException {
<span class="nc" id="L693">            Assert.checkNotNullParam(&quot;evidenceType&quot;, evidenceType);</span>
<span class="nc" id="L694">            List&lt;Credential&gt; credentials = loadCredentials();</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">            for (Credential credential : credentials) {</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">                if (credential.canVerify(evidenceType, algorithmName)) {</span>
<span class="nc" id="L697">                    ElytronMessages.log.tracef(&quot;FileSystemSecurityRealm - evidence verification SUPPORTED: type = [%s]  algorithm = [%s]  credentials = [%d]&quot;, evidenceType, algorithmName, credentials.size());</span>
<span class="nc" id="L698">                    return SupportLevel.SUPPORTED;</span>
                }
<span class="nc" id="L700">            }</span>
<span class="nc" id="L701">            ElytronMessages.log.tracef(&quot;FileSystemSecurityRealm - evidence verification UNSUPPORTED: type = [%s]  algorithm = [%s]  credentials = [%d]&quot;, evidenceType, algorithmName, credentials.size());</span>
<span class="nc" id="L702">            return SupportLevel.UNSUPPORTED;</span>
        }

        public boolean verifyEvidence(final Evidence evidence) throws RealmUnavailableException {
<span class="nc" id="L706">            Assert.checkNotNullParam(&quot;evidence&quot;, evidence);</span>

<span class="nc bnc" id="L708" title="All 2 branches missed.">            if (ElytronMessages.log.isTraceEnabled()) {</span>
                try {
<span class="nc" id="L710">                    final LoadedIdentity loadedIdentity = loadIdentity(false, true);</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">                    ElytronMessages.log.tracef(&quot;Trying to authenticate identity %s using FileSystemSecurityRealm&quot;, (loadedIdentity != null) ? loadedIdentity.getName() : &quot;null&quot;);</span>
<span class="nc" id="L712">                } catch (RealmUnavailableException e) {</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">                    if (e.getCause() instanceof IntegrityException) {</span>
<span class="nc" id="L714">                        return false;</span>
                    }
<span class="nc" id="L716">                    throw e;</span>
<span class="nc" id="L717">                }</span>
            }
<span class="nc" id="L719">            List&lt;Credential&gt; credentials = null;</span>
            try {
<span class="nc" id="L721">                credentials = loadCredentials();</span>
<span class="nc" id="L722">            } catch (RealmUnavailableException e) {</span>
<span class="nc bnc" id="L723" title="All 2 branches missed.">                if (e.getCause() instanceof IntegrityException) {</span>
<span class="nc" id="L724">                    return false;</span>
                }
<span class="nc" id="L726">                throw e;</span>
<span class="nc" id="L727">            }</span>
<span class="nc" id="L728">            ElytronMessages.log.tracef(&quot;FileSystemSecurityRealm - verification evidence [%s] against [%d] credentials...&quot;, evidence, credentials.size());</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">            for (Credential credential : credentials) {</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">                if (credential.canVerify(evidence)) {</span>
<span class="nc" id="L731">                    boolean verified = false;</span>
<span class="nc bnc" id="L732" title="All 2 branches missed.">                    if (credential instanceof PasswordCredential) {</span>
<span class="nc" id="L733">                        verified = ((PasswordCredential )credential).verify(providers, evidence, hashCharset);</span>
                    } else {
<span class="nc" id="L735">                        verified = credential.verify(providers, evidence);</span>
                    }
<span class="nc" id="L737">                    ElytronMessages.log.tracef(&quot;FileSystemSecurityRealm - verification against credential [%s] = %b&quot;, credential, verified);</span>
<span class="nc" id="L738">                    return verified;</span>
                }
<span class="nc" id="L740">            }</span>
<span class="nc" id="L741">            ElytronMessages.log.tracef(&quot;FileSystemSecurityRealm - no credential able to verify evidence [%s]&quot;, evidence);</span>
<span class="nc" id="L742">            return false;</span>
        }

        List&lt;Credential&gt; loadCredentials() throws RealmUnavailableException {
<span class="nc" id="L746">            final LoadedIdentity loadedIdentity = loadIdentity(false, true);</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">            return loadedIdentity == null ? Collections.emptyList() : loadedIdentity.getCredentials();</span>
        }

        public boolean exists() throws RealmUnavailableException {
<span class="pc bpc" id="L751" title="1 of 2 branches missed.">            if (System.getSecurityManager() == null) {</span>
<span class="fc" id="L752">                return Files.exists(path);</span>
            }
<span class="nc" id="L754">            return AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; Files.exists(path));</span>
        }

        public void delete() throws RealmUnavailableException {
<span class="nc bnc" id="L758" title="All 2 branches missed.">            if (System.getSecurityManager() == null) {</span>
<span class="nc" id="L759">                deletePrivileged();</span>
<span class="nc" id="L760">                return;</span>
            }
            try {
<span class="nc" id="L763">                AccessController.doPrivileged((PrivilegedExceptionAction&lt;Void&gt;) this::deletePrivileged);</span>
<span class="nc" id="L764">            } catch (PrivilegedActionException e) {</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">                if (e.getException() instanceof RealmUnavailableException) {</span>
<span class="nc" id="L766">                    throw (RealmUnavailableException) e.getException();</span>
                }
<span class="nc" id="L768">                throw new RuntimeException(e.getException());</span>
<span class="nc" id="L769">            }</span>
<span class="nc" id="L770">        }</span>

        private Void deletePrivileged() throws RealmUnavailableException {
            try {
<span class="nc" id="L774">                Files.delete(path);</span>
<span class="nc" id="L775">                return null;</span>
<span class="nc" id="L776">            } catch (NoSuchFileException e) {</span>
<span class="nc" id="L777">                throw ElytronMessages.log.fileSystemRealmNotFound(name);</span>
<span class="nc" id="L778">            } catch (IOException e) {</span>
<span class="nc" id="L779">                throw ElytronMessages.log.fileSystemRealmDeleteFailed(name, e);</span>
            }
        }

        private String tempSuffix() {
<span class="fc" id="L784">            final ThreadLocalRandom random = ThreadLocalRandom.current();</span>
<span class="fc" id="L785">            char[] array = new char[12];</span>
<span class="fc bfc" id="L786" title="All 2 branches covered.">            for (int i = 0; i &lt; array.length; i ++) {</span>
<span class="fc" id="L787">                int idx = random.nextInt(36);</span>
<span class="fc bfc" id="L788" title="All 2 branches covered.">                if (idx &lt; 26) {</span>
<span class="fc" id="L789">                    array[i] = (char) ('A' + idx);</span>
                } else {
<span class="fc" id="L791">                    array[i] = (char) ('0' + idx - 26);</span>
                }
            }
<span class="fc" id="L794">            return new String(array);</span>
        }

        private Path tempPath() {
<span class="fc" id="L798">            Path parent = path.getParent();</span>
<span class="fc" id="L799">            File file = parent.toFile();</span>
<span class="fc bfc" id="L800" title="All 2 branches covered.">            if (!file.exists()) {</span>
<span class="fc" id="L801">                file.mkdirs();</span>
            }
<span class="fc" id="L803">            return parent.resolve(path.getFileName().toString() + '.' + tempSuffix());</span>
        }

        public void create() throws RealmUnavailableException {
<span class="pc bpc" id="L807" title="1 of 2 branches missed.">            if (System.getSecurityManager() == null) {</span>
<span class="fc" id="L808">                createPrivileged();</span>
<span class="fc" id="L809">                return;</span>
            }
            try {
<span class="nc" id="L812">                AccessController.doPrivileged((PrivilegedExceptionAction&lt;Void&gt;) this::createPrivileged);</span>
<span class="nc" id="L813">            } catch (PrivilegedActionException e) {</span>
<span class="nc bnc" id="L814" title="All 2 branches missed.">                if (e.getException() instanceof RealmUnavailableException) {</span>
<span class="nc" id="L815">                    throw (RealmUnavailableException) e.getException();</span>
                }
<span class="nc" id="L817">                throw new RuntimeException(e.getException());</span>
<span class="nc" id="L818">            }</span>
<span class="nc" id="L819">        }</span>

        private Void createPrivileged() throws RealmUnavailableException {
            for (;;) {
<span class="fc" id="L823">                final Path tempPath = tempPath();</span>
<span class="fc" id="L824">                final XMLOutputFactory xmlOutputFactory = XMLOutputFactory.newFactory();</span>
<span class="fc" id="L825">                try (OutputStream outputStream = new BufferedOutputStream(Files.newOutputStream(tempPath, WRITE, CREATE_NEW, DSYNC))) {</span>
<span class="fc" id="L826">                    try (AutoCloseableXMLStreamWriterHolder holder = new AutoCloseableXMLStreamWriterHolder(xmlOutputFactory.createXMLStreamWriter(outputStream))) {</span>
<span class="fc" id="L827">                        String namespace = &quot;&quot;;</span>
<span class="pc bpc" id="L828" title="1 of 2 branches missed.">                        if (integrityEnabled) {</span>
<span class="nc" id="L829">                            namespace = Version.VERSION_1_2.getNamespace();</span>
<span class="pc bpc" id="L830" title="1 of 2 branches missed.">                        } else if (secretKey != null) {</span>
<span class="nc" id="L831">                            namespace = Version.VERSION_1_1.getNamespace();</span>
                        } else {
<span class="fc" id="L833">                            namespace = Version.VERSION_1_0.getNamespace();</span>
                        }
<span class="fc" id="L835">                        final XMLStreamWriter streamWriter = holder.getXmlStreamWriter();</span>
                        // create empty identity
<span class="fc" id="L837">                        streamWriter.writeStartDocument();</span>
<span class="fc" id="L838">                        streamWriter.writeCharacters(&quot;\n&quot;);</span>
<span class="fc" id="L839">                        streamWriter.writeStartElement(&quot;identity&quot;);</span>
<span class="fc" id="L840">                        streamWriter.writeDefaultNamespace(namespace);</span>
<span class="pc bpc" id="L841" title="1 of 2 branches missed.">                        if (integrityEnabled) {</span>
<span class="nc" id="L842">                            streamWriter.writeCharacters(&quot;\n    &quot;);</span>
<span class="nc" id="L843">                            streamWriter.writeStartElement(&quot;principal&quot;);</span>
<span class="nc bnc" id="L844" title="All 2 branches missed.">                            streamWriter.writeAttribute(&quot;name&quot;, secretKey != null ? CipherUtil.encrypt(name, secretKey) : name);</span>
<span class="nc" id="L845">                            streamWriter.writeEndElement();</span>
<span class="nc" id="L846">                            streamWriter.writeCharacters(&quot;\n    &quot;);</span>
                        }
<span class="fc" id="L848">                        streamWriter.writeEndElement();</span>
<span class="fc" id="L849">                        streamWriter.writeEndDocument();</span>
<span class="nc" id="L850">                    } catch (XMLStreamException | GeneralSecurityException e) {</span>
<span class="nc" id="L851">                        throw ElytronMessages.log.fileSystemRealmFailedToWrite(tempPath, name, e);</span>
<span class="fc" id="L852">                    }</span>
<span class="pc bpc" id="L853" title="1 of 2 branches missed.">                    if(integrityEnabled) {</span>
                        try {
<span class="nc" id="L855">                            writeDigitalSignature(tempPath, this.name);</span>
<span class="nc" id="L856">                        } catch (RealmUnavailableException e) {</span>
<span class="nc" id="L857">                            throw ElytronMessages.log.unableToGenerateSignature(path.toString());</span>
<span class="nc" id="L858">                        }</span>
                    }
<span class="nc" id="L860">                } catch (FileAlreadyExistsException ignored) {</span>
                    // try a new name
<span class="nc" id="L862">                    continue;</span>
<span class="nc" id="L863">                } catch (IOException e) {</span>
<span class="nc" id="L864">                    throw ElytronMessages.log.fileSystemRealmFailedToOpen(tempPath, name, e);</span>
<span class="fc" id="L865">                }</span>
                try {
<span class="fc" id="L867">                    Files.createLink(path, tempPath);</span>
<span class="nc" id="L868">                } catch (FileAlreadyExistsException e) {</span>
                    try {
<span class="nc" id="L870">                        Files.delete(tempPath);</span>
<span class="nc" id="L871">                    } catch (IOException e2) {</span>
<span class="nc" id="L872">                        e.addSuppressed(e2);</span>
<span class="nc" id="L873">                    }</span>
<span class="nc" id="L874">                    throw ElytronMessages.log.fileSystemRealmAlreadyExists(name, e);</span>
<span class="nc" id="L875">                } catch (IOException e) {</span>
<span class="nc" id="L876">                    throw ElytronMessages.log.fileSystemRealmFailedToWrite(tempPath, name, e);</span>
<span class="fc" id="L877">                }</span>
                try {
<span class="fc" id="L879">                    Files.delete(tempPath);</span>
<span class="nc" id="L880">                } catch (IOException ignored) {</span>
                    // nothing we can do
<span class="fc" id="L882">                }</span>
<span class="fc" id="L883">                return null;</span>
            }
        }

        public void setCredentials(final Collection&lt;? extends Credential&gt; credentials) throws RealmUnavailableException {
<span class="nc" id="L888">            Assert.checkNotNullParam(&quot;credential&quot;, credentials);</span>
<span class="nc" id="L889">            final LoadedIdentity loadedIdentity = loadIdentity(false, false);</span>
<span class="nc bnc" id="L890" title="All 2 branches missed.">            if (loadedIdentity == null) {</span>
<span class="nc" id="L891">                throw ElytronMessages.log.fileSystemRealmNotFound(name);</span>
            }

<span class="nc" id="L894">            final LoadedIdentity newIdentity = new LoadedIdentity(name, new ArrayList&lt;&gt;(credentials), loadedIdentity.getAttributes(), hashEncoding);</span>
<span class="nc" id="L895">            replaceIdentity(newIdentity);</span>
<span class="nc" id="L896">        }</span>

        public void setAttributes(final Attributes attributes) throws RealmUnavailableException {
<span class="fc" id="L899">            Assert.checkNotNullParam(&quot;attributes&quot;, attributes);</span>
<span class="fc" id="L900">            final LoadedIdentity loadedIdentity = loadIdentity(false, true);</span>
<span class="pc bpc" id="L901" title="1 of 2 branches missed.">            if (loadedIdentity == null) {</span>
<span class="nc" id="L902">                throw ElytronMessages.log.fileSystemRealmNotFound(name);</span>
            }
<span class="fc" id="L904">            final LoadedIdentity newIdentity = new LoadedIdentity(name, loadedIdentity.getCredentials(), attributes, hashEncoding);</span>
<span class="fc" id="L905">            replaceIdentity(newIdentity);</span>
<span class="fc" id="L906">        }</span>

        @Override
        public Attributes getAttributes() throws RealmUnavailableException {
<span class="nc" id="L910">            final LoadedIdentity loadedIdentity = loadIdentity(true, false);</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">            if (loadedIdentity == null) {</span>
<span class="nc" id="L912">                throw ElytronMessages.log.fileSystemRealmNotFound(name);</span>
            }
<span class="nc" id="L914">            return loadedIdentity.getAttributes().asReadOnly();</span>
        }

        private void replaceIdentity(final LoadedIdentity newIdentity) throws RealmUnavailableException {
<span class="pc bpc" id="L918" title="1 of 2 branches missed.">            if (System.getSecurityManager() == null) {</span>
<span class="fc" id="L919">                replaceIdentityPrivileged(newIdentity);</span>
<span class="fc" id="L920">                return;</span>
            }
            try {
<span class="nc" id="L923">                AccessController.doPrivileged((PrivilegedExceptionAction&lt;Void&gt;) () -&gt; replaceIdentityPrivileged(newIdentity));</span>
<span class="nc" id="L924">            } catch (PrivilegedActionException e) {</span>
<span class="nc bnc" id="L925" title="All 2 branches missed.">                if (e.getException() instanceof RealmUnavailableException) {</span>
<span class="nc" id="L926">                    throw (RealmUnavailableException) e.getException();</span>
                }
<span class="nc" id="L928">                throw new RuntimeException(e.getException());</span>
<span class="nc" id="L929">            }</span>
<span class="nc" id="L930">        }</span>

        private Void replaceIdentityPrivileged(final LoadedIdentity newIdentity) throws RealmUnavailableException {
<span class="pc bpc" id="L933" title="1 of 2 branches missed.">            if (!isIntegrityValid()) {</span>
<span class="nc" id="L934">                throw new RealmUnavailableException(ElytronMessages.log.invalidIdentitySignature(name));</span>
            }
            for (;;) {
<span class="fc" id="L937">                final Path tempPath = tempPath();</span>
                try {
<span class="fc" id="L939">                    final XMLOutputFactory xmlOutputFactory = XMLOutputFactory.newFactory();</span>
<span class="fc" id="L940">                    try (OutputStream outputStream = new BufferedOutputStream(Files.newOutputStream(tempPath, WRITE, CREATE_NEW, DSYNC))) {</span>
<span class="fc" id="L941">                        try (AutoCloseableXMLStreamWriterHolder holder = new AutoCloseableXMLStreamWriterHolder(xmlOutputFactory.createXMLStreamWriter(outputStream))) {</span>
<span class="fc" id="L942">                            writeIdentity(holder.getXmlStreamWriter(), newIdentity);</span>
<span class="nc" id="L943">                        } catch (XMLStreamException | InvalidKeySpecException | NoSuchAlgorithmException | CertificateEncodingException e) {</span>
<span class="nc" id="L944">                            throw ElytronMessages.log.fileSystemRealmFailedToWrite(tempPath, name, e);</span>
<span class="nc" id="L945">                        } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L946">                            throw ElytronMessages.log.fileSystemRealmEncryptionFailed(e);</span>
<span class="fc" id="L947">                        }</span>
<span class="pc bpc" id="L948" title="1 of 2 branches missed.">                        if (integrityEnabled) {</span>
                            try {
<span class="nc" id="L950">                                writeDigitalSignature(tempPath, name);</span>
<span class="nc" id="L951">                            } catch (RealmUnavailableException e) {</span>
<span class="nc" id="L952">                                throw ElytronMessages.log.unableToGenerateSignature(path.toString());</span>
<span class="nc" id="L953">                            }</span>
                        }
<span class="nc" id="L955">                    } catch (FileAlreadyExistsException ignored) {</span>
                        // try a new name
<span class="nc" id="L957">                        continue;</span>
<span class="nc" id="L958">                    } catch (IOException e) {</span>
                        try {
<span class="nc" id="L960">                            Files.deleteIfExists(tempPath);</span>
<span class="nc" id="L961">                        } catch (IOException e2) {</span>
<span class="nc" id="L962">                            e.addSuppressed(e2);</span>
<span class="nc" id="L963">                        }</span>
<span class="nc" id="L964">                        throw ElytronMessages.log.fileSystemRealmFailedToOpen(tempPath, name, e);</span>
<span class="fc" id="L965">                    }</span>
                    try {
<span class="fc" id="L967">                        Files.delete(path);</span>
<span class="nc" id="L968">                    } catch (IOException e) {</span>
<span class="nc" id="L969">                        throw ElytronMessages.log.fileSystemUpdatedFailed(path.toAbsolutePath().toString(), e);</span>
<span class="fc" id="L970">                    }</span>
                    try {
<span class="fc" id="L972">                        Files.createLink(path, tempPath);</span>
<span class="nc" id="L973">                    } catch (FileAlreadyExistsException e) {</span>
                        try {
<span class="nc" id="L975">                            Files.deleteIfExists(tempPath);</span>
<span class="nc" id="L976">                        } catch (IOException e2) {</span>
<span class="nc" id="L977">                            e.addSuppressed(e2);</span>
<span class="nc" id="L978">                        }</span>
<span class="nc" id="L979">                        throw ElytronMessages.log.fileSystemRealmAlreadyExists(name, e);</span>
<span class="nc" id="L980">                    } catch (IOException e) {</span>
<span class="nc" id="L981">                        throw ElytronMessages.log.fileSystemRealmFailedToWrite(tempPath, name, e);</span>
<span class="fc" id="L982">                    }</span>
                    try {
<span class="fc" id="L984">                        Files.delete(tempPath);</span>
<span class="nc" id="L985">                    } catch (IOException ignored) {</span>
                        // nothing we can do
<span class="fc" id="L987">                    }</span>
<span class="fc" id="L988">                    return null;</span>
<span class="nc" id="L989">                } catch (Throwable t) {</span>
                    try {
<span class="nc" id="L991">                        Files.delete(tempPath);</span>
<span class="nc" id="L992">                    } catch (IOException e) {</span>
<span class="nc" id="L993">                        t.addSuppressed(e);</span>
<span class="nc" id="L994">                    }</span>
<span class="nc" id="L995">                    throw t;</span>
                }
            }
        }

        private Version requiredVersion(final LoadedIdentity identityToWrite) {
            // As new functionality is added we will identify if we need to use a later version
            // if new functionality is used then use the required schema version otherwise fallback
            // to an older version.

<span class="pc bpc" id="L1005" title="1 of 2 branches missed.">            if (integrityEnabled) {</span>
<span class="nc" id="L1006">                return Version.VERSION_1_2;</span>
<span class="pc bpc" id="L1007" title="1 of 2 branches missed.">            } else if (secretKey != null) {</span>
<span class="nc" id="L1008">                return Version.VERSION_1_1;</span>
            } else {
<span class="fc" id="L1010">                return Version.VERSION_1_0;</span>
            }
        }

        private void writeIdentity(final XMLStreamWriter streamWriter, final LoadedIdentity newIdentity) throws XMLStreamException, InvalidKeySpecException, NoSuchAlgorithmException, GeneralSecurityException {
<span class="fc" id="L1015">            streamWriter.writeStartDocument();</span>
<span class="fc" id="L1016">            streamWriter.writeCharacters(&quot;\n&quot;);</span>
<span class="fc" id="L1017">            streamWriter.writeStartElement(&quot;identity&quot;);</span>
<span class="fc" id="L1018">            streamWriter.writeDefaultNamespace(requiredVersion(newIdentity).getNamespace());</span>

<span class="pc bpc" id="L1020" title="1 of 2 branches missed.">            if (integrityEnabled) {</span>
<span class="nc" id="L1021">                streamWriter.writeCharacters(&quot;\n    &quot;);</span>
<span class="nc" id="L1022">                streamWriter.writeStartElement(&quot;principal&quot;);</span>
<span class="nc bnc" id="L1023" title="All 2 branches missed.">                streamWriter.writeAttribute(&quot;name&quot;, secretKey != null ? CipherUtil.encrypt(name, secretKey) : name);</span>
<span class="nc" id="L1024">                streamWriter.writeEndElement();</span>
            }

<span class="pc bpc" id="L1027" title="1 of 2 branches missed.">            if (newIdentity.getCredentials().size() &gt; 0) {</span>
<span class="nc" id="L1028">                streamWriter.writeCharacters(&quot;\n    &quot;);</span>
<span class="nc" id="L1029">                streamWriter.writeStartElement(&quot;credentials&quot;);</span>
<span class="nc bnc" id="L1030" title="All 2 branches missed.">                for (Credential credential : newIdentity.getCredentials()) {</span>
<span class="nc" id="L1031">                    streamWriter.writeCharacters(&quot;\n        &quot;);</span>
<span class="nc bnc" id="L1032" title="All 2 branches missed.">                    if (credential instanceof PasswordCredential) {</span>
<span class="nc" id="L1033">                        Password password = ((PasswordCredential) credential).getPassword();</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">                        if (password instanceof OneTimePassword) {</span>
<span class="nc" id="L1035">                            final OneTimePassword otp = (OneTimePassword) password;</span>
<span class="nc" id="L1036">                            streamWriter.writeStartElement(&quot;otp&quot;);</span>
<span class="nc" id="L1037">                            streamWriter.writeAttribute(&quot;algorithm&quot;, otp.getAlgorithm());</span>
<span class="nc" id="L1038">                            streamWriter.writeAttribute(&quot;hash&quot;, ByteIterator.ofBytes(otp.getHash()).base64Encode().drainToString());</span>
<span class="nc" id="L1039">                            streamWriter.writeAttribute(&quot;seed&quot;, ByteIterator.ofBytes(otp.getSeed().getBytes(StandardCharsets.US_ASCII)).base64Encode().drainToString());</span>
<span class="nc" id="L1040">                            streamWriter.writeAttribute(&quot;sequence&quot;, Integer.toString(otp.getSequenceNumber()));</span>
<span class="nc" id="L1041">                            streamWriter.writeEndElement();</span>
<span class="nc" id="L1042">                        } else {</span>
<span class="nc" id="L1043">                            streamWriter.writeStartElement(&quot;password&quot;);</span>
                            String format;
<span class="nc" id="L1045">                            String algorithm = password.getAlgorithm();</span>
                            String passwordString;
<span class="nc" id="L1047">                            byte[] encoded = BasicPasswordSpecEncoding.encode(password, providers);</span>

<span class="nc bnc" id="L1049" title="All 2 branches missed.">                            if (secretKey != null) {</span>
<span class="nc" id="L1050">                                format = ENCRYPTION_FORMAT;</span>
<span class="nc" id="L1051">                                passwordString = ByteIterator.ofBytes(CipherUtil.encrypt(encoded, secretKey)).base64Encode().drainToString();</span>
<span class="nc bnc" id="L1052" title="All 2 branches missed.">                            } else if (encoded != null) {</span>
<span class="nc bnc" id="L1053" title="All 2 branches missed.">                                if (newIdentity.getHashEncoding() == Encoding.HEX) {</span>
<span class="nc" id="L1054">                                    format = HEX;</span>
<span class="nc" id="L1055">                                    passwordString = ByteIterator.ofBytes(encoded).hexEncode().drainToString();</span>
                                } else {
                                    // default to base64
<span class="nc" id="L1058">                                    format = BASE64_FORMAT;</span>
<span class="nc" id="L1059">                                    passwordString = ByteIterator.ofBytes(encoded).base64Encode().drainToString();</span>
                                }
                            } else {
<span class="nc" id="L1062">                                format = MCF_FORMAT;</span>
<span class="nc" id="L1063">                                passwordString = ModularCrypt.encodeAsString(password);</span>
                            }

<span class="nc" id="L1066">                            streamWriter.writeAttribute(&quot;algorithm&quot;, algorithm);</span>
<span class="nc" id="L1067">                            streamWriter.writeAttribute(&quot;format&quot;, format);</span>
<span class="nc" id="L1068">                            streamWriter.writeCharacters(passwordString);</span>
<span class="nc" id="L1069">                            streamWriter.writeEndElement();</span>
                        }
                    }
<span class="nc" id="L1072">                }</span>
<span class="nc" id="L1073">                streamWriter.writeCharacters(&quot;\n    &quot;);</span>
<span class="nc" id="L1074">                streamWriter.writeEndElement();</span>
            }
<span class="fc" id="L1076">            final Iterator&lt;Attributes.Entry&gt; entryIter = newIdentity.getAttributes().entries().iterator();</span>
<span class="pc bpc" id="L1077" title="1 of 2 branches missed.">            if (entryIter.hasNext()) {</span>
<span class="fc" id="L1078">                streamWriter.writeCharacters(&quot;\n    &quot;);</span>
<span class="fc" id="L1079">                streamWriter.writeStartElement(&quot;attributes&quot;);</span>
                do {
<span class="fc" id="L1081">                    final Attributes.Entry entry = entryIter.next();</span>
<span class="fc bfc" id="L1082" title="All 2 branches covered.">                    for (String value : entry) {</span>
<span class="fc" id="L1083">                        streamWriter.writeCharacters(&quot;\n        &quot;);</span>
<span class="fc" id="L1084">                        streamWriter.writeStartElement(&quot;attribute&quot;);</span>
<span class="pc bpc" id="L1085" title="1 of 2 branches missed.">                        streamWriter.writeAttribute(&quot;name&quot;, secretKey != null ? CipherUtil.encrypt(entry.getKey(), secretKey) : entry.getKey());</span>
<span class="pc bpc" id="L1086" title="1 of 2 branches missed.">                        streamWriter.writeAttribute(&quot;value&quot;, secretKey != null ? CipherUtil.encrypt(value, secretKey) : value);</span>
<span class="fc" id="L1087">                        streamWriter.writeEndElement();</span>
<span class="fc" id="L1088">                    }</span>
<span class="fc bfc" id="L1089" title="All 2 branches covered.">                } while (entryIter.hasNext());</span>
<span class="fc" id="L1090">                streamWriter.writeCharacters(&quot;\n    &quot;);</span>
<span class="fc" id="L1091">                streamWriter.writeEndElement();</span>
<span class="fc" id="L1092">                streamWriter.writeCharacters(&quot;\n&quot;);</span>
            }
<span class="fc" id="L1094">            streamWriter.writeCharacters(&quot;\n    &quot;);</span>
<span class="fc" id="L1095">            streamWriter.writeEndElement();</span>
<span class="fc" id="L1096">            streamWriter.writeEndDocument();</span>
<span class="fc" id="L1097">        }</span>

        public void dispose() {
            // Release the lock for this realm identity
<span class="fc" id="L1101">            IdentityLock identityLock = lock;</span>
<span class="fc" id="L1102">            lock = null;</span>
<span class="pc bpc" id="L1103" title="1 of 2 branches missed.">            if (identityLock != null) {</span>
<span class="fc" id="L1104">                identityLock.release();</span>
            }
<span class="fc" id="L1106">        }</span>

        public AuthorizationIdentity getAuthorizationIdentity() throws RealmUnavailableException {
<span class="fc" id="L1109">            final LoadedIdentity loadedIdentity = loadIdentity(true, false);</span>
<span class="fc bfc" id="L1110" title="All 2 branches covered.">            return loadedIdentity == null ? AuthorizationIdentity.EMPTY : AuthorizationIdentity.basicIdentity(loadedIdentity.getAttributes());</span>
        }

        private LoadedIdentity loadIdentity(final boolean skipCredentials, final boolean skipAttributes) throws RealmUnavailableException {
<span class="pc bpc" id="L1114" title="1 of 2 branches missed.">            if (System.getSecurityManager() == null) {</span>
<span class="fc" id="L1115">                return loadIdentityPrivileged(skipCredentials, skipAttributes);</span>
            }
            try {
<span class="nc" id="L1118">                return AccessController.doPrivileged((PrivilegedExceptionAction&lt;LoadedIdentity&gt;) () -&gt; loadIdentityPrivileged(skipCredentials, skipAttributes));</span>
<span class="nc" id="L1119">            } catch (PrivilegedActionException e) {</span>
<span class="nc bnc" id="L1120" title="All 2 branches missed.">                if (e.getException() instanceof RealmUnavailableException) {</span>
<span class="nc" id="L1121">                    throw (RealmUnavailableException) e.getException();</span>
                }
<span class="nc" id="L1123">                throw new RuntimeException(e.getException());</span>
            }
        }

        protected LoadedIdentity loadIdentityPrivileged(final boolean skipCredentials, final boolean skipAttributes) throws RealmUnavailableException {
<span class="pc bpc" id="L1128" title="1 of 2 branches missed.">            if (!isIntegrityValid()) {</span>
<span class="nc" id="L1129">                throw new RealmUnavailableException(ElytronMessages.log.invalidIdentitySignature(name));</span>
            }
<span class="fc" id="L1131">            try (InputStream inputStream = Files.newInputStream(path, READ)) {</span>
<span class="fc" id="L1132">                final XMLInputFactory inputFactory = XMLInputFactory.newFactory();</span>
<span class="fc" id="L1133">                inputFactory.setProperty(XMLInputFactory.IS_VALIDATING, Boolean.FALSE);</span>
<span class="fc" id="L1134">                inputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, Boolean.FALSE);</span>
<span class="fc" id="L1135">                inputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);</span>
<span class="fc" id="L1136">                inputFactory.setProperty(XMLInputFactory.IS_COALESCING, Boolean.TRUE);</span>
<span class="fc" id="L1137">                try (final AutoCloseableXMLStreamReaderHolder holder = new AutoCloseableXMLStreamReaderHolder(inputFactory.createXMLStreamReader(inputStream, &quot;UTF-8&quot;))) {</span>
<span class="fc" id="L1138">                    final XMLStreamReader streamReader = holder.getXmlStreamReader();</span>
<span class="fc" id="L1139">                    return parseIdentity(streamReader, skipCredentials, skipAttributes);</span>
<span class="nc" id="L1140">                } catch (XMLStreamException e) {</span>
<span class="nc" id="L1141">                    throw ElytronMessages.log.fileSystemRealmFailedToRead(path, name, e);</span>
                }
<span class="fc" id="L1143">            } catch (NoSuchFileException | FileNotFoundException ignored) {</span>
<span class="fc" id="L1144">                return null;</span>
<span class="nc" id="L1145">            } catch (IOException e) {</span>
<span class="nc" id="L1146">                throw ElytronMessages.log.fileSystemRealmFailedToOpen(path, name, e);</span>
            }
        }

        private LoadedIdentity parseIdentity(final XMLStreamReader streamReader, final boolean skipCredentials, final boolean skipAttributes) throws RealmUnavailableException, XMLStreamException {
<span class="fc" id="L1151">            final int tag = streamReader.nextTag();</span>
            Version version;
<span class="pc bpc" id="L1153" title="3 of 6 branches missed.">            if (tag != START_ELEMENT || ((version = identifyVersion(streamReader)) == null) || ! &quot;identity&quot;.equals(streamReader.getLocalName())) {</span>
<span class="nc" id="L1154">                throw ElytronMessages.log.fileSystemRealmInvalidContent(path, streamReader.getLocation().getLineNumber(), name);</span>
            }
<span class="fc" id="L1156">            return parseIdentityContents(streamReader, version, skipCredentials, skipAttributes);</span>
        }

        private Version identifyVersion(final XMLStreamReader streamReader) {
<span class="fc" id="L1160">            return KNOWN_NAMESPACES.get(streamReader.getNamespaceURI());</span>
        }

        private LoadedIdentity parseIdentityContents(final XMLStreamReader streamReader, final Version version, final boolean skipCredentials, final boolean skipAttributes) throws RealmUnavailableException, XMLStreamException {
<span class="fc" id="L1164">            final int attributeCount = streamReader.getAttributeCount();</span>
<span class="pc bpc" id="L1165" title="1 of 2 branches missed.">            if (attributeCount &gt; 0) {</span>
<span class="nc" id="L1166">                throw ElytronMessages.log.fileSystemRealmInvalidContent(path, streamReader.getLocation().getLineNumber(), name);</span>
            }
<span class="fc" id="L1168">            List&lt;Credential&gt; credentials = Collections.emptyList();</span>
<span class="fc" id="L1169">            Attributes attributes = Attributes.EMPTY;</span>
<span class="fc" id="L1170">            boolean gotCredentials = false;</span>
<span class="fc" id="L1171">            boolean gotAttributes = false;</span>
            for (;;) {
<span class="fc bfc" id="L1173" title="All 2 branches covered.">                if (streamReader.isEndElement()) {</span>
<span class="pc bpc" id="L1174" title="1 of 4 branches missed.">                    if (attributes == Attributes.EMPTY &amp;&amp; !skipAttributes) {</span>
                        // Since this could be a use-case wanting to modify the attributes, make sure that we have a
                        // modifiable version of Attributes;
<span class="nc" id="L1177">                        attributes = new MapAttributes();</span>
                    }
<span class="fc" id="L1179">                    return new LoadedIdentity(name, credentials, attributes, hashEncoding);</span>
                }
<span class="pc bpc" id="L1181" title="3 of 4 branches missed.">                if (!(version.getNamespace().equals(streamReader.getNamespaceURI())) &amp;&amp; !(XMLSignature.XMLNS.equals(streamReader.getNamespaceURI()))) {</span>
                    // Mixed versions unsupported.
<span class="nc" id="L1183">                    throw ElytronMessages.log.fileSystemRealmInvalidContent(path, streamReader.getLocation().getLineNumber(), name);</span>
                }

<span class="pc bpc" id="L1186" title="1 of 2 branches missed.">                if (&quot;principal&quot;.equals(streamReader.getLocalName())) {</span>
<span class="nc bnc" id="L1187" title="All 2 branches missed.">                    if (version.isAtLeast(Version.VERSION_1_2)) {</span>
<span class="nc" id="L1188">                        consumeContent(streamReader);</span>
                    } else {
<span class="nc" id="L1190">                        throw ElytronMessages.log.fileSystemRealmInvalidContent(path, streamReader.getLocation().getLineNumber(), name);</span>
                    }
                }

<span class="pc bpc" id="L1194" title="2 of 4 branches missed.">                if (! gotCredentials &amp;&amp; &quot;credentials&quot;.equals(streamReader.getLocalName())) {</span>
<span class="nc" id="L1195">                    gotCredentials = true;</span>
<span class="nc bnc" id="L1196" title="All 2 branches missed.">                    if (skipCredentials) {</span>
<span class="nc" id="L1197">                        consumeContent(streamReader);</span>
                    } else {
<span class="nc" id="L1199">                        credentials = parseCredentials(streamReader, version);</span>
                    }
<span class="pc bpc" id="L1201" title="1 of 4 branches missed.">                } else if (! gotAttributes &amp;&amp; &quot;attributes&quot;.equals(streamReader.getLocalName())) {</span>
<span class="fc" id="L1202">                    gotAttributes = true;</span>
<span class="pc bpc" id="L1203" title="1 of 2 branches missed.">                    if (skipAttributes) {</span>
<span class="nc" id="L1204">                        consumeContent(streamReader);</span>
                    } else {
<span class="fc" id="L1206">                        attributes = parseAttributes(streamReader, version);</span>
                    }
                }
<span class="fc" id="L1209">                streamReader.nextTag();</span>
            }
        }

        private List&lt;Credential&gt; parseCredentials(final XMLStreamReader streamReader, final Version version) throws RealmUnavailableException, XMLStreamException {
<span class="nc" id="L1214">            final int attributeCount = streamReader.getAttributeCount();</span>
<span class="nc bnc" id="L1215" title="All 2 branches missed.">            if (attributeCount &gt; 0) {</span>
<span class="nc" id="L1216">                throw ElytronMessages.log.fileSystemRealmInvalidContent(path, streamReader.getLocation().getLineNumber(), name);</span>
            }
<span class="nc bnc" id="L1218" title="All 2 branches missed.">            if (streamReader.nextTag() == END_ELEMENT) {</span>
<span class="nc" id="L1219">                return Collections.emptyList();</span>
            }
<span class="nc" id="L1221">            List&lt;Credential&gt; credentials = new ArrayList&lt;&gt;();</span>
            do {
<span class="nc bnc" id="L1223" title="All 2 branches missed.">                if (! version.getNamespace().equals(streamReader.getNamespaceURI()) ) {</span>
                    // Mixed versions unsupported.
<span class="nc" id="L1225">                    throw ElytronMessages.log.fileSystemRealmInvalidContent(path, streamReader.getLocation().getLineNumber(), name);</span>
                }
<span class="nc bnc" id="L1227" title="All 2 branches missed.">                if (&quot;password&quot;.equals(streamReader.getLocalName())) {</span>
<span class="nc" id="L1228">                    parsePassword(credentials, streamReader, version);</span>
<span class="nc bnc" id="L1229" title="All 2 branches missed.">                } else if (&quot;public-key&quot;.equals(streamReader.getLocalName())) {</span>
<span class="nc" id="L1230">                    parsePublicKey(credentials, streamReader);</span>
<span class="nc bnc" id="L1231" title="All 2 branches missed.">                } else if (&quot;certificate&quot;.equals(streamReader.getLocalName())) {</span>
<span class="nc" id="L1232">                    parseCertificate(credentials, streamReader);</span>
<span class="nc bnc" id="L1233" title="All 2 branches missed.">                } else if (&quot;otp&quot;.equals(streamReader.getLocalName())) {</span>
<span class="nc" id="L1234">                    parseOtp(credentials, streamReader);</span>
                } else {
<span class="nc" id="L1236">                    throw ElytronMessages.log.fileSystemRealmInvalidContent(path, streamReader.getLocation().getLineNumber(), name);</span>
                }
<span class="nc bnc" id="L1238" title="All 2 branches missed.">            } while (streamReader.nextTag() != END_ELEMENT);</span>
<span class="nc" id="L1239">            return credentials;</span>
        }

        private void parseCredential(final XMLStreamReader streamReader, CredentialParseFunction function) throws RealmUnavailableException, XMLStreamException {
<span class="nc" id="L1243">            final int attributeCount = streamReader.getAttributeCount();</span>
<span class="nc" id="L1244">            String name = null;</span>
<span class="nc" id="L1245">            String algorithm = null;</span>
<span class="nc" id="L1246">            String format = null;</span>
<span class="nc bnc" id="L1247" title="All 2 branches missed.">            for (int i = 0; i &lt; attributeCount; i ++) {</span>
<span class="nc" id="L1248">                String namespace = streamReader.getAttributeNamespace(i);</span>
<span class="nc bnc" id="L1249" title="All 4 branches missed.">                if (namespace != null &amp;&amp; !namespace.equals(&quot;&quot;)) {</span>
<span class="nc" id="L1250">                    throw ElytronMessages.log.fileSystemRealmInvalidContent(path, streamReader.getLocation().getLineNumber(), name);</span>
                }
<span class="nc" id="L1252">                final String localName = streamReader.getAttributeLocalName(i);</span>
<span class="nc bnc" id="L1253" title="All 2 branches missed.">                if (&quot;name&quot;.equals(localName)) {</span>
<span class="nc" id="L1254">                    name = streamReader.getAttributeValue(i);</span>
<span class="nc bnc" id="L1255" title="All 2 branches missed.">                } else if (&quot;algorithm&quot;.equals(localName)) {</span>
<span class="nc" id="L1256">                    algorithm = streamReader.getAttributeValue(i);</span>
<span class="nc bnc" id="L1257" title="All 2 branches missed.">                } else if (&quot;format&quot;.equals(localName)) {</span>
<span class="nc" id="L1258">                    format = streamReader.getAttributeValue(i);</span>
                } else {
<span class="nc" id="L1260">                    throw ElytronMessages.log.fileSystemRealmInvalidContent(path, streamReader.getLocation().getLineNumber(), name);</span>
                }
            }
<span class="nc" id="L1263">            final String text = streamReader.getElementText().trim();</span>
<span class="nc" id="L1264">            function.parseCredential(algorithm, format, text);</span>
<span class="nc" id="L1265">        }</span>

        private void parseCertificate(final List&lt;Credential&gt; credentials, final XMLStreamReader streamReader) throws RealmUnavailableException, XMLStreamException {
<span class="nc" id="L1268">            parseCredential(streamReader, (algorithm, format, text) -&gt; {</span>
<span class="nc bnc" id="L1269" title="All 2 branches missed.">                if (algorithm == null) algorithm = &quot;X.509&quot;;</span>
<span class="nc bnc" id="L1270" title="All 2 branches missed.">                if (format == null) format = X509_FORMAT;</span>
                try {
<span class="nc" id="L1272">                    final CertificateFactory certificateFactory = CertificateFactory.getInstance(algorithm);</span>
<span class="nc" id="L1273">                    credentials.add(new X509CertificateChainPublicCredential((X509Certificate) certificateFactory.generateCertificate(</span>
<span class="nc" id="L1274">                        CodePointIterator.ofString(text).base64Decode().asInputStream())));</span>
<span class="nc" id="L1275">                } catch (CertificateException | ClassCastException e) {</span>
<span class="nc" id="L1276">                    throw ElytronMessages.log.fileSystemRealmCertificateReadError(format, path, streamReader.getLocation().getLineNumber(), name);</span>
<span class="nc" id="L1277">                }</span>
<span class="nc" id="L1278">            });</span>
<span class="nc" id="L1279">        }</span>

        private void parsePublicKey(final List&lt;Credential&gt; credentials, final XMLStreamReader streamReader) throws RealmUnavailableException, XMLStreamException {
<span class="nc" id="L1282">            parseCredential(streamReader, (algorithm, format, text) -&gt; {</span>
<span class="nc bnc" id="L1283" title="All 2 branches missed.">                if (algorithm == null) {</span>
<span class="nc" id="L1284">                    throw ElytronMessages.log.fileSystemRealmMissingAttribute(&quot;algorithm&quot;, path, streamReader.getLocation().getLineNumber(), name);</span>
                }
<span class="nc bnc" id="L1286" title="All 2 branches missed.">                if (format == null) {</span>
<span class="nc" id="L1287">                    format = X509_FORMAT;</span>
<span class="nc bnc" id="L1288" title="All 2 branches missed.">                } else if (!X509_FORMAT.equals(format)) {</span>
<span class="nc" id="L1289">                    throw ElytronMessages.log.fileSystemRealmUnsupportedKeyFormat(format, path, streamReader.getLocation().getLineNumber(), name);</span>
                }
                try {
<span class="nc" id="L1292">                    KeyFactory keyFactory = KeyFactory.getInstance(algorithm);</span>
<span class="nc" id="L1293">                    credentials.add(new PublicKeyCredential(keyFactory.generatePublic(new PKCS8EncodedKeySpec(CodePointIterator.ofString(text).base64Decode().drain()))));</span>
<span class="nc" id="L1294">                } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L1295">                    throw ElytronMessages.log.fileSystemRealmUnsupportedKeyAlgorithm(format, path, streamReader.getLocation().getLineNumber(), name, e);</span>
<span class="nc" id="L1296">                } catch (InvalidKeySpecException e) {</span>
<span class="nc" id="L1297">                    throw ElytronMessages.log.fileSystemRealmUnsupportedKeyFormat(format, path, streamReader.getLocation().getLineNumber(), name);</span>
<span class="nc" id="L1298">                }</span>
<span class="nc" id="L1299">            });</span>
<span class="nc" id="L1300">        }</span>

        private void parsePassword(final List&lt;Credential&gt; credentials, final XMLStreamReader streamReader, final Version version) throws XMLStreamException, RealmUnavailableException {
<span class="nc" id="L1303">            parseCredential(streamReader, (algorithm, format, text) -&gt; {</span>
                try {
<span class="nc bnc" id="L1305" title="All 2 branches missed.">                    if (ENCRYPTION_FORMAT.equals(format)) {</span>
<span class="nc bnc" id="L1306" title="All 2 branches missed.">                        if (! version.isAtLeast(Version.VERSION_1_1)) {</span>
<span class="nc" id="L1307">                            throw ElytronMessages.log.fileSystemRealmInvalidContent(path, streamReader.getLocation().getLineNumber(), name);</span>
                        }
<span class="nc bnc" id="L1309" title="All 2 branches missed.">                        if (algorithm == null) {</span>
<span class="nc" id="L1310">                            throw ElytronMessages.log.fileSystemRealmMissingAttribute(&quot;algorithm&quot;, path, streamReader.getLocation().getLineNumber(), name);</span>
                        }
<span class="nc" id="L1312">                        PasswordFactory passwordFactory = PasswordFactory.getInstance(algorithm, providers);</span>
<span class="nc" id="L1313">                        byte[] encryptedPasswordBytes = CodePointIterator.ofChars(text.toCharArray()).base64Decode().drain();</span>
                        byte[] decryptedPasswordBytes;
                        try {
<span class="nc" id="L1316">                            decryptedPasswordBytes = CipherUtil.decrypt(encryptedPasswordBytes, secretKey);</span>
<span class="nc" id="L1317">                        } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L1318">                            throw ElytronMessages.log.fileSystemRealmDecryptionFailed(e);</span>
<span class="nc" id="L1319">                        }</span>
<span class="nc" id="L1320">                        PasswordSpec passwordSpec = BasicPasswordSpecEncoding.decode(decryptedPasswordBytes);</span>

<span class="nc bnc" id="L1322" title="All 2 branches missed.">                        if (passwordSpec != null) {</span>
<span class="nc" id="L1323">                            credentials.add(new PasswordCredential(passwordFactory.generatePassword(passwordSpec)));</span>
                        } else {
<span class="nc" id="L1325">                            throw ElytronMessages.log.fileSystemRealmInvalidPasswordAlgorithm(algorithm, path, streamReader.getLocation().getLineNumber(), name);</span>
                        }
<span class="nc bnc" id="L1327" title="All 4 branches missed.">                    } else if (BASE64_FORMAT.equals(format) || HEX.equals(format)) {</span>
<span class="nc bnc" id="L1328" title="All 2 branches missed.">                        if (algorithm == null) {</span>
<span class="nc" id="L1329">                            throw ElytronMessages.log.fileSystemRealmMissingAttribute(&quot;algorithm&quot;, path, streamReader.getLocation().getLineNumber(), name);</span>
                        }
<span class="nc" id="L1331">                        PasswordFactory passwordFactory = PasswordFactory.getInstance(algorithm, providers);</span>
                        byte[] passwordBytes;
<span class="nc bnc" id="L1333" title="All 2 branches missed.">                        if (BASE64_FORMAT.equals(format)) {</span>
<span class="nc" id="L1334">                            passwordBytes = CodePointIterator.ofChars(text.toCharArray()).base64Decode().drain();</span>
                        } else {
<span class="nc" id="L1336">                            passwordBytes = CodePointIterator.ofChars(text.toCharArray()).hexDecode().drain();</span>
                        }
<span class="nc" id="L1338">                        PasswordSpec passwordSpec = BasicPasswordSpecEncoding.decode(passwordBytes);</span>

<span class="nc bnc" id="L1340" title="All 2 branches missed.">                        if (passwordSpec != null) {</span>
<span class="nc" id="L1341">                            credentials.add(new PasswordCredential(passwordFactory.generatePassword(passwordSpec)));</span>
                        } else {
<span class="nc" id="L1343">                            throw ElytronMessages.log.fileSystemRealmInvalidPasswordAlgorithm(algorithm, path, streamReader.getLocation().getLineNumber(), name);</span>
                        }
<span class="nc bnc" id="L1345" title="All 2 branches missed.">                    } else if (MCF_FORMAT.equals(format)) {</span>
<span class="nc" id="L1346">                        credentials.add(new PasswordCredential(ModularCrypt.decode(text)));</span>
                    } else {
<span class="nc" id="L1348">                        throw ElytronMessages.log.fileSystemRealmInvalidPasswordFormat(format, path, streamReader.getLocation().getLineNumber(), name);</span>
                    }
<span class="nc" id="L1350">                } catch (InvalidKeySpecException | NoSuchAlgorithmException e) {</span>
<span class="nc" id="L1351">                    throw ElytronMessages.log.fileSystemRealmInvalidContent(path, streamReader.getLocation().getLineNumber(), name);</span>
<span class="nc" id="L1352">                }</span>
<span class="nc" id="L1353">            });</span>
<span class="nc" id="L1354">        }</span>

        private void parseOtp(final List&lt;Credential&gt; credentials, final XMLStreamReader streamReader) throws XMLStreamException, RealmUnavailableException {
<span class="nc" id="L1357">            String name = null;</span>
<span class="nc" id="L1358">            String algorithm = null;</span>
<span class="nc" id="L1359">            byte[] hash = null;</span>
<span class="nc" id="L1360">            String seed = null;</span>
<span class="nc" id="L1361">            int sequenceNumber = 0;</span>

<span class="nc" id="L1363">            final int attributeCount = streamReader.getAttributeCount();</span>
<span class="nc bnc" id="L1364" title="All 2 branches missed.">            for (int i = 0; i &lt; attributeCount; i ++) {</span>
<span class="nc" id="L1365">                String namespace = streamReader.getAttributeNamespace(i);</span>
<span class="nc bnc" id="L1366" title="All 4 branches missed.">                if (namespace != null &amp;&amp; !namespace.equals(&quot;&quot;)) {</span>
<span class="nc" id="L1367">                    throw ElytronMessages.log.fileSystemRealmInvalidContent(path, streamReader.getLocation().getLineNumber(), name);</span>
                }
<span class="nc" id="L1369">                final String localName = streamReader.getAttributeLocalName(i);</span>
<span class="nc bnc" id="L1370" title="All 2 branches missed.">                if (&quot;name&quot;.equals(localName)) {</span>
<span class="nc" id="L1371">                    name = streamReader.getAttributeValue(i);</span>
<span class="nc bnc" id="L1372" title="All 2 branches missed.">                } else if (&quot;algorithm&quot;.equals(localName)) {</span>
<span class="nc" id="L1373">                    algorithm = streamReader.getAttributeValue(i);</span>
<span class="nc bnc" id="L1374" title="All 2 branches missed.">                } else if (&quot;hash&quot;.equals(localName)) {</span>
<span class="nc" id="L1375">                    hash = CodePointIterator.ofString(streamReader.getAttributeValue(i)).base64Decode(Base64Alphabet.STANDARD, false).drain();</span>
<span class="nc bnc" id="L1376" title="All 2 branches missed.">                } else if (&quot;seed&quot;.equals(localName)) {</span>
<span class="nc" id="L1377">                    seed = new String(CodePointIterator.ofString(streamReader.getAttributeValue(i)).base64Decode(Base64Alphabet.STANDARD, false).drain(), StandardCharsets.US_ASCII);</span>
<span class="nc bnc" id="L1378" title="All 2 branches missed.">                } else if (&quot;sequence&quot;.equals(localName)) {</span>
<span class="nc" id="L1379">                    sequenceNumber = Integer.parseInt(streamReader.getAttributeValue(i));</span>
                } else {
<span class="nc" id="L1381">                    throw ElytronMessages.log.fileSystemRealmInvalidContent(path, streamReader.getLocation().getLineNumber(), name);</span>
                }
            }

<span class="nc bnc" id="L1385" title="All 2 branches missed.">            if (streamReader.nextTag() != END_ELEMENT) {</span>
<span class="nc" id="L1386">                throw ElytronMessages.log.fileSystemRealmInvalidContent(path, streamReader.getLocation().getLineNumber(), name);</span>
            }

            try {
<span class="nc bnc" id="L1390" title="All 2 branches missed.">                if (algorithm == null) {</span>
<span class="nc" id="L1391">                    throw ElytronMessages.log.fileSystemRealmMissingAttribute(&quot;algorithm&quot;, path, streamReader.getLocation().getLineNumber(), name);</span>
                }
<span class="nc" id="L1393">                PasswordFactory passwordFactory = PasswordFactory.getInstance(algorithm, providers);</span>
<span class="nc" id="L1394">                Password password = passwordFactory.generatePassword(new OneTimePasswordSpec(hash, seed, sequenceNumber));</span>
<span class="nc" id="L1395">                credentials.add(new PasswordCredential(password));</span>
<span class="nc" id="L1396">            } catch (InvalidKeySpecException e) {</span>
<span class="nc" id="L1397">                throw ElytronMessages.log.fileSystemRealmInvalidOtpDefinition(path, streamReader.getLocation().getLineNumber(), name, e);</span>
<span class="nc" id="L1398">            } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L1399">                throw ElytronMessages.log.fileSystemRealmInvalidOtpAlgorithm(algorithm, path, streamReader.getLocation().getLineNumber(), name, e);</span>
<span class="nc" id="L1400">            }</span>
<span class="nc" id="L1401">        }</span>

        private Attributes parseAttributes(final XMLStreamReader streamReader, final Version version) throws RealmUnavailableException, XMLStreamException {
<span class="fc" id="L1404">            final int attributeCount = streamReader.getAttributeCount();</span>
<span class="pc bpc" id="L1405" title="1 of 2 branches missed.">            if (attributeCount &gt; 0) {</span>
<span class="nc" id="L1406">                throw ElytronMessages.log.fileSystemRealmInvalidContent(path, streamReader.getLocation().getLineNumber(), name);</span>
            }
<span class="fc" id="L1408">            int tag = streamReader.nextTag();</span>
<span class="pc bpc" id="L1409" title="1 of 2 branches missed.">            if (tag == END_ELEMENT) {</span>
<span class="nc" id="L1410">                return Attributes.EMPTY;</span>
            }
<span class="fc" id="L1412">            Attributes attributes = new MapAttributes();</span>
            do {
<span class="pc bpc" id="L1414" title="1 of 2 branches missed.">                if (! version.getNamespace().equals(streamReader.getNamespaceURI()) ) {</span>

                    // Mixed versions unsupported.
<span class="nc" id="L1417">                    throw ElytronMessages.log.fileSystemRealmInvalidContent(path, streamReader.getLocation().getLineNumber(), name);</span>
                }
<span class="pc bpc" id="L1419" title="1 of 2 branches missed.">                if (&quot;attribute&quot;.equals(streamReader.getLocalName())) {</span>
<span class="fc" id="L1420">                    parseAttribute(streamReader, attributes);</span>
                } else {
<span class="nc" id="L1422">                    throw ElytronMessages.log.fileSystemRealmInvalidContent(path, streamReader.getLocation().getLineNumber(), name);</span>
                }
<span class="fc bfc" id="L1424" title="All 2 branches covered.">            } while (streamReader.nextTag() == START_ELEMENT);</span>
<span class="fc" id="L1425">            return attributes;</span>
        }

        private void parseAttribute(final XMLStreamReader streamReader, final Attributes attributes) throws XMLStreamException, RealmUnavailableException {
<span class="fc" id="L1429">            String name = null;</span>
<span class="fc" id="L1430">            String value = null;</span>
<span class="fc" id="L1431">            final int attributeCount = streamReader.getAttributeCount();</span>
<span class="fc bfc" id="L1432" title="All 2 branches covered.">            for (int i = 0; i &lt; attributeCount; i++) {</span>
<span class="fc" id="L1433">                String namespace = streamReader.getAttributeNamespace(i);</span>
<span class="pc bpc" id="L1434" title="3 of 4 branches missed.">                if (namespace != null &amp;&amp; !namespace.equals(&quot;&quot;)) {</span>
<span class="nc" id="L1435">                    throw ElytronMessages.log.fileSystemRealmInvalidContent(path, streamReader.getLocation().getLineNumber(), this.name);</span>
                }
<span class="fc bfc" id="L1437" title="All 2 branches covered.">                if (&quot;name&quot;.equals(streamReader.getAttributeLocalName(i))) {</span>
<span class="fc" id="L1438">                    name = streamReader.getAttributeValue(i);</span>
<span class="pc bpc" id="L1439" title="1 of 2 branches missed.">                } else if (&quot;value&quot;.equals(streamReader.getAttributeLocalName(i))) {</span>
<span class="fc" id="L1440">                    value = streamReader.getAttributeValue(i);</span>
                } else {
<span class="nc" id="L1442">                    throw ElytronMessages.log.fileSystemRealmInvalidContent(path, streamReader.getLocation().getLineNumber(), this.name);</span>
                }
            }
<span class="pc bpc" id="L1445" title="1 of 2 branches missed.">            if (name == null) {</span>
<span class="nc" id="L1446">                throw ElytronMessages.log.fileSystemRealmMissingAttribute(&quot;name&quot;, path, streamReader.getLocation().getLineNumber(), this.name);</span>
            }
<span class="pc bpc" id="L1448" title="1 of 2 branches missed.">            if (value == null) {</span>
<span class="nc" id="L1449">                throw ElytronMessages.log.fileSystemRealmMissingAttribute(&quot;value&quot;, path, streamReader.getLocation().getLineNumber(), this.name);</span>
            }
<span class="pc bpc" id="L1451" title="1 of 2 branches missed.">            if (secretKey != null) {</span>
                try {
<span class="nc" id="L1453">                    attributes.addLast(CipherUtil.decrypt(name, secretKey), CipherUtil.decrypt(value, secretKey));</span>
<span class="nc" id="L1454">                } catch (GeneralSecurityException e){</span>
<span class="nc" id="L1455">                    throw ElytronMessages.log.fileSystemRealmDecryptionFailed(e);</span>
<span class="nc" id="L1456">                }</span>
            } else {
<span class="fc" id="L1458">                attributes.addLast(name, value);</span>
            }
<span class="pc bpc" id="L1460" title="1 of 2 branches missed.">            if (streamReader.nextTag() != END_ELEMENT) {</span>
<span class="nc" id="L1461">                throw ElytronMessages.log.fileSystemRealmInvalidContent(path, streamReader.getLocation().getLineNumber(), this.name);</span>
            }
<span class="fc" id="L1463">        }</span>

        private void consumeContent(final XMLStreamReader reader) throws XMLStreamException {
<span class="nc bnc" id="L1466" title="All 2 branches missed.">            while (reader.hasNext()) {</span>
<span class="nc bnc" id="L1467" title="All 3 branches missed.">                switch (reader.next()) {</span>
                    case START_ELEMENT: {
<span class="nc" id="L1469">                        consumeContent(reader);</span>
<span class="nc" id="L1470">                        break;</span>
                    }
                    case END_ELEMENT: {
<span class="nc" id="L1473">                        return;</span>
                    }
                }
            }
<span class="nc" id="L1477">        }</span>

        private boolean isIntegrityValid() {
<span class="pc bpc" id="L1480" title="1 of 2 branches missed.">            if (this.publicKey != null) {</span>
<span class="nc" id="L1481">                DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span>
<span class="nc" id="L1482">                dbf.setNamespaceAware(true);</span>
                Document doc;
                try {
<span class="nc" id="L1485">                    doc = dbf.newDocumentBuilder().parse(path.toString());</span>
<span class="nc" id="L1486">                } catch (SAXException | IOException | ParserConfigurationException e) {</span>
<span class="nc" id="L1487">                    return false;</span>
<span class="nc" id="L1488">                }</span>
<span class="nc bnc" id="L1489" title="All 4 branches missed.">                return (validatePrincipalName(doc) &amp;&amp; validateDigitalSignature(doc));</span>
            }
<span class="fc" id="L1491">            return true;</span>
        }

        // Process for updating identity:
        // 1. Validate current identity digital signature
        // 2. Update identity with new data
        // 3. Create new digital signature
        private boolean validateDigitalSignature(Document doc) {
            try {
<span class="nc" id="L1500">                NodeList nl = doc.getElementsByTagNameNS(XMLSignature.XMLNS, &quot;Signature&quot;);</span>
<span class="nc bnc" id="L1501" title="All 2 branches missed.">                if (nl.getLength() == 0) {</span>
<span class="nc" id="L1502">                    throw ElytronMessages.log.cannotFindSignature(path.toString());</span>
                }
<span class="nc" id="L1504">                XMLSignatureFactory fac = XMLSignatureFactory.getInstance(&quot;DOM&quot;);</span>
<span class="nc" id="L1505">                DOMValidateContext valContext = new DOMValidateContext(publicKey, nl.item(0));</span>
<span class="nc" id="L1506">                XMLSignature signature = fac.unmarshalXMLSignature(valContext);</span>
<span class="nc" id="L1507">                boolean coreValidity = signature.validate(valContext);</span>
<span class="nc" id="L1508">                ElytronMessages.log.tracef(&quot;FileSystemSecurityRealm - verification against signature for credential [%s] = %b&quot;, name, coreValidity);</span>
<span class="nc" id="L1509">                return coreValidity;</span>
<span class="nc" id="L1510">           } catch (IOException | MarshalException | XMLSignatureException e) {</span>
<span class="nc" id="L1511">                ElytronMessages.log.tracef(&quot;FileSystemSecurityRealm - Error during verification. Signature for credential [%s] failed&quot;, name);</span>
<span class="nc" id="L1512">                return false;</span>
            }
        }

        private boolean validatePrincipalName(Document doc) {
<span class="nc" id="L1517">            NodeList nl = doc.getElementsByTagName(&quot;principal&quot;);</span>
<span class="nc bnc" id="L1518" title="All 2 branches missed.">            if (nl.getLength() == 0) {</span>
<span class="nc" id="L1519">                ElytronMessages.log.tracef(&quot;FileSystemSecurityRealm - verification against principal for credential [%s] = %b&quot;, name, false);</span>
<span class="nc" id="L1520">                return false;</span>
            }
<span class="nc" id="L1522">            String principalName = nl.item(0).getAttributes().getNamedItem(&quot;name&quot;).getNodeValue();</span>
<span class="nc bnc" id="L1523" title="All 2 branches missed.">            if (secretKey != null) {</span>
                try {
<span class="nc" id="L1525">                    principalName = CipherUtil.decrypt(principalName, secretKey);</span>
<span class="nc" id="L1526">                } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L1527">                    ElytronMessages.log.tracef(&quot;FileSystemSecurityRealm - verification against principal for credential [%s] = %b&quot;, name, false);</span>
<span class="nc" id="L1528">                    return false;</span>
<span class="nc" id="L1529">                }</span>
            }
<span class="nc" id="L1531">            boolean validity = Objects.equals(principalName, name);</span>
<span class="nc" id="L1532">            ElytronMessages.log.tracef(&quot;FileSystemSecurityRealm - verification against principal for credential [%s] = %b&quot;, name, validity);</span>
<span class="nc" id="L1533">            return validity;</span>
        }

        private void writeDigitalSignature(Path path, String name) throws RealmUnavailableException {
            try {
<span class="nc" id="L1538">                DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span>
<span class="nc" id="L1539">                dbf.setNamespaceAware(true);</span>
<span class="nc" id="L1540">                DocumentBuilder builder = dbf.newDocumentBuilder();</span>
<span class="nc" id="L1541">                Document doc = builder.parse(Files.newInputStream(path));</span>
<span class="nc" id="L1542">                Element elem = doc.getDocumentElement();</span>
<span class="nc" id="L1543">                NodeList signatureNode = doc.getElementsByTagName(&quot;Signature&quot;);</span>
<span class="nc bnc" id="L1544" title="All 2 branches missed.">                if (signatureNode.getLength() &gt; 0) {</span>
<span class="nc" id="L1545">                    Node sig = signatureNode.item(0);</span>
<span class="nc" id="L1546">                    elem.removeChild(sig);</span>
                }
<span class="nc" id="L1548">                DOMSignContext dsc = new DOMSignContext(this.privateKey, elem);</span>
<span class="nc" id="L1549">                XMLSignatureFactory fac = XMLSignatureFactory.getInstance(&quot;DOM&quot;);</span>
<span class="nc" id="L1550">                Reference ref = fac.newReference</span>
<span class="nc" id="L1551">                        (&quot;&quot;, fac.newDigestMethod(DigestMethod.SHA256, null),</span>
                                Collections.singletonList
<span class="nc" id="L1553">                                        (fac.newTransform(Transform.ENVELOPED,</span>
                                                (TransformParameterSpec) null)), null, null);
<span class="nc" id="L1555">                String signatureMethod = &quot;&quot;;</span>
                // https://issues.redhat.com/browse/ELY-2346
                // Once JDK 8 support is removed use the javax.xml.crypto.dsig.SignatureMethod to set these signatureMethods
<span class="nc bnc" id="L1558" title="All 5 branches missed.">                switch (this.publicKey.getAlgorithm()) {</span>
                    case &quot;DSA&quot;:
<span class="nc" id="L1560">                        signatureMethod = &quot;http://www.w3.org/2009/xmldsig11#dsa-sha256&quot;;</span>
<span class="nc" id="L1561">                        break;</span>
                    case &quot;RSA&quot;:
<span class="nc" id="L1563">                        signatureMethod = &quot;http://www.w3.org/2001/04/xmldsig-more#rsa-sha256&quot;;</span>
<span class="nc" id="L1564">                        break;</span>
                    case &quot;HMAC&quot;:
<span class="nc" id="L1566">                        signatureMethod = &quot;http://www.w3.org/2001/04/xmldsig-more#hmac-sha256&quot;;</span>
<span class="nc" id="L1567">                        break;</span>
                    case &quot;EC&quot;:
<span class="nc" id="L1569">                        signatureMethod = &quot;http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256&quot;;</span>
                        break;
                }
<span class="nc" id="L1572">                SignedInfo si = fac.newSignedInfo</span>
<span class="nc" id="L1573">                        (fac.newCanonicalizationMethod</span>
<span class="nc" id="L1574">                                        (CanonicalizationMethod.INCLUSIVE,</span>
                                                (C14NMethodParameterSpec) null),
<span class="nc" id="L1576">                                fac.newSignatureMethod(signatureMethod, null),</span>
<span class="nc" id="L1577">                                Collections.singletonList(ref));</span>
<span class="nc" id="L1578">                KeyInfoFactory kif = fac.getKeyInfoFactory();</span>
<span class="nc" id="L1579">                KeyValue kv = kif.newKeyValue(this.publicKey);</span>
<span class="nc" id="L1580">                KeyInfo ki = kif.newKeyInfo(Collections.singletonList(kv));</span>
<span class="nc" id="L1581">                XMLSignature signature = fac.newXMLSignature(si, ki);</span>
<span class="nc" id="L1582">                signature.sign(dsc);</span>
<span class="nc" id="L1583">                TransformerFactory transformerFactory = TransformerFactory.newInstance();</span>
<span class="nc" id="L1584">                Transformer transformer = transformerFactory.newTransformer();</span>
<span class="nc" id="L1585">                DOMSource source = new DOMSource(doc);</span>
<span class="nc" id="L1586">                FileWriter writer = new FileWriter(String.valueOf(path));</span>
<span class="nc" id="L1587">                StreamResult result = new StreamResult(writer);</span>
<span class="nc" id="L1588">                transformer.transform(source, result);</span>
<span class="nc" id="L1589">                ElytronMessages.log.tracef(&quot;FileSystemSecurityRealm - signature against file updated [%s]&quot;, name);</span>
<span class="nc" id="L1590">                writer.close();</span>
<span class="nc" id="L1591">            } catch (ParserConfigurationException | IOException | NoSuchAlgorithmException | InvalidAlgorithmParameterException |</span>
                    KeyException | XMLSignatureException | MarshalException | TransformerException | SAXException e) {
<span class="nc" id="L1593">                ElytronMessages.log.tracef(&quot;FileSystemSecurityRealm - Error during signature generation against identity [%s]&quot;, name);</span>
<span class="nc" id="L1594">                throw ElytronMessages.log.unableToGenerateSignature(String.valueOf(this.path));</span>
<span class="nc" id="L1595">            }</span>
<span class="nc" id="L1596">        }</span>
    }

    protected static final class LoadedIdentity {
        private final String name;
        private final List&lt;Credential&gt; credentials;
        private final Attributes attributes;
        private final Encoding hashEncoding;

<span class="fc" id="L1605">        LoadedIdentity(final String name, final List&lt;Credential&gt; credentials, final Attributes attributes, final Encoding hashEncoding) {</span>
<span class="fc" id="L1606">            this.name = name;</span>
<span class="fc" id="L1607">            this.credentials = credentials;</span>
<span class="fc" id="L1608">            this.attributes = attributes;</span>
<span class="fc" id="L1609">            this.hashEncoding = hashEncoding;</span>
<span class="fc" id="L1610">        }</span>

        public String getName() {
<span class="nc" id="L1613">            return name;</span>
        }

        public Attributes getAttributes() {
<span class="fc" id="L1617">            return attributes;</span>
        }

        List&lt;Credential&gt; getCredentials() {
<span class="fc" id="L1621">            return credentials;</span>
        }

        public Encoding getHashEncoding() {
<span class="nc" id="L1625">            return hashEncoding;</span>
        }

    }

    static class AutoCloseableXMLStreamReaderHolder implements AutoCloseable {
        private final XMLStreamReader xmlStreamReader;

<span class="fc" id="L1633">        AutoCloseableXMLStreamReaderHolder(final XMLStreamReader xmlStreamReader) {</span>
<span class="fc" id="L1634">            this.xmlStreamReader = xmlStreamReader;</span>
<span class="fc" id="L1635">        }</span>

        public void close() throws XMLStreamException {
<span class="fc" id="L1638">            xmlStreamReader.close();</span>
<span class="fc" id="L1639">        }</span>

        public XMLStreamReader getXmlStreamReader() {
<span class="fc" id="L1642">            return xmlStreamReader;</span>
        }
    }

    static class AutoCloseableXMLStreamWriterHolder implements AutoCloseable {
        private final XMLStreamWriter xmlStreamWriter;

<span class="fc" id="L1649">        AutoCloseableXMLStreamWriterHolder(final XMLStreamWriter xmlStreamWriter) {</span>
<span class="fc" id="L1650">            this.xmlStreamWriter = xmlStreamWriter;</span>
<span class="fc" id="L1651">        }</span>

        public void close() throws XMLStreamException {
<span class="fc" id="L1654">            xmlStreamWriter.close();</span>
<span class="fc" id="L1655">        }</span>

        public XMLStreamWriter getXmlStreamWriter() {
<span class="fc" id="L1658">            return xmlStreamWriter;</span>
        }
    }

    public static class IntegrityResult {
        /**
         * The result of the integrity check and invalid identities.
         */
        private final boolean valid;
        private final ArrayList&lt;String&gt; identityNames;

<span class="nc" id="L1669">        IntegrityResult(final boolean valid, final ArrayList&lt;String&gt; identityNames) {</span>
<span class="nc" id="L1670">            this.valid = valid;</span>
<span class="nc" id="L1671">            this.identityNames = identityNames;</span>
<span class="nc" id="L1672">        }</span>

        /**
         * The validity of the integrity check.
         *
         * @return {@code true} if the integrity check was successful.
         */
        public boolean isValid() {
<span class="nc" id="L1680">            return valid;</span>
        }

        /**
         * Returns a string of the identities that were found to be invalid.
         *
         * @return the list of identities that were found to be invalid.
         */
        public String getIdentityNames() {
<span class="nc" id="L1689">            return identityNames.toString();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>