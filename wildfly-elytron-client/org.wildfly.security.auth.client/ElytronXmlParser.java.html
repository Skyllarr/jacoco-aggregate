<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ElytronXmlParser.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">WildFly Elytron</a> &gt; <a href="../index.html" class="el_bundle">wildfly-elytron-client</a> &gt; <a href="index.source.html" class="el_package">org.wildfly.security.auth.client</a> &gt; <span class="el_source">ElytronXmlParser.java</span></div><h1>ElytronXmlParser.java</h1><pre class="source lang-java linenums">/*
 * JBoss, Home of Professional Open Source.
 * Copyright 2014 Red Hat, Inc., and individual contributors
 * as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.wildfly.security.auth.client;

import static javax.xml.stream.XMLStreamConstants.END_ELEMENT;
import static javax.xml.stream.XMLStreamConstants.START_ELEMENT;
import static org.wildfly.common.Assert.checkMinimumParameter;
import static org.wildfly.common.Assert.checkNotNullParam;
import static org.wildfly.security.auth.client._private.ElytronMessages.xmlLog;
import static org.wildfly.security.provider.util.ProviderUtil.INSTALLED_PROVIDERS;
import static org.wildfly.security.provider.util.ProviderUtil.findProvider;

import java.io.Closeable;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.net.Authenticator;
import java.net.MalformedURLException;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.security.GeneralSecurityException;
import java.security.KeyPair;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.Provider;
import java.security.PublicKey;
import java.security.cert.X509Certificate;
import java.security.spec.InvalidKeySpecException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.ServiceConfigurationError;
import java.util.ServiceLoader;
import java.util.function.IntFunction;
import java.util.function.Supplier;
import java.util.regex.Pattern;

import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.SecretKeySpec;
import javax.net.ssl.KeyManager;
import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509ExtendedKeyManager;
import javax.net.ssl.X509TrustManager;
import javax.xml.stream.Location;

import org.ietf.jgss.GSSException;
import org.ietf.jgss.Oid;
import org.wildfly.client.config.ClientConfiguration;
import org.wildfly.client.config.ConfigXMLParseException;
import org.wildfly.client.config.ConfigurationXMLStreamReader;
import org.wildfly.client.config.XMLLocation;
import org.wildfly.common.Assert;
import org.wildfly.common.function.ExceptionBiFunction;
import org.wildfly.common.function.ExceptionSupplier;
import org.wildfly.common.function.ExceptionUnaryOperator;
import org.wildfly.common.iteration.CodePointIterator;
import org.wildfly.security.FixedSecurityFactory;
import org.wildfly.security.SecurityFactory;
import org.wildfly.security.asn1.OidsUtil;
import org.wildfly.security.auth.client._private.ElytronMessages;
import org.wildfly.security.auth.server.IdentityCredentials;
import org.wildfly.security.auth.server.NameRewriter;
import org.wildfly.security.auth.util.ElytronAuthenticator;
import org.wildfly.security.auth.util.ElytronFilePasswordProvider;
import org.wildfly.security.auth.util.RegexNameRewriter;
import org.wildfly.security.credential.BearerTokenCredential;
import org.wildfly.security.credential.Credential;
import org.wildfly.security.credential.KeyPairCredential;
import org.wildfly.security.credential.PasswordCredential;
import org.wildfly.security.credential.PublicKeyCredential;
import org.wildfly.security.credential.SSHCredential;
import org.wildfly.security.credential.X509CertificateChainPrivateCredential;
import org.wildfly.security.credential.source.CredentialSource;
import org.wildfly.security.credential.source.impl.CredentialStoreCredentialSource;
import org.wildfly.security.credential.source.impl.KeyStoreCredentialSource;
import org.wildfly.security.credential.source.impl.LocalKerberosCredentialSource;
import org.wildfly.security.credential.source.OAuth2CredentialSource;
import org.wildfly.security.credential.store.CredentialStore;
import org.wildfly.security.keystore.AliasFilter;
import org.wildfly.security.keystore.FilteringKeyStore;
import org.wildfly.security.keystore.KeyStoreUtil;
import org.wildfly.security.keystore.PasswordEntry;
import org.wildfly.security.keystore.WrappingPasswordKeyStore;
import org.wildfly.security.mechanism.gssapi.GSSCredentialSecurityFactory;
import org.wildfly.security.password.Password;
import org.wildfly.security.password.PasswordFactory;
import org.wildfly.security.password.WildFlyElytronPasswordProvider;
import org.wildfly.security.password.interfaces.ClearPassword;
import org.wildfly.security.password.interfaces.MaskedPassword;
import org.wildfly.security.password.spec.ClearPasswordSpec;
import org.wildfly.security.password.spec.MaskedPasswordSpec;
import org.wildfly.security.pem.Pem;
import org.wildfly.security.pem.PemEntry;
import org.wildfly.security.provider.util.ProviderFactory;
import org.wildfly.security.provider.util.ProviderServiceLoaderSupplier;
import org.wildfly.security.provider.util.ProviderUtil;
import org.wildfly.security.sasl.SaslMechanismSelector;
import org.wildfly.security.sasl.util.ServiceLoaderSaslClientFactory;
import org.wildfly.security.ssl.CipherSuiteSelector;
import org.wildfly.security.ssl.ProtocolSelector;
import org.wildfly.security.ssl.SSLContextBuilder;
import org.wildfly.security.ssl.X509RevocationTrustManager;

/**
 * A parser for the Elytron XML schema.
 *
 * @author &lt;a href=&quot;mailto:david.lloyd@redhat.com&quot;&gt;David M. Lloyd&lt;/a&gt;
 */
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">public final class ElytronXmlParser {</span>

<span class="fc" id="L140">    private static final Supplier&lt;Provider[]&gt; ELYTRON_PROVIDER_SUPPLIER = ProviderFactory.getElytronProviderSupplier(ElytronXmlParser.class.getClassLoader());</span>

<span class="fc" id="L142">    private static final Supplier&lt;Provider[]&gt; DEFAULT_PROVIDER_SUPPLIER = ProviderUtil.aggregate(ELYTRON_PROVIDER_SUPPLIER, INSTALLED_PROVIDERS);</span>

    static final Map&lt;String, Version&gt; KNOWN_NAMESPACES;

<span class="fc" id="L146">    private enum Version {</span>

<span class="fc" id="L148">        VERSION_1_0(&quot;urn:elytron:1.0&quot;, null),</span>
<span class="fc" id="L149">        VERSION_1_0_1(&quot;urn:elytron:1.0.1&quot;, VERSION_1_0),</span>
<span class="fc" id="L150">        VERSION_1_1(&quot;urn:elytron:client:1.1&quot;, VERSION_1_0_1),</span>
<span class="fc" id="L151">        VERSION_1_2(&quot;urn:elytron:client:1.2&quot;, VERSION_1_1),</span>
<span class="fc" id="L152">        VERSION_1_3(&quot;urn:elytron:client:1.3&quot;, VERSION_1_2),</span>
<span class="fc" id="L153">        VERSION_1_4(&quot;urn:elytron:client:1.4&quot;, VERSION_1_3),</span>
<span class="fc" id="L154">        VERSION_1_5(&quot;urn:elytron:client:1.5&quot;, VERSION_1_4),</span>
<span class="fc" id="L155">        VERSION_1_6(&quot;urn:elytron:client:1.6&quot;, VERSION_1_5),</span>
<span class="fc" id="L156">        VERSION_1_7(&quot;urn:elytron:client:1.7&quot;, VERSION_1_6);</span>

        final String namespace;

        /*
         * In the future we could support multiple parents but wait until that becomes a reality before adding it.
         */
        final Version parent;

<span class="fc" id="L165">        Version(String namespace, Version parent) {</span>
<span class="fc" id="L166">            this.namespace = namespace;</span>
<span class="fc" id="L167">            this.parent = parent;</span>
<span class="fc" id="L168">        }</span>


        boolean isAtLeast(Version version) {
<span class="pc bpc" id="L172" title="2 of 6 branches missed.">            return this.equals(version) || (parent != null ? parent.isAtLeast(version) : false);</span>
        }

    }

    static {
<span class="fc" id="L178">        Map&lt;String, Version&gt; knownNamespaces = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">        for (Version version : Version.values()) {</span>
<span class="fc" id="L180">            knownNamespaces.put(version.namespace, version);</span>
        }
<span class="fc" id="L182">        KNOWN_NAMESPACES = Collections.unmodifiableMap(knownNamespaces);</span>
<span class="fc" id="L183">    }</span>

    private ElytronXmlParser() {
    }

    // authentication client document

    /**
     * Parse an Elytron authentication client configuration from a configuration discovered using the default wildfly-client-config discovery rules.
     *
     * @return the authentication context factory
     * @throws ConfigXMLParseException if the resource failed to be parsed
     */
    public static SecurityFactory&lt;AuthenticationContext&gt; parseAuthenticationClientConfiguration() throws ConfigXMLParseException {
<span class="fc" id="L197">        final ClientConfiguration clientConfiguration = ClientConfiguration.getInstance();</span>
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">        if (clientConfiguration != null) try (final ConfigurationXMLStreamReader streamReader = clientConfiguration.readConfiguration(KNOWN_NAMESPACES.keySet())) {</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">            if (streamReader != null) {</span>
<span class="nc" id="L200">                xmlLog.tracef(&quot;Parsing configuration from %s for namespace %s&quot;, streamReader.getUri(), streamReader.getNamespaceURI());</span>
<span class="nc" id="L201">                return parseAuthenticationClientConfiguration(streamReader);</span>
            } else {
<span class="nc bnc" id="L203" title="All 2 branches missed.">                if (xmlLog.isTraceEnabled()) {</span>
<span class="nc" id="L204">                    xmlLog.tracef(&quot;No configuration found for known namespaces '%s'&quot;, namespacesToString());</span>
                }
            }
<span class="nc bnc" id="L207" title="All 2 branches missed.">        }</span>
<span class="fc" id="L208">        xmlLog.trace(&quot;Fallback to parse legacy configuration.&quot;);</span>
        // Try legacy configuration next
<span class="fc" id="L210">        return parseLegacyConfiguration();</span>
    }

    /**
     * Parse an Elytron authentication client configuration from a resource located at a specified {@link URI}.
     *
     * @param uri the {@link URI} of the configuration.
     * @return the authentication context factory
     * @throws ConfigXMLParseException if the resource failed to be parsed
     */
    public static SecurityFactory&lt;AuthenticationContext&gt; parseAuthenticationClientConfiguration(URI uri) throws ConfigXMLParseException {
<span class="fc" id="L221">        final ClientConfiguration clientConfiguration = ClientConfiguration.getInstance(uri);</span>
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">        if (clientConfiguration != null) try (final ConfigurationXMLStreamReader streamReader = clientConfiguration.readConfiguration(KNOWN_NAMESPACES.keySet())) {</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">            if (streamReader != null) {</span>
<span class="fc" id="L224">                xmlLog.tracef(&quot;Parsig configuration from %s for namespace %s&quot;, streamReader.getUri(), streamReader.getNamespaceURI());</span>
<span class="fc" id="L225">                return parseAuthenticationClientConfiguration(streamReader);</span>
            } else {
<span class="nc bnc" id="L227" title="All 2 branches missed.">                if (xmlLog.isTraceEnabled()) {</span>
<span class="nc" id="L228">                    xmlLog.tracef(&quot;No configuration found for known namespaces '%s'&quot;, namespacesToString());</span>
                }
            }
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">        }</span>
<span class="nc" id="L232">        xmlLog.trace(&quot;Fallback to parse legacy configuration.&quot;);</span>
        // Try legacy configuration next
<span class="nc" id="L234">        return parseLegacyConfiguration();</span>
    }

    private static String namespacesToString() {
<span class="nc" id="L238">        Iterator&lt;String&gt; namespaceIterator = KNOWN_NAMESPACES.keySet().iterator();</span>
<span class="nc" id="L239">        StringBuilder namespaces = new StringBuilder(namespaceIterator.next());</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">        while (namespaceIterator.hasNext()) {</span>
<span class="nc" id="L241">            namespaces.append(&quot;,&quot;).append(namespaceIterator.next());</span>
        }

<span class="nc" id="L244">        return namespaces.toString();</span>
    }

    /**
     * Parse a Elytron authentication client configuration from a configuration XML reader.
     *
     * @param reader the XML stream reader
     * @return the authentication context factory
     * @throws ConfigXMLParseException if the resource failed to be parsed
     */
    static SecurityFactory&lt;AuthenticationContext&gt; parseAuthenticationClientConfiguration(ConfigurationXMLStreamReader reader) throws ConfigXMLParseException {
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">        if (reader.hasNext()) {</span>
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">            switch (reader.nextTag()) {</span>
                case START_ELEMENT: {
<span class="fc" id="L258">                    Version xmlVersion = KNOWN_NAMESPACES.get(checkGetElementNamespace(reader));</span>
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">                    switch (reader.getLocalName()) {</span>
                        case &quot;authentication-client&quot;: {
<span class="fc" id="L261">                            return parseAuthenticationClientType(reader, xmlVersion);</span>
                        }
                        default: {
<span class="nc" id="L264">                            throw reader.unexpectedElement();</span>
                        }
                    }
                }
                default: {
<span class="nc" id="L269">                    throw reader.unexpectedContent();</span>
                }
            }
        }
<span class="nc" id="L273">        xmlLog.trace(&quot;No authentication-client element found, falling back to empty AuthenticationContext&quot;);</span>
<span class="nc" id="L274">        return AuthenticationContext::empty;</span>
    }

    private static SecurityFactory&lt;AuthenticationContext&gt; parseLegacyConfiguration() {
<span class="fc" id="L278">        final ServiceLoader&lt;LegacyConfiguration&gt; loader = ServiceLoader.load(LegacyConfiguration.class, ElytronXmlParser.class.getClassLoader());</span>
<span class="fc" id="L279">        final Iterator&lt;LegacyConfiguration&gt; iterator = loader.iterator();</span>
<span class="fc" id="L280">        final List&lt;LegacyConfiguration&gt; configs = new ArrayList&lt;&gt;();</span>
        for (;;) try {
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">            if (! iterator.hasNext()) break;</span>
<span class="nc" id="L283">            configs.add(iterator.next());</span>
<span class="nc" id="L284">        } catch (ServiceConfigurationError ignored) {}</span>
<span class="fc" id="L285">        return () -&gt; {</span>
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">            for (LegacyConfiguration config : configs) {</span>
<span class="nc" id="L287">                final AuthenticationContext context = config.getConfiguredAuthenticationContext();</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">                if (context != null) {</span>
<span class="nc" id="L289">                    xmlLog.trace(&quot;Found AuthenticationContext in legacy configuration&quot;);</span>
<span class="nc" id="L290">                    return context;</span>
                }
<span class="nc" id="L292">            }</span>
<span class="fc" id="L293">            xmlLog.trace(&quot;No legacy configuration available, using AuthenticationContext.empty()&quot;);</span>
<span class="fc" id="L294">            return AuthenticationContext.empty();</span>
        };
    }

    // authentication client types

    /**
     * Parse an XML element of type {@code authentication-client-type} from an XML reader.
     *
     * @param reader the XML stream reader
     * @param xmlVersion the version of parsed XML
     * @return the authentication context factory
     * @throws ConfigXMLParseException if the resource failed to be parsed
     */
    static SecurityFactory&lt;AuthenticationContext&gt; parseAuthenticationClientType(ConfigurationXMLStreamReader reader, final Version xmlVersion) throws ConfigXMLParseException {
<span class="fc" id="L309">        requireNoAttributes(reader);</span>
<span class="fc" id="L310">        ExceptionSupplier&lt;RuleNode&lt;AuthenticationConfiguration&gt;, ConfigXMLParseException&gt; authFactory = () -&gt; null;</span>
<span class="fc" id="L311">        ExceptionSupplier&lt;RuleNode&lt;SecurityFactory&lt;SSLContext&gt;&gt;, ConfigXMLParseException&gt; sslFactory = () -&gt; null;</span>
<span class="fc" id="L312">        Map&lt;String, ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt;&gt; keyStoresMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L313">        Map&lt;String, ExceptionSupplier&lt;CredentialStore, ConfigXMLParseException&gt;&gt; credentialStoresMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L314">        Map&lt;String, ExceptionSupplier&lt;SecurityFactory&lt;SSLContext&gt;, ConfigXMLParseException&gt;&gt; sslContextsMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L315">        Map&lt;String, ExceptionSupplier&lt;AuthenticationConfiguration, ConfigXMLParseException&gt;&gt; authenticationConfigurationsMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L316">        final DeferredSupplier&lt;Provider[]&gt; providersSupplier = new DeferredSupplier&lt;&gt;(DEFAULT_PROVIDER_SUPPLIER);</span>
<span class="fc" id="L317">        boolean netAuthenticator = false;</span>
<span class="fc" id="L318">        int foundBits  = 0;</span>
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="fc" id="L320">            final int tag = reader.nextTag();</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">            if (tag == START_ELEMENT) {</span>
<span class="fc" id="L322">                checkElementNamespace(reader, xmlVersion);</span>
<span class="pc bpc" id="L323" title="3 of 9 branches missed.">                switch (reader.getLocalName()) {</span>
                    case &quot;authentication-rules&quot;: {
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">                        if (isSet(foundBits, 0)) throw reader.unexpectedElement();</span>
<span class="fc" id="L326">                        foundBits = setBit(foundBits, 0);</span>
<span class="fc" id="L327">                        authFactory = parseRulesType(reader, xmlVersion, authenticationConfigurationsMap, (r, m) -&gt; parseAuthenticationRuleType(r, xmlVersion, m));</span>
<span class="fc" id="L328">                        break;</span>
                    }
                    case &quot;ssl-context-rules&quot;: {
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">                        if (isSet(foundBits, 1)) throw reader.unexpectedElement();</span>
<span class="fc" id="L332">                        foundBits = setBit(foundBits, 1);</span>
<span class="fc" id="L333">                        sslFactory = parseRulesType(reader, xmlVersion, sslContextsMap, (r,m) -&gt; parseSslContextRuleType(r, xmlVersion, m));</span>
<span class="fc" id="L334">                        break;</span>
                    }
                    case &quot;authentication-configurations&quot;: {
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">                        if (isSet(foundBits, 2)) throw reader.unexpectedElement();</span>
<span class="fc" id="L338">                        foundBits = setBit(foundBits, 2);</span>
<span class="fc" id="L339">                        parseAuthenticationConfigurationsType(reader, xmlVersion, authenticationConfigurationsMap, keyStoresMap, credentialStoresMap, providersSupplier);</span>
<span class="fc" id="L340">                        break;</span>
                    }
                    case &quot;ssl-contexts&quot;: {
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">                        if (isSet(foundBits, 3)) throw reader.unexpectedElement();</span>
<span class="fc" id="L344">                        foundBits = setBit(foundBits, 3);</span>
<span class="fc" id="L345">                        parseSslContextsType(reader, xmlVersion, sslContextsMap, keyStoresMap, credentialStoresMap, providersSupplier);</span>
<span class="fc" id="L346">                        break;</span>
                    }
                    case &quot;key-stores&quot;: {
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">                        if (isSet(foundBits, 4)) throw reader.unexpectedElement();</span>
<span class="fc" id="L350">                        foundBits = setBit(foundBits, 4);</span>
<span class="fc" id="L351">                        parseKeyStoresType(reader, xmlVersion, keyStoresMap, credentialStoresMap, providersSupplier);</span>
<span class="fc" id="L352">                        break;</span>
                    }
                    case &quot;net-authenticator&quot;: {
<span class="nc bnc" id="L355" title="All 2 branches missed.">                        if (isSet(foundBits, 5)) throw reader.unexpectedElement();</span>
<span class="nc" id="L356">                        foundBits = setBit(foundBits, 5);</span>
<span class="nc" id="L357">                        netAuthenticator = true;</span>
<span class="nc" id="L358">                        parseEmptyType(reader);</span>
<span class="nc" id="L359">                        break;</span>
                    }
                    case &quot;credential-stores&quot;: {
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">                        if (isSet(foundBits, 6)) throw reader.unexpectedElement();</span>
<span class="fc" id="L363">                        foundBits = setBit(foundBits, 6);</span>
<span class="fc" id="L364">                        parseCredentialStoresType(reader, xmlVersion, keyStoresMap, credentialStoresMap, providersSupplier);</span>
<span class="fc" id="L365">                        break;</span>
                    }
                    case &quot;providers&quot;: {
<span class="nc bnc" id="L368" title="All 2 branches missed.">                        if (isSet(foundBits, 7)) throw reader.unexpectedElement();</span>
<span class="nc" id="L369">                        foundBits = setBit(foundBits, 7);</span>
<span class="nc" id="L370">                        Supplier&lt;Provider[]&gt; supplier = parseProvidersType(reader, xmlVersion);</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">                        if (supplier != null) {</span>
<span class="nc" id="L372">                            providersSupplier.setSupplier(supplier);</span>
                        }
                        break;
                    }
<span class="pc" id="L376">                    default: throw reader.unexpectedElement();</span>
                }
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="pc bpc" id="L379" title="2 of 4 branches missed.">                assert reader.getLocalName().equals(&quot;authentication-client&quot;);</span>
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">                if (netAuthenticator) {</span>
<span class="nc" id="L381">                    Authenticator.setDefault(new ElytronAuthenticator());</span>
                }
                // validate key and credential stores...
<span class="fc bfc" id="L384" title="All 2 branches covered.">                for (ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt; supplier : keyStoresMap.values()) {</span>
<span class="fc" id="L385">                    supplier.get();</span>
<span class="fc" id="L386">                }</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">                for (ExceptionSupplier&lt;CredentialStore, ConfigXMLParseException&gt; supplier : credentialStoresMap.values()) {</span>
<span class="fc" id="L388">                    supplier.get();</span>
<span class="fc" id="L389">                }</span>
<span class="fc" id="L390">                final RuleNode&lt;AuthenticationConfiguration&gt; authNode = authFactory.get();</span>
<span class="fc" id="L391">                final RuleNode&lt;SecurityFactory&lt;SSLContext&gt;&gt; sslNode = sslFactory.get();</span>
<span class="fc" id="L392">                return () -&gt; new AuthenticationContext(authNode, sslNode);</span>
            } else {
<span class="nc" id="L394">                throw reader.unexpectedContent();</span>
            }
<span class="fc" id="L396">        }</span>
<span class="nc" id="L397">        throw reader.unexpectedDocumentEnd();</span>
    }

    private static void parseAuthenticationConfigurationsType(final ConfigurationXMLStreamReader reader, final Version xmlVersion, final Map&lt;String, ExceptionSupplier&lt;AuthenticationConfiguration, ConfigXMLParseException&gt;&gt; authenticationConfigurationsMap, final Map&lt;String, ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt;&gt; keyStoresMap, final Map&lt;String, ExceptionSupplier&lt;CredentialStore, ConfigXMLParseException&gt;&gt; credentialStoresMap, final Supplier&lt;Provider[]&gt; providers) throws ConfigXMLParseException {
<span class="fc" id="L401">        requireNoAttributes(reader);</span>
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="fc" id="L403">            final int tag = reader.nextTag();</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">            if (tag == START_ELEMENT) {</span>
<span class="fc" id="L405">                checkElementNamespace(reader, xmlVersion);</span>
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">                switch (reader.getLocalName()) {</span>
                    case &quot;configuration&quot;: {
<span class="fc" id="L408">                        parseAuthenticationConfigurationType(reader, xmlVersion, authenticationConfigurationsMap, keyStoresMap, credentialStoresMap, providers);</span>
<span class="fc" id="L409">                        break;</span>
                    }
                    default: {
<span class="pc" id="L412">                        throw reader.unexpectedElement();</span>
                    }
                }
<span class="pc bpc" id="L415" title="1 of 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="fc" id="L416">                return;</span>
            } else {
<span class="nc" id="L418">                throw reader.unexpectedContent();</span>
            }
<span class="fc" id="L420">        }</span>
<span class="nc" id="L421">        throw reader.unexpectedDocumentEnd();</span>
    }

    private static void parseSslContextsType(final ConfigurationXMLStreamReader reader, final Version xmlVersion, final Map&lt;String, ExceptionSupplier&lt;SecurityFactory&lt;SSLContext&gt;, ConfigXMLParseException&gt;&gt; sslContextsMap, final Map&lt;String, ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt;&gt; keyStoresMap, final Map&lt;String, ExceptionSupplier&lt;CredentialStore, ConfigXMLParseException&gt;&gt; credentialStoresMap, final Supplier&lt;Provider[]&gt; providers) throws ConfigXMLParseException {
<span class="fc" id="L425">        requireNoAttributes(reader);</span>
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="fc" id="L427">            final int tag = reader.nextTag();</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">            if (tag == START_ELEMENT) {</span>
<span class="fc" id="L429">                checkElementNamespace(reader, xmlVersion);</span>
<span class="pc bpc" id="L430" title="1 of 3 branches missed.">                switch (reader.getLocalName()) {</span>
                    case &quot;ssl-context&quot;: {
<span class="fc" id="L432">                        parseSslContextType(reader, xmlVersion, sslContextsMap, keyStoresMap, credentialStoresMap, providers);</span>
<span class="fc" id="L433">                        break;</span>
                    }
                    case &quot;default-ssl-context&quot;: {
<span class="fc" id="L436">                        final String name = parseNameType(reader);</span>
<span class="fc" id="L437">                        sslContextsMap.put(name, () -&gt; SSLContext::getDefault);</span>
<span class="fc" id="L438">                        break;</span>
                    }
                    default: {
<span class="pc" id="L441">                        throw reader.unexpectedElement();</span>
                    }
                }
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="fc" id="L445">                return;</span>
            } else {
<span class="nc" id="L447">                throw reader.unexpectedContent();</span>
            }
<span class="fc" id="L449">        }</span>
<span class="nc" id="L450">        throw reader.unexpectedDocumentEnd();</span>
    }

    private static void parseSslContextType(final ConfigurationXMLStreamReader reader, final Version xmlVersion, final Map&lt;String, ExceptionSupplier&lt;SecurityFactory&lt;SSLContext&gt;, ConfigXMLParseException&gt;&gt; sslContextsMap, final Map&lt;String, ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt;&gt; keyStoresMap, final Map&lt;String, ExceptionSupplier&lt;CredentialStore, ConfigXMLParseException&gt;&gt; credentialStoresMap, final Supplier&lt;Provider[]&gt; providers) throws ConfigXMLParseException {
<span class="fc" id="L454">        final String name = requireSingleAttribute(reader, &quot;name&quot;);</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">        if (sslContextsMap.containsKey(name)) {</span>
<span class="nc" id="L456">            throw xmlLog.xmlDuplicateSslContextName(name, reader);</span>
        }
<span class="fc" id="L458">        final XMLLocation location = reader.getLocation();</span>
<span class="fc" id="L459">        int foundBits = 0;</span>
<span class="fc" id="L460">        String providerName = null;</span>
<span class="fc" id="L461">        CipherSuiteSelector cipherSuiteSelector = null;</span>
<span class="fc" id="L462">        ProtocolSelector protocolSelector = null;</span>
<span class="fc" id="L463">        ExceptionSupplier&lt;X509ExtendedKeyManager, ConfigXMLParseException&gt; keyManagerSupplier = null;</span>
<span class="fc" id="L464">        ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt; trustStoreSupplier = null;</span>
<span class="fc" id="L465">        DeferredSupplier&lt;Provider[]&gt; providersSupplier = new DeferredSupplier&lt;&gt;(providers);</span>
<span class="fc" id="L466">        TrustManagerBuilder trustManagerBuilder = new TrustManagerBuilder(providersSupplier, location);</span>

<span class="pc bpc" id="L468" title="1 of 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="fc" id="L469">            final int tag = reader.nextTag();</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">            if (tag == START_ELEMENT) {</span>
<span class="fc" id="L471">                checkElementNamespace(reader, xmlVersion);</span>
<span class="pc bpc" id="L472" title="7 of 11 branches missed.">                switch (reader.getLocalName()) {</span>
                    case &quot;key-store-ssl-certificate&quot;: {
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">                        if (isSet(foundBits, 0)) throw reader.unexpectedElement();</span>
<span class="fc" id="L475">                        foundBits = setBit(foundBits, 0);</span>
<span class="fc" id="L476">                        keyManagerSupplier = parseKeyStoreSslCertificate(reader, xmlVersion, keyStoresMap, credentialStoresMap, providers);</span>
<span class="fc" id="L477">                        break;</span>
                    }
                    case &quot;cipher-suite&quot;: {
<span class="pc bpc" id="L480" title="1 of 2 branches missed.">                        if (isSet(foundBits, 1)) throw reader.unexpectedElement();</span>
<span class="fc" id="L481">                        foundBits = setBit(foundBits, 1);</span>
<span class="fc" id="L482">                        cipherSuiteSelector = parseCipherSuiteSelectorType(reader, xmlVersion);</span>
<span class="fc" id="L483">                        break;</span>
                    }
                    case &quot;protocol&quot;: {
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">                        if (isSet(foundBits, 2)) throw reader.unexpectedElement();</span>
<span class="fc" id="L487">                        foundBits = setBit(foundBits, 2);</span>
<span class="fc" id="L488">                        protocolSelector = parseProtocolSelectorNamesType(reader);</span>
<span class="fc" id="L489">                        break;</span>
                    }
                    case &quot;provider-name&quot;: {
<span class="nc bnc" id="L492" title="All 2 branches missed.">                        if (isSet(foundBits, 3)) throw reader.unexpectedElement();</span>
<span class="nc" id="L493">                        foundBits = setBit(foundBits, 3);</span>
<span class="nc" id="L494">                        providerName = parseNameType(reader);</span>
<span class="nc" id="L495">                        break;</span>
                    }
                    case &quot;providers&quot;: {
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">                        if (isSet(foundBits, 4)) throw reader.unexpectedElement();</span>
<span class="fc" id="L499">                        foundBits = setBit(foundBits, 4);</span>
<span class="fc" id="L500">                        Supplier&lt;Provider[]&gt; supplier = parseProvidersType(reader, xmlVersion);</span>
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">                        if (supplier != null) {</span>
<span class="fc" id="L502">                            providersSupplier.setSupplier(supplier);</span>
                        }
                        break;
                    }
                    case &quot;trust-store&quot;: {
<span class="nc bnc" id="L507" title="All 2 branches missed.">                        if (isSet(foundBits, 5)) throw reader.unexpectedElement();</span>
<span class="nc" id="L508">                        foundBits = setBit(foundBits, 5);</span>
<span class="nc" id="L509">                        trustStoreSupplier = parseTrustStoreRefType(reader, keyStoresMap);</span>
<span class="nc" id="L510">                        break;</span>
                    }
                    case &quot;certificate-revocation-list&quot;: {
                        // rejects attribute if certificate-revocation-lists has been set
<span class="nc bnc" id="L514" title="All 4 branches missed.">                        if (isSet(foundBits, 6) || isSet(foundBits, 9)) throw reader.unexpectedElement();</span>
<span class="nc" id="L515">                        foundBits = setBit(foundBits, 6);</span>
<span class="nc" id="L516">                        parseCertificateRevocationList(reader, trustManagerBuilder, xmlVersion, false);</span>
<span class="nc" id="L517">                        break;</span>
                    }
                    case &quot;trust-manager&quot;: {
<span class="nc bnc" id="L520" title="All 4 branches missed.">                        if (isSet(foundBits, 7) || !xmlVersion.isAtLeast(Version.VERSION_1_1)) throw reader.unexpectedElement();</span>
<span class="nc" id="L521">                        foundBits = setBit(foundBits, 7);</span>
<span class="nc" id="L522">                        parseTrustManager(reader, trustManagerBuilder, xmlVersion);</span>
<span class="nc" id="L523">                        break;</span>
                    }
                    case &quot;ocsp&quot;: {
<span class="nc bnc" id="L526" title="All 4 branches missed.">                        if (isSet(foundBits, 8) || !xmlVersion.isAtLeast(Version.VERSION_1_4)) throw reader.unexpectedElement();</span>
<span class="nc" id="L527">                        foundBits = setBit(foundBits, 8);</span>
<span class="nc" id="L528">                        parseOcsp(reader, trustManagerBuilder, keyStoresMap);</span>
<span class="nc" id="L529">                        break;</span>
                    }
                    case &quot;certificate-revocation-lists&quot; : {
                        // rejects attribute if certificate-revocation-list has been set
<span class="nc bnc" id="L533" title="All 6 branches missed.">                        if (isSet(foundBits, 9) || isSet(foundBits, 6) || !xmlVersion.isAtLeast(Version.VERSION_1_7)) throw reader.unexpectedElement();</span>
<span class="nc" id="L534">                        foundBits = setBit(foundBits, 9);</span>
<span class="nc" id="L535">                        parseCertificateRevocationLists(reader, trustManagerBuilder, xmlVersion);</span>
<span class="nc" id="L536">                        break;</span>
                    }
<span class="pc" id="L538">                    default: throw reader.unexpectedElement();</span>
                }
<span class="pc bpc" id="L540" title="1 of 2 branches missed.">            } else if (tag != END_ELEMENT) {</span>
<span class="nc" id="L541">                throw reader.unexpectedContent();</span>
            } else {
                // ready to register!
<span class="fc" id="L544">                final Supplier&lt;Provider[]&gt; finalProvidersSupplier = providersSupplier;</span>
<span class="fc" id="L545">                final ProtocolSelector finalProtocolSelector = protocolSelector;</span>
<span class="fc" id="L546">                final CipherSuiteSelector finalCipherSuiteSelector = cipherSuiteSelector;</span>
<span class="fc" id="L547">                final String finalProviderName = providerName;</span>
<span class="fc" id="L548">                final ExceptionSupplier&lt;X509ExtendedKeyManager, ConfigXMLParseException&gt; finalKeyManagerSupplier = keyManagerSupplier;</span>
<span class="fc" id="L549">                final ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt; finalTrustStoreSupplier = trustStoreSupplier;</span>
<span class="pc bpc" id="L550" title="2 of 4 branches missed.">                final boolean initTrustManager = finalTrustStoreSupplier != null || isSet(foundBits, 7);</span>
<span class="fc" id="L551">                sslContextsMap.putIfAbsent(name, () -&gt; {</span>
<span class="fc" id="L552">                    final SSLContextBuilder sslContextBuilder = new SSLContextBuilder();</span>
<span class="fc" id="L553">                    sslContextBuilder.setClientMode(true);</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">                    if (finalCipherSuiteSelector != null) {</span>
<span class="fc" id="L555">                        sslContextBuilder.setCipherSuiteSelector(finalCipherSuiteSelector);</span>
                    }
<span class="fc bfc" id="L557" title="All 2 branches covered.">                    if (finalProtocolSelector != null) {</span>
<span class="fc" id="L558">                        sslContextBuilder.setProtocolSelector(finalProtocolSelector);</span>
                    }
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">                    if (finalKeyManagerSupplier != null) {</span>
<span class="fc" id="L561">                        sslContextBuilder.setKeyManager(finalKeyManagerSupplier.get());</span>
                    }
<span class="pc bpc" id="L563" title="1 of 2 branches missed.">                    if (initTrustManager) {</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">                        if (finalTrustStoreSupplier != null) {</span>
<span class="nc" id="L565">                            trustManagerBuilder.setTrustStore(finalTrustStoreSupplier.get());</span>
                        }
                        try {
<span class="nc" id="L568">                            sslContextBuilder.setTrustManager(trustManagerBuilder.build());</span>
<span class="nc" id="L569">                        } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L570">                            throw new ConfigXMLParseException(e);</span>
<span class="nc" id="L571">                        }</span>
                    }
<span class="fc" id="L573">                    sslContextBuilder.setProviderName(finalProviderName);</span>
<span class="fc" id="L574">                    sslContextBuilder.setProviderSupplier(finalProvidersSupplier);</span>
<span class="fc" id="L575">                    sslContextBuilder.setUseCipherSuitesOrder(true);</span>
<span class="fc" id="L576">                    return sslContextBuilder.build();</span>
                });
<span class="fc" id="L578">                return;</span>
            }
<span class="fc" id="L580">        }</span>
<span class="nc" id="L581">        throw reader.unexpectedDocumentEnd();</span>
    }

    private static class TrustManagerBuilder {
        final Supplier&lt;Provider[]&gt; providers;
        final Location xmlLocation;
<span class="fc" id="L587">        String providerName = null;</span>
<span class="fc" id="L588">        String algorithm = null;</span>
        KeyStore trustStore;
<span class="fc" id="L590">        boolean crl = false;</span>
<span class="fc" id="L591">        List&lt;InputStream&gt; crlStreams = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L592">        int maxCertPath = 5;</span>
<span class="fc" id="L593">        boolean ocsp = false;</span>
<span class="fc" id="L594">        boolean preferCrls = false;</span>
<span class="fc" id="L595">        boolean onlyLeafCert = false;</span>
<span class="fc" id="L596">        boolean softFail = false;</span>
<span class="fc" id="L597">        URI ocspResponder = null;</span>
<span class="fc" id="L598">        boolean maxCertPathSet = false;</span>
<span class="fc" id="L599">        String responderCertAlias = null;</span>
<span class="fc" id="L600">        ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt; responderStoreSupplier = null;</span>

<span class="fc" id="L602">        TrustManagerBuilder(Supplier&lt;Provider[]&gt; providers, Location xmlLocation) {</span>
<span class="fc" id="L603">            this.providers = providers;</span>
<span class="fc" id="L604">            this.xmlLocation = xmlLocation;</span>
<span class="fc" id="L605">        }</span>

        void setProviderName(String providerName) {
<span class="nc" id="L608">            this.providerName = providerName;</span>
<span class="nc" id="L609">        }</span>

        void setAlgorithm(String algorithm) {
<span class="nc" id="L612">            this.algorithm = algorithm;</span>
<span class="nc" id="L613">        }</span>

        void setTrustStore(KeyStore trustStore) {
<span class="nc" id="L616">            this.trustStore = trustStore;</span>
<span class="nc" id="L617">        }</span>

        void setCrl() {
<span class="nc" id="L620">            this.crl = true;</span>
<span class="nc" id="L621">        }</span>

        void addCrlStream(InputStream crlStream) {
<span class="nc" id="L624">            this.crlStreams.add(crlStream);</span>
<span class="nc" id="L625">        }</span>

        void setMaxCertPath(int maxCertPath) {
<span class="nc" id="L628">            checkMinimumParameter(&quot;maxCertPath&quot;, 1, maxCertPath);</span>
<span class="nc" id="L629">            this.maxCertPath = maxCertPath;</span>
<span class="nc" id="L630">            this.maxCertPathSet = true;</span>
<span class="nc" id="L631">        }</span>

        boolean isMaxCertPathSet() {
<span class="nc" id="L634">            return maxCertPathSet;</span>
        }

        public void setOcsp() {
<span class="nc" id="L638">            this.ocsp = true;</span>
<span class="nc" id="L639">        }</span>

        public void setPreferCrls(boolean preferCrls) {
<span class="nc" id="L642">            this.preferCrls = preferCrls;</span>
<span class="nc" id="L643">        }</span>

        public void setOnlyLeafCert(boolean onlyLeafCert) {
<span class="nc" id="L646">            this.onlyLeafCert = onlyLeafCert;</span>
<span class="nc" id="L647">        }</span>

        public void setSoftFail(boolean softFail) {
<span class="nc" id="L650">            this.softFail = softFail;</span>
<span class="nc" id="L651">        }</span>

        public void setOcspResponder(URI ocspResponder) {
<span class="nc" id="L654">            this.ocspResponder = ocspResponder;</span>
<span class="nc" id="L655">        }</span>

        public void setOcspRescponderCertAlias(String alias) {
<span class="nc" id="L658">            this.responderCertAlias = alias;</span>
<span class="nc" id="L659">        }</span>

        public void setOcspResponderCertKeystoreSupplier(ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt; supplier) {
<span class="nc" id="L662">            this.responderStoreSupplier = supplier;</span>
<span class="nc" id="L663">        }</span>

        X509TrustManager build() throws NoSuchAlgorithmException, KeyStoreException, ConfigXMLParseException {
<span class="nc bnc" id="L666" title="All 2 branches missed.">            final String algorithm = this.algorithm != null ? this.algorithm : TrustManagerFactory.getDefaultAlgorithm();</span>
<span class="nc" id="L667">            Provider provider = findProvider(providers, providerName, TrustManagerFactory.class, algorithm);</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">            if (provider == null) {</span>
<span class="nc" id="L669">                throw xmlLog.xmlUnableToIdentifyProvider(xmlLocation, providerName, &quot;TrustManagerFactory&quot;, algorithm);</span>
            }

<span class="nc" id="L672">            final TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(algorithm, provider);</span>
<span class="nc bnc" id="L673" title="All 4 branches missed.">            if (crl || ocsp) {</span>
<span class="nc" id="L674">                X509RevocationTrustManager.Builder revocationBuilder = X509RevocationTrustManager.builder();</span>
<span class="nc" id="L675">                revocationBuilder.setCrlStreams(crlStreams);</span>
<span class="nc" id="L676">                revocationBuilder.setResponderURI(ocspResponder);</span>
<span class="nc" id="L677">                revocationBuilder.setTrustManagerFactory(trustManagerFactory);</span>
<span class="nc" id="L678">                revocationBuilder.setTrustStore(trustStore);</span>
<span class="nc" id="L679">                revocationBuilder.setOnlyEndEntity(onlyLeafCert);</span>
<span class="nc" id="L680">                revocationBuilder.setSoftFail(softFail);</span>
<span class="nc" id="L681">                revocationBuilder.setMaxCertPath(maxCertPath);</span>

<span class="nc bnc" id="L683" title="All 4 branches missed.">                if (crl &amp;&amp; ocsp) {</span>
<span class="nc" id="L684">                    revocationBuilder.setPreferCrls(preferCrls);</span>
<span class="nc" id="L685">                    revocationBuilder.setNoFallback(false);</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">                } else if (crl) {</span>
<span class="nc" id="L687">                    revocationBuilder.setPreferCrls(true);</span>
<span class="nc" id="L688">                    revocationBuilder.setNoFallback(true);</span>
                } else {
<span class="nc" id="L690">                    revocationBuilder.setPreferCrls(false);</span>
<span class="nc" id="L691">                    revocationBuilder.setNoFallback(true);</span>
                }

<span class="nc bnc" id="L694" title="All 2 branches missed.">                if (responderCertAlias != null) {</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">                    KeyStore responderStore = responderStoreSupplier != null ? responderStoreSupplier.get() : trustStore;</span>
<span class="nc" id="L696">                    revocationBuilder.setOcspResponderCert((X509Certificate) responderStore.getCertificate(responderCertAlias));</span>
                }

<span class="nc" id="L699">                return revocationBuilder.build();</span>
            } else {
<span class="nc" id="L701">                trustManagerFactory.init(trustStore);</span>
            }
<span class="nc bnc" id="L703" title="All 2 branches missed.">            for (TrustManager trustManager : trustManagerFactory.getTrustManagers()) {</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">                if (trustManager instanceof X509TrustManager) {</span>
<span class="nc" id="L705">                    return (X509TrustManager) trustManager;</span>
                }
            }
<span class="nc" id="L708">            throw ElytronMessages.log.noDefaultTrustManager();</span>
        }
    }

    private static void parseCertificateRevocationLists(ConfigurationXMLStreamReader reader, TrustManagerBuilder builder, final Version xmlVersion) throws ConfigXMLParseException {
<span class="nc bnc" id="L713" title="All 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="nc" id="L714">            final int tag = reader.nextTag();</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">            if (tag == START_ELEMENT) {</span>
<span class="nc bnc" id="L716" title="All 2 branches missed.">                switch (reader.getLocalName()) {</span>
                    case &quot;certificate-revocation-list&quot;: {
<span class="nc" id="L718">                        parseCertificateRevocationList(reader, builder, xmlVersion, true);</span>
<span class="nc" id="L719">                        break;</span>
                    }
                    default:
<span class="nc" id="L722">                        throw reader.unexpectedElement();</span>
                }
<span class="nc bnc" id="L724" title="All 2 branches missed.">            } else if (tag != END_ELEMENT) {</span>
<span class="nc" id="L725">                throw reader.unexpectedContent();</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="nc" id="L727">                return;</span>
            }
<span class="nc" id="L729">        }</span>
<span class="nc" id="L730">        throw reader.unexpectedDocumentEnd();</span>
    }

    private static void parseCertificateRevocationList(ConfigurationXMLStreamReader reader, TrustManagerBuilder builder, final Version xmlVersion, boolean multipleCrls) throws ConfigXMLParseException {
<span class="nc" id="L734">        final int attributeCount = reader.getAttributeCount();</span>
<span class="nc" id="L735">        String path = null;</span>
<span class="nc" id="L736">        ExceptionSupplier&lt;InputStream, IOException&gt; resourceSource = null;</span>
<span class="nc" id="L737">        URI uriSource = null;</span>
<span class="nc" id="L738">        boolean gotSource = false;</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">        for (int i = 0; i &lt; attributeCount; i ++) {</span>
<span class="nc" id="L740">            checkAttributeNamespace(reader, i);</span>
<span class="nc bnc" id="L741" title="All 3 branches missed.">            switch (reader.getAttributeLocalName(i)) {</span>
                case &quot;path&quot;: {
<span class="nc bnc" id="L743" title="All 2 branches missed.">                    if (gotSource) throw reader.unexpectedAttribute(i);</span>
<span class="nc" id="L744">                    gotSource = true;</span>
<span class="nc" id="L745">                    path = reader.getAttributeValueResolved(i);</span>
<span class="nc" id="L746">                    break;</span>
                }
                case &quot;maximum-cert-path&quot;: { //Deprecated
<span class="nc bnc" id="L749" title="All 4 branches missed.">                    if (builder.isMaxCertPathSet() || multipleCrls) throw reader.unexpectedAttribute(i);</span>
<span class="nc" id="L750">                    xmlLog.xmlDeprecatedElement(&quot;maximum-cert-path&quot;, reader.getLocation());</span>
                    // only set the maximum-cert-path inside a CRL if it's a single CRL.
<span class="nc" id="L752">                    builder.setMaxCertPath(reader.getIntAttributeValueResolved(i, 1, Integer.MAX_VALUE));</span>
<span class="nc" id="L753">                    break;</span>
                }
<span class="nc" id="L755">                default: throw reader.unexpectedAttribute(i);</span>
            }
        }
<span class="nc bnc" id="L758" title="All 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="nc" id="L759">            final int tag = reader.nextTag();</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">            if (tag == START_ELEMENT) {</span>
<span class="nc" id="L761">                checkElementNamespace(reader, xmlVersion);</span>
<span class="nc bnc" id="L762" title="All 3 branches missed.">                switch (reader.getLocalName()) {</span>
                    case &quot;resource&quot;: {
<span class="nc bnc" id="L764" title="All 4 branches missed.">                        if (gotSource || !xmlVersion.isAtLeast(Version.VERSION_1_1)) {</span>
<span class="nc" id="L765">                            throw reader.unexpectedElement();</span>
                        }
<span class="nc" id="L767">                        gotSource = true;</span>
<span class="nc" id="L768">                        resourceSource = parseResourceType(reader, xmlVersion);</span>
<span class="nc" id="L769">                        break;</span>
                    }
                    case &quot;uri&quot;: {
<span class="nc bnc" id="L772" title="All 4 branches missed.">                        if (gotSource || !xmlVersion.isAtLeast(Version.VERSION_1_1)) {</span>
<span class="nc" id="L773">                            throw reader.unexpectedElement();</span>
                        }
<span class="nc" id="L775">                        gotSource = true;</span>
<span class="nc" id="L776">                        uriSource = parseUriType(reader);</span>
<span class="nc" id="L777">                        break;</span>
                    }
<span class="nc" id="L779">                    default: throw reader.unexpectedElement();</span>
                }
<span class="nc bnc" id="L781" title="All 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="nc" id="L782">                builder.setCrl();</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">                if (gotSource) {</span>
                    try {
<span class="nc bnc" id="L785" title="All 2 branches missed.">                        if (path != null) builder.addCrlStream(new FileInputStream(path));</span>
<span class="nc bnc" id="L786" title="All 2 branches missed.">                        else if (resourceSource != null) builder.addCrlStream(resourceSource.get());</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">                        else if (uriSource != null) builder.addCrlStream(uriSource.toURL().openStream());</span>
<span class="nc" id="L788">                    } catch (IOException e) {</span>
<span class="nc" id="L789">                        throw new ConfigXMLParseException(e);</span>
<span class="nc" id="L790">                    }</span>
                }
<span class="nc" id="L792">                return;</span>
            } else {
<span class="nc" id="L794">                throw reader.unexpectedContent();</span>
            }
<span class="nc" id="L796">        }</span>
<span class="nc" id="L797">        throw reader.unexpectedDocumentEnd();</span>
    }

    private static void parseOcsp(ConfigurationXMLStreamReader reader, TrustManagerBuilder builder, Map&lt;String, ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt;&gt; keyStoresMap) throws ConfigXMLParseException {
<span class="nc" id="L801">        final int attributeCount = reader.getAttributeCount();</span>
<span class="nc" id="L802">        boolean gotPreferCrls = false;</span>
<span class="nc" id="L803">        boolean gotResponder = false;</span>
<span class="nc" id="L804">        boolean gotResponderCertAlias = false;</span>
<span class="nc" id="L805">        boolean gotResponderKeystore = false;</span>
<span class="nc" id="L806">        builder.setOcsp();</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">        for (int i = 0; i &lt; attributeCount; i ++) {</span>
<span class="nc" id="L808">            checkAttributeNamespace(reader, i);</span>
<span class="nc bnc" id="L809" title="All 5 branches missed.">            switch (reader.getAttributeLocalName(i)) {</span>
                case &quot;responder&quot;: {
<span class="nc bnc" id="L811" title="All 2 branches missed.">                    if (gotResponder) throw reader.unexpectedAttribute(i);</span>
<span class="nc" id="L812">                    builder.setOcspResponder(reader.getURIAttributeValueResolved(i));</span>
<span class="nc" id="L813">                    gotResponder = true;</span>
<span class="nc" id="L814">                    break;</span>
                }
                case &quot;prefer-crls&quot;: {
<span class="nc bnc" id="L817" title="All 2 branches missed.">                    if (gotPreferCrls) throw reader.unexpectedAttribute(i);</span>
<span class="nc" id="L818">                    builder.setPreferCrls(reader.getBooleanAttributeValueResolved(i));</span>
<span class="nc" id="L819">                    gotPreferCrls = true;</span>
<span class="nc" id="L820">                    break;</span>
                }
                case &quot;responder-certificate&quot;: {
<span class="nc bnc" id="L823" title="All 2 branches missed.">                    if (gotResponderCertAlias) throw reader.unexpectedAttribute(i);</span>
<span class="nc" id="L824">                    builder.setOcspRescponderCertAlias(reader.getAttributeValueResolved(i));</span>
<span class="nc" id="L825">                    gotResponderCertAlias = true;</span>
<span class="nc" id="L826">                    break;</span>
                }
                case &quot;responder-keystore&quot;: {
<span class="nc bnc" id="L829" title="All 2 branches missed.">                    if (gotResponderKeystore) throw reader.unexpectedAttribute(i);</span>
<span class="nc" id="L830">                    builder.setOcspResponderCertKeystoreSupplier(keyStoresMap.get(reader.getAttributeValueResolved(i)));</span>
<span class="nc" id="L831">                    gotResponderKeystore = true;</span>
<span class="nc" id="L832">                    break;</span>
                }
<span class="nc" id="L834">                default: throw reader.unexpectedAttribute(i);</span>
            }
        }
<span class="nc bnc" id="L837" title="All 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="nc" id="L838">            final int tag = reader.nextTag();</span>
<span class="nc bnc" id="L839" title="All 2 branches missed.">            if (tag == END_ELEMENT) {</span>
<span class="nc" id="L840">                return;</span>
            } else {
<span class="nc" id="L842">                throw reader.unexpectedContent();</span>
            }
        }
<span class="nc" id="L845">        throw reader.unexpectedDocumentEnd();</span>
    }

    private static ExceptionSupplier&lt;X509ExtendedKeyManager, ConfigXMLParseException&gt; parseKeyStoreSslCertificate(ConfigurationXMLStreamReader reader,
            final Version xmlVersion, Map&lt;String, ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt;&gt; keyStoresMap,
            final Map&lt;String, ExceptionSupplier&lt;CredentialStore, ConfigXMLParseException&gt;&gt; credentialStoresMap, final Supplier&lt;Provider[]&gt; providers)
            throws ConfigXMLParseException {
<span class="fc" id="L852">        final int attributeCount = reader.getAttributeCount();</span>
<span class="fc" id="L853">        final XMLLocation location = reader.getLocation();</span>
<span class="fc" id="L854">        String providerName = null;</span>
<span class="fc" id="L855">        String algorithm = null;</span>
<span class="fc" id="L856">        String keyStoreName = null;</span>
<span class="fc" id="L857">        String alias = null;</span>
<span class="fc bfc" id="L858" title="All 2 branches covered.">        for (int i = 0; i &lt; attributeCount; i ++) {</span>
<span class="fc" id="L859">            checkAttributeNamespace(reader, i);</span>
<span class="pc bpc" id="L860" title="3 of 5 branches missed.">            switch (reader.getAttributeLocalName(i)) {</span>
                case &quot;provider-name&quot;: {
<span class="nc bnc" id="L862" title="All 4 branches missed.">                    if (providerName != null || !xmlVersion.isAtLeast(Version.VERSION_1_2)) throw reader.unexpectedAttribute(i);</span>
<span class="nc" id="L863">                    providerName = reader.getAttributeValueResolved(i);</span>
<span class="nc" id="L864">                    break;</span>
                }
                case &quot;algorithm&quot;: {
<span class="nc bnc" id="L867" title="All 4 branches missed.">                    if (providerName != null || !xmlVersion.isAtLeast(Version.VERSION_1_2)) throw reader.unexpectedAttribute(i);</span>
<span class="nc bnc" id="L868" title="All 2 branches missed.">                    if (algorithm != null) throw reader.unexpectedAttribute(i);</span>
<span class="nc" id="L869">                    algorithm = reader.getAttributeValueResolved(i);</span>
<span class="nc" id="L870">                    break;</span>
                }
                case &quot;key-store-name&quot;: {
<span class="pc bpc" id="L873" title="1 of 2 branches missed.">                    if (keyStoreName != null) throw reader.unexpectedAttribute(i);</span>
<span class="fc" id="L874">                    keyStoreName = reader.getAttributeValueResolved(i);</span>
<span class="fc" id="L875">                    break;</span>
                }
                case &quot;alias&quot;: {
<span class="pc bpc" id="L878" title="1 of 2 branches missed.">                    if (alias != null) throw reader.unexpectedAttribute(i);</span>
<span class="fc" id="L879">                    alias = reader.getAttributeValueResolved(i);</span>
<span class="fc" id="L880">                    break;</span>
                }
<span class="nc" id="L882">                default: throw reader.unexpectedAttribute(i);</span>
            }
        }
<span class="pc bpc" id="L885" title="1 of 2 branches missed.">        if (keyStoreName == null) {</span>
<span class="nc" id="L886">            throw missingAttribute(reader, &quot;key-store-name&quot;);</span>
        }
<span class="fc" id="L888">        ExceptionSupplier&lt;KeyStore.Entry, ConfigXMLParseException&gt; keyStoreCredential = null;</span>
<span class="pc bpc" id="L889" title="1 of 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="fc" id="L890">            final int tag = reader.nextTag();</span>
<span class="fc bfc" id="L891" title="All 2 branches covered.">            if (tag == START_ELEMENT) {</span>
<span class="fc" id="L892">                checkElementNamespace(reader, xmlVersion);</span>
<span class="pc bpc" id="L893" title="3 of 5 branches missed.">                switch (reader.getLocalName()) {</span>
                    case &quot;key-store-credential&quot;: {
<span class="nc bnc" id="L895" title="All 2 branches missed.">                        if (keyStoreCredential != null) throw reader.unexpectedElement();</span>
<span class="nc" id="L896">                        keyStoreCredential = parseKeyStoreRefType(reader, xmlVersion, keyStoresMap, credentialStoresMap, providers);</span>
<span class="nc" id="L897">                        break;</span>
                    }
                    case &quot;key-store-clear-password&quot;: {
<span class="pc bpc" id="L900" title="1 of 2 branches missed.">                        if (keyStoreCredential != null) throw reader.unexpectedElement();</span>
<span class="fc" id="L901">                        ExceptionSupplier&lt;Password, ConfigXMLParseException&gt; credential = parseClearPassword(reader, providers);</span>
<span class="fc" id="L902">                        keyStoreCredential = () -&gt; new PasswordEntry(credential.get());</span>
<span class="fc" id="L903">                        break;</span>
                    }
                    case &quot;key-store-masked-password&quot;: {
<span class="pc bpc" id="L906" title="2 of 4 branches missed.">                        if (keyStoreCredential != null || !xmlVersion.isAtLeast(Version.VERSION_1_4)) throw reader.unexpectedElement();</span>
<span class="fc" id="L907">                        ExceptionSupplier&lt;Password, ConfigXMLParseException&gt; credential = parseMaskedPassword(reader, providers);</span>
<span class="fc" id="L908">                        keyStoreCredential = () -&gt; new PasswordEntry(credential.get());</span>
<span class="fc" id="L909">                        break;</span>
                    }
                    case &quot;credential-store-reference&quot;: {
<span class="nc bnc" id="L912" title="All 4 branches missed.">                        if (keyStoreCredential != null || !xmlVersion.isAtLeast(Version.VERSION_1_0_1)) {</span>
<span class="nc" id="L913">                            throw reader.unexpectedElement();</span>
                        }
<span class="nc" id="L915">                        final XMLLocation nestedLocation = reader.getLocation();</span>
<span class="nc" id="L916">                        ExceptionSupplier&lt;CredentialSource, ConfigXMLParseException&gt; credentialSourceSupplier = parseCredentialStoreRefType(reader, credentialStoresMap);</span>
<span class="nc" id="L917">                        keyStoreCredential = () -&gt; {</span>
                            try {
<span class="nc" id="L919">                                PasswordCredential passwordCredential = credentialSourceSupplier.get().getCredential(PasswordCredential.class);</span>
<span class="nc bnc" id="L920" title="All 2 branches missed.">                                if (passwordCredential == null) {</span>
<span class="nc" id="L921">                                    throw new ConfigXMLParseException(xmlLog.couldNotObtainCredential(), reader);</span>
                                }
<span class="nc" id="L923">                                return new PasswordEntry(passwordCredential.getPassword());</span>
<span class="nc" id="L924">                            } catch (IOException e) {</span>
<span class="nc" id="L925">                                throw xmlLog.xmlFailedToCreateCredential(nestedLocation, e);</span>
                            }
                        };
<span class="nc" id="L928">                        break;</span>
                    }
<span class="pc" id="L930">                    default: throw reader.unexpectedElement();</span>
                }
<span class="pc bpc" id="L932" title="1 of 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="fc" id="L933">                final ExceptionSupplier&lt;KeyStore.Entry, ConfigXMLParseException&gt; finalKeyStoreCredential = keyStoreCredential;</span>
<span class="fc" id="L934">                final String finalAlgorithm = algorithm;</span>
<span class="fc" id="L935">                final String finalProviderName = providerName;</span>
<span class="fc" id="L936">                final String finalKeyStoreName = keyStoreName;</span>
<span class="fc" id="L937">                final String finalAlias = alias;</span>
<span class="fc" id="L938">                return () -&gt; {</span>
                    try {
<span class="fc" id="L940">                        final ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt; keyStoreSupplier = keyStoresMap.get(finalKeyStoreName);</span>
<span class="pc bpc" id="L941" title="1 of 2 branches missed.">                        if (keyStoreSupplier == null) {</span>
<span class="nc" id="L942">                            throw xmlLog.xmlUnknownKeyStoreSpecified(location);</span>
                        }
<span class="fc" id="L944">                        KeyStore keyStore = keyStoreSupplier.get();</span>

<span class="pc bpc" id="L946" title="1 of 2 branches missed.">                        if (xmlLog.isTraceEnabled()) {</span>
<span class="nc" id="L947">                            xmlLog.tracef(&quot;Using KeyStore [%s] containing aliases %s&quot;, finalKeyStoreName, aliasesToString(keyStore.aliases()));</span>
                        }

<span class="fc bfc" id="L950" title="All 2 branches covered.">                        if (finalAlias != null) {</span>
<span class="fc" id="L951">                            keyStore = FilteringKeyStore.filteringKeyStore(keyStore, AliasFilter.fromString(finalAlias));</span>
<span class="pc bpc" id="L952" title="1 of 2 branches missed.">                            if (xmlLog.isTraceEnabled()) xmlLog.tracef(&quot;Filtered aliases %s&quot;, aliasesToString(keyStore.aliases()));</span>
<span class="pc bpc" id="L953" title="1 of 2 branches missed.">                            if (keyStore.size() &lt; 1) throw xmlLog.keyStoreEntryMissing(location, finalAlias);</span>
                        }

<span class="pc bpc" id="L956" title="1 of 2 branches missed.">                        String algorithmResolved = finalAlgorithm != null ? finalAlgorithm : KeyManagerFactory.getDefaultAlgorithm();</span>
<span class="fc" id="L957">                        Provider provider = findProvider(providers, finalProviderName, KeyManagerFactory.class, algorithmResolved);</span>
<span class="pc bpc" id="L958" title="1 of 2 branches missed.">                        if (provider == null) {</span>
<span class="nc" id="L959">                            throw xmlLog.xmlUnableToIdentifyProvider(location, finalProviderName, &quot;KeyManagerFactory&quot;, algorithmResolved);</span>
                        }

<span class="fc" id="L962">                        char[] password = keyStoreCredentialToPassword(finalKeyStoreCredential, providers);</span>

<span class="fc" id="L964">                        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(algorithmResolved, provider);</span>
<span class="fc" id="L965">                        keyManagerFactory.init(keyStoreSupplier.get(), password);</span>

<span class="pc bpc" id="L967" title="1 of 2 branches missed.">                        for (KeyManager keyManager : keyManagerFactory.getKeyManagers()) {</span>
<span class="pc bpc" id="L968" title="1 of 2 branches missed.">                            if (keyManager instanceof X509ExtendedKeyManager) {</span>
<span class="fc" id="L969">                                return (X509ExtendedKeyManager) keyManager;</span>
                            }
                        }
<span class="nc" id="L972">                        throw ElytronMessages.log.noDefaultKeyManager();</span>
<span class="nc" id="L973">                    } catch (GeneralSecurityException | IOException e) {</span>
<span class="nc" id="L974">                        throw xmlLog.xmlFailedToLoadKeyStoreData(location, e);</span>
                    }
                };
            } else {
<span class="nc" id="L978">                throw reader.unexpectedContent();</span>
            }
<span class="fc" id="L980">        }</span>
<span class="nc" id="L981">        throw reader.unexpectedDocumentEnd();</span>
    }

    private static String aliasesToString(Enumeration&lt;String&gt; aliases) {
<span class="nc" id="L985">        StringBuilder builder = new StringBuilder(&quot;[&quot;);</span>
<span class="nc bnc" id="L986" title="All 2 branches missed.">        while (aliases.hasMoreElements()) {</span>
<span class="nc" id="L987">            builder.append(aliases.nextElement());</span>
<span class="nc bnc" id="L988" title="All 2 branches missed.">            if (aliases.hasMoreElements()) builder.append(&quot;, &quot;);</span>
        }
<span class="nc" id="L990">        return builder.append(']').toString();</span>
    }

    private static void parseTrustManager(ConfigurationXMLStreamReader reader, TrustManagerBuilder builder, final Version xmlVersion) throws ConfigXMLParseException {
<span class="nc" id="L994">        final int attributeCount = reader.getAttributeCount();</span>
<span class="nc" id="L995">        String providerName = null;</span>
<span class="nc" id="L996">        String algorithm = null;</span>
<span class="nc" id="L997">        boolean gotSoftFail = false;</span>
<span class="nc" id="L998">        boolean gotOnlyLeafCert = false;</span>
<span class="nc bnc" id="L999" title="All 2 branches missed.">        for (int i = 0; i &lt; attributeCount; i ++) {</span>
<span class="nc" id="L1000">            checkAttributeNamespace(reader, i);</span>
<span class="nc bnc" id="L1001" title="All 6 branches missed.">            switch (reader.getAttributeLocalName(i)) {</span>
                case &quot;provider-name&quot;: {
<span class="nc bnc" id="L1003" title="All 2 branches missed.">                    if (providerName != null) throw reader.unexpectedAttribute(i);</span>
<span class="nc" id="L1004">                    providerName = reader.getAttributeValueResolved(i);</span>
<span class="nc" id="L1005">                    break;</span>
                }
                case &quot;algorithm&quot;: {
<span class="nc bnc" id="L1008" title="All 2 branches missed.">                    if (algorithm != null) throw reader.unexpectedAttribute(i);</span>
<span class="nc" id="L1009">                    algorithm = reader.getAttributeValueResolved(i);</span>
<span class="nc" id="L1010">                    break;</span>
                }
                case &quot;soft-fail&quot;: {
<span class="nc bnc" id="L1013" title="All 4 branches missed.">                    if (gotSoftFail || !xmlVersion.isAtLeast(Version.VERSION_1_4)) {</span>
<span class="nc" id="L1014">                        throw reader.unexpectedAttribute(i);</span>
                    }
<span class="nc" id="L1016">                    gotSoftFail = true;</span>
<span class="nc" id="L1017">                    builder.setSoftFail(reader.getBooleanAttributeValueResolved(i));</span>
<span class="nc" id="L1018">                    break;</span>
                }
                case &quot;maximum-cert-path&quot;: {
<span class="nc bnc" id="L1021" title="All 4 branches missed.">                    if (builder.isMaxCertPathSet() || !xmlVersion.isAtLeast(Version.VERSION_1_4)) {</span>
<span class="nc" id="L1022">                        throw reader.unexpectedAttribute(i);</span>
                    }
<span class="nc" id="L1024">                    builder.setMaxCertPath(reader.getIntAttributeValueResolved(i, 1, Integer.MAX_VALUE));</span>
<span class="nc" id="L1025">                    break;</span>
                }
                case &quot;only-leaf-cert&quot;: {
<span class="nc bnc" id="L1028" title="All 4 branches missed.">                    if (gotOnlyLeafCert || !xmlVersion.isAtLeast(Version.VERSION_1_4)) {</span>
<span class="nc" id="L1029">                        throw reader.unexpectedAttribute(i);</span>
                    }
<span class="nc" id="L1031">                    gotOnlyLeafCert = true;</span>
<span class="nc" id="L1032">                    builder.setOnlyLeafCert(reader.getBooleanAttributeValueResolved(i));</span>
<span class="nc" id="L1033">                    break;</span>
                }
<span class="nc" id="L1035">                default: throw reader.unexpectedAttribute(i);</span>
            }
        }
<span class="nc bnc" id="L1038" title="All 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="nc" id="L1039">            final int tag = reader.nextTag();</span>
<span class="nc bnc" id="L1040" title="All 2 branches missed.">            if (tag == START_ELEMENT) {</span>
<span class="nc" id="L1041">                throw reader.unexpectedElement();</span>
<span class="nc bnc" id="L1042" title="All 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="nc" id="L1043">                builder.setProviderName(providerName);</span>
<span class="nc" id="L1044">                builder.setAlgorithm(algorithm);</span>
<span class="nc" id="L1045">                return;</span>
            } else {
<span class="nc" id="L1047">                throw reader.unexpectedContent();</span>
            }
        }
<span class="nc" id="L1050">        throw reader.unexpectedDocumentEnd();</span>
    }

    static ExceptionUnaryOperator&lt;RuleNode&lt;SecurityFactory&lt;SSLContext&gt;&gt;, ConfigXMLParseException&gt; parseSslContextRuleType(final ConfigurationXMLStreamReader reader, final Version xmlVersion, final Map&lt;String, ExceptionSupplier&lt;SecurityFactory&lt;SSLContext&gt;, ConfigXMLParseException&gt;&gt; sslContextsMap) throws ConfigXMLParseException {
<span class="fc" id="L1054">        final String attributeName = &quot;use-ssl-context&quot;;</span>
<span class="fc" id="L1055">        final String name = requireSingleAttribute(reader, attributeName);</span>
<span class="fc" id="L1056">        final XMLLocation location = reader.getLocation();</span>
<span class="fc" id="L1057">        final MatchRule rule = parseAbstractMatchRuleType(reader, xmlVersion);</span>
<span class="fc" id="L1058">        return next -&gt; {</span>
<span class="fc" id="L1059">            final ExceptionSupplier&lt;SecurityFactory&lt;SSLContext&gt;, ConfigXMLParseException&gt; factory = sslContextsMap.get(name);</span>
<span class="pc bpc" id="L1060" title="1 of 2 branches missed.">            if (factory == null) throw xmlLog.xmlUnknownSslContextSpecified(location, name);</span>
<span class="fc" id="L1061">            return new RuleNode&lt;&gt;(next, rule, factory.get());</span>
        };
    }

    static ExceptionUnaryOperator&lt;RuleNode&lt;AuthenticationConfiguration&gt;, ConfigXMLParseException&gt; parseAuthenticationRuleType(final ConfigurationXMLStreamReader reader, final Version xmlVersion, final Map&lt;String, ExceptionSupplier&lt;AuthenticationConfiguration, ConfigXMLParseException&gt;&gt; authenticationConfigurationsMap) throws ConfigXMLParseException {
<span class="fc" id="L1066">        final String attributeName = &quot;use-configuration&quot;;</span>
<span class="fc" id="L1067">        final String name = requireSingleAttribute(reader, attributeName);</span>
<span class="fc" id="L1068">        final XMLLocation location = reader.getLocation();</span>
<span class="fc" id="L1069">        final MatchRule rule = parseAbstractMatchRuleType(reader, xmlVersion);</span>
<span class="fc" id="L1070">        return next -&gt; {</span>
<span class="fc" id="L1071">            final ExceptionSupplier&lt;AuthenticationConfiguration, ConfigXMLParseException&gt; factory = authenticationConfigurationsMap.get(name);</span>
<span class="pc bpc" id="L1072" title="1 of 2 branches missed.">            if (factory == null) throw xmlLog.xmlUnknownAuthenticationConfigurationSpecified(location, name);</span>
<span class="fc" id="L1073">            return new RuleNode&lt;&gt;(next, rule, factory.get());</span>
        };
    }

    static &lt;C&gt; ExceptionSupplier&lt;RuleNode&lt;C&gt;, ConfigXMLParseException&gt; parseRulesType(ConfigurationXMLStreamReader reader, final Version xmlVersion,
            final Map&lt;String, ExceptionSupplier&lt;C, ConfigXMLParseException&gt;&gt; configurations, ExceptionBiFunction&lt;ConfigurationXMLStreamReader, Map&lt;String, ExceptionSupplier&lt;C, ConfigXMLParseException&gt;&gt;, ExceptionUnaryOperator&lt;RuleNode&lt;C&gt;, ConfigXMLParseException&gt;, ConfigXMLParseException&gt; ruleParseFunction)
            throws ConfigXMLParseException {
<span class="fc" id="L1080">        requireNoAttributes(reader);</span>
<span class="fc" id="L1081">        final List&lt;ExceptionUnaryOperator&lt;RuleNode&lt;C&gt;, ConfigXMLParseException&gt;&gt; rulesList = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L1082" title="1 of 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="fc" id="L1083">            final int tag = reader.nextTag();</span>
<span class="fc bfc" id="L1084" title="All 2 branches covered.">            if (tag == START_ELEMENT) {</span>
<span class="fc" id="L1085">                checkElementNamespace(reader, xmlVersion);</span>
<span class="pc bpc" id="L1086" title="1 of 2 branches missed.">                switch (reader.getLocalName()) {</span>
                    case &quot;rule&quot;: {
<span class="fc" id="L1088">                        rulesList.add(ruleParseFunction.apply(reader, configurations));</span>
<span class="fc" id="L1089">                        break;</span>
                    }
<span class="pc" id="L1091">                    default: throw reader.unexpectedElement();</span>
                }
<span class="pc bpc" id="L1093" title="1 of 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="fc" id="L1094">                return () -&gt; {</span>
<span class="fc" id="L1095">                    RuleNode&lt;C&gt; node = null;</span>
<span class="fc" id="L1096">                    final ListIterator&lt;ExceptionUnaryOperator&lt;RuleNode&lt;C&gt;, ConfigXMLParseException&gt;&gt; iterator = rulesList.listIterator(rulesList.size());</span>
                    // iterate backwards to build the singly-linked list in constant time
<span class="fc bfc" id="L1098" title="All 2 branches covered.">                    while (iterator.hasPrevious()) {</span>
<span class="fc" id="L1099">                        node = iterator.previous().apply(node);</span>
                    }
<span class="fc" id="L1101">                    return node;</span>
                };
            } else {
<span class="nc" id="L1104">                throw reader.unexpectedContent();</span>
            }
<span class="fc" id="L1106">        }</span>
<span class="nc" id="L1107">        throw reader.unexpectedDocumentEnd();</span>
    }

    static void parseAuthenticationConfigurationType(ConfigurationXMLStreamReader reader, final Version xmlVersion, final Map&lt;String, ExceptionSupplier&lt;AuthenticationConfiguration, ConfigXMLParseException&gt;&gt; authenticationConfigurationsMap,
            final Map&lt;String, ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt;&gt; keyStoresMap, final Map&lt;String, ExceptionSupplier&lt;CredentialStore, ConfigXMLParseException&gt;&gt; credentialStoresMap,
            final Supplier&lt;Provider[]&gt; providers) throws ConfigXMLParseException {
<span class="fc" id="L1113">        final String name = requireSingleAttribute(reader, &quot;name&quot;);</span>
<span class="pc bpc" id="L1114" title="1 of 2 branches missed.">        if (authenticationConfigurationsMap.containsKey(name)) {</span>
<span class="nc" id="L1115">            throw xmlLog.xmlDuplicateAuthenticationConfigurationName(name, reader);</span>
        }

<span class="fc" id="L1118">        ExceptionUnaryOperator&lt;AuthenticationConfiguration, ConfigXMLParseException&gt; configuration = ignored -&gt; AuthenticationConfiguration.empty();</span>
<span class="fc" id="L1119">        DeferredSupplier&lt;Provider[]&gt; providerSupplier = new DeferredSupplier&lt;&gt;(providers);</span>
<span class="fc" id="L1120">        configuration = andThenOp(configuration, parent -&gt; parent.useProviders(providerSupplier));</span>

<span class="fc" id="L1122">        int foundBits = 0;</span>
<span class="pc bpc" id="L1123" title="1 of 2 branches missed.">        if (! reader.hasNext()) {</span>
<span class="nc" id="L1124">            throw reader.unexpectedDocumentEnd();</span>
        }
<span class="pc bpc" id="L1126" title="1 of 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="fc" id="L1127">            int tag = reader.nextTag();</span>
<span class="fc bfc" id="L1128" title="All 2 branches covered.">            if (tag == START_ELEMENT) {</span>
<span class="fc" id="L1129">                checkElementNamespace(reader, xmlVersion);</span>
<span class="pc bpc" id="L1130" title="13 of 16 branches missed.">                switch (reader.getLocalName()) {</span>
                    // -- set --
                    case &quot;set-host&quot;: {
<span class="nc bnc" id="L1133" title="All 2 branches missed.">                        if (isSet(foundBits, 0)) throw reader.unexpectedElement();</span>
<span class="nc" id="L1134">                        foundBits = setBit(foundBits, 0);</span>
<span class="nc" id="L1135">                        final String hostName = parseNameType(reader);</span>
<span class="nc" id="L1136">                        configuration = andThenOp(configuration, parentConfig -&gt; parentConfig.useHost(hostName));</span>
<span class="nc" id="L1137">                        xmlLog.xmlDeprecatedElement(reader.getLocalName(), reader.getLocation());</span>
<span class="nc" id="L1138">                        break;</span>
                    }
                    case &quot;set-port&quot;: {
<span class="nc bnc" id="L1141" title="All 2 branches missed.">                        if (isSet(foundBits, 1)) throw reader.unexpectedElement();</span>
<span class="nc" id="L1142">                        foundBits = setBit(foundBits, 1);</span>
<span class="nc" id="L1143">                        final int port = parsePortType(reader);</span>
<span class="nc" id="L1144">                        configuration = andThenOp(configuration, parentConfig -&gt; parentConfig.usePort(port));</span>
<span class="nc" id="L1145">                        xmlLog.xmlDeprecatedElement(reader.getLocalName(), reader.getLocation());</span>
<span class="nc" id="L1146">                        break;</span>
                    }
                    // these two are a &lt;choice&gt; which is why they share a bit #; you can have only one of them
                    case &quot;set-user-name&quot;: {
<span class="nc bnc" id="L1150" title="All 2 branches missed.">                        if (isSet(foundBits, 2)) throw reader.unexpectedElement();</span>
<span class="nc" id="L1151">                        foundBits = setBit(foundBits, 2);</span>
<span class="nc" id="L1152">                        final String userName = parseNameType(reader);</span>
<span class="nc" id="L1153">                        configuration = andThenOp(configuration, parentConfig -&gt; parentConfig.useName(userName));</span>
<span class="nc" id="L1154">                        break;</span>
                    }
                    case &quot;set-anonymous&quot;: {
<span class="pc bpc" id="L1157" title="1 of 2 branches missed.">                        if (isSet(foundBits, 2)) throw reader.unexpectedElement();</span>
<span class="fc" id="L1158">                        foundBits = setBit(foundBits, 2);</span>
<span class="fc" id="L1159">                        parseEmptyType(reader);</span>
<span class="fc" id="L1160">                        configuration = andThenOp(configuration, AuthenticationConfiguration::useAnonymous);</span>
<span class="fc" id="L1161">                        break;</span>
                    }
                    case &quot;set-mechanism-realm&quot;: {
<span class="nc bnc" id="L1164" title="All 2 branches missed.">                        if (isSet(foundBits, 3)) throw reader.unexpectedElement();</span>
<span class="nc" id="L1165">                        foundBits = setBit(foundBits, 3);</span>
<span class="nc" id="L1166">                        final String realm = parseNameType(reader);</span>
<span class="nc" id="L1167">                        configuration = andThenOp(configuration, parentConfig -&gt; parentConfig.useRealm(realm));</span>
<span class="nc" id="L1168">                        break;</span>
                    }
                    case &quot;rewrite-user-name-regex&quot;: {
<span class="nc bnc" id="L1171" title="All 2 branches missed.">                        if (isSet(foundBits, 4)) throw reader.unexpectedElement();</span>
<span class="nc" id="L1172">                        foundBits = setBit(foundBits, 4);</span>
<span class="nc" id="L1173">                        final NameRewriter nameRewriter = parseRegexSubstitutionType(reader);</span>
<span class="nc" id="L1174">                        configuration = andThenOp(configuration, parentConfig -&gt; parentConfig.rewriteUser(nameRewriter));</span>
<span class="nc" id="L1175">                        break;</span>
                    }
                    case &quot;set-mechanism-properties&quot;: {
<span class="nc bnc" id="L1178" title="All 2 branches missed.">                        if (isSet(foundBits, 5)) throw reader.unexpectedElement();</span>
<span class="nc" id="L1179">                        foundBits = setBit(foundBits, 5);</span>
<span class="nc" id="L1180">                        final Map&lt;String, String&gt; mechanismProperties = parsePropertiesType(reader, xmlVersion);</span>
<span class="nc" id="L1181">                        configuration = andThenOp(configuration, parentConfig -&gt; parentConfig.useSaslMechanismProperties(mechanismProperties, true));</span>
<span class="nc" id="L1182">                        break;</span>
                    }
                    case &quot;sasl-mechanism-selector&quot;: {
<span class="nc bnc" id="L1185" title="All 2 branches missed.">                        if (isSet(foundBits, 6)) throw reader.unexpectedElement();</span>
<span class="nc" id="L1186">                        foundBits = setBit(foundBits, 6);</span>
<span class="nc" id="L1187">                        final SaslMechanismSelector selector = parseSaslMechanismSelectorType(reader);</span>
<span class="nc" id="L1188">                        configuration = andThenOp(configuration, parentConfig -&gt; parentConfig.setSaslMechanismSelector(selector));</span>
<span class="nc" id="L1189">                        break;</span>
                    }
                    case &quot;credentials&quot;: {
<span class="pc bpc" id="L1192" title="1 of 2 branches missed.">                        if (isSet(foundBits, 9)) throw reader.unexpectedElement();</span>
<span class="fc" id="L1193">                        foundBits = setBit(foundBits, 9);</span>
<span class="fc" id="L1194">                        final ExceptionSupplier&lt;CredentialSource, ConfigXMLParseException&gt; credentialSource = parseCredentialsType(reader, xmlVersion, keyStoresMap, credentialStoresMap, providerSupplier);</span>
<span class="fc" id="L1195">                        configuration = andThenOp(configuration, parentConfig -&gt; parentConfig.useCredentials(credentialSource.get()));</span>
<span class="fc" id="L1196">                        break;</span>
                    }
                    case &quot;set-authorization-name&quot;: {
<span class="nc bnc" id="L1199" title="All 2 branches missed.">                        if (isSet(foundBits, 10)) throw reader.unexpectedElement();</span>
<span class="nc" id="L1200">                        foundBits = setBit(foundBits, 10);</span>
<span class="nc" id="L1201">                        final String authName = parseNameType(reader);</span>
<span class="nc" id="L1202">                        configuration = andThenOp(configuration, parentConfig -&gt; parentConfig.useAuthorizationName(authName));</span>
<span class="nc" id="L1203">                        break;</span>
                    }
                    case &quot;providers&quot;: {
<span class="nc bnc" id="L1206" title="All 2 branches missed.">                        if (isSet(foundBits, 11)) throw reader.unexpectedElement();</span>
<span class="nc" id="L1207">                        foundBits = setBit(foundBits, 11);</span>
<span class="nc" id="L1208">                        Supplier&lt;Provider[]&gt; supplier = parseProvidersType(reader, xmlVersion);</span>
<span class="nc bnc" id="L1209" title="All 2 branches missed.">                        if (supplier != null) {</span>
<span class="nc" id="L1210">                            providerSupplier.setSupplier(supplier);</span>
                        }
                        break;
                    }
                    // these two are a &lt;choice&gt; which is why they share a bit #; you can have only one of them
                    case &quot;use-provider-sasl-factory&quot;: {
<span class="nc bnc" id="L1216" title="All 2 branches missed.">                        if (isSet(foundBits, 12)) throw reader.unexpectedElement();</span>
<span class="nc" id="L1217">                        foundBits = setBit(foundBits, 12);</span>
<span class="nc" id="L1218">                        parseEmptyType(reader);</span>
<span class="nc" id="L1219">                        configuration = andThenOp(configuration, AuthenticationConfiguration::useSaslClientFactoryFromProviders);</span>
<span class="nc" id="L1220">                        break;</span>
                    }
                    case &quot;use-service-loader-sasl-factory&quot;: {
<span class="nc bnc" id="L1223" title="All 2 branches missed.">                        if (isSet(foundBits, 12)) throw reader.unexpectedElement();</span>
<span class="nc" id="L1224">                        foundBits = setBit(foundBits, 12);</span>
<span class="nc" id="L1225">                        final String moduleName = parseModuleRefType(reader);</span>
<span class="nc bnc" id="L1226" title="All 2 branches missed.">                        final ClassLoader classLoader = (moduleName == null) ? ElytronXmlParser.class.getClassLoader() : ModuleLoader.getClassLoaderFromModule(reader, moduleName);</span>
<span class="nc" id="L1227">                        configuration = andThenOp(configuration, parentConfig -&gt; parentConfig.useSaslClientFactory(new ServiceLoaderSaslClientFactory(classLoader)));</span>
<span class="nc" id="L1228">                        break;</span>
                    }
                    case &quot;set-protocol&quot;: {
<span class="nc bnc" id="L1231" title="All 2 branches missed.">                        if (isSet(foundBits, 13)) throw reader.unexpectedElement();</span>
<span class="nc" id="L1232">                        foundBits = setBit(foundBits, 13);</span>
<span class="nc" id="L1233">                        final String protocol = parseNameType(reader);</span>
<span class="nc" id="L1234">                        configuration = andThenOp(configuration, parentConfig -&gt; parentConfig.useProtocol(protocol));</span>
<span class="nc" id="L1235">                        xmlLog.xmlDeprecatedElement(reader.getLocalName(), reader.getLocation());</span>
<span class="nc" id="L1236">                        break;</span>
                    }
                    case &quot;webservices&quot;: {
<span class="pc bpc" id="L1239" title="1 of 2 branches missed.">                        if (isSet(foundBits, 14)) throw reader.unexpectedElement();</span>
<span class="fc" id="L1240">                        foundBits = setBit(foundBits, 14);</span>
<span class="fc" id="L1241">                        Map&lt;String, ?&gt; webServices = parseWebServicesType(reader, xmlVersion);</span>
<span class="fc" id="L1242">                        configuration = andThenOp(configuration, parentConfig -&gt; parentConfig.useWebServices(webServices));</span>
<span class="fc" id="L1243">                        break;</span>
                    }
                    default: {
<span class="pc" id="L1246">                        throw reader.unexpectedElement();</span>
                    }
                }
<span class="pc bpc" id="L1249" title="1 of 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="fc" id="L1250">                final ExceptionUnaryOperator&lt;AuthenticationConfiguration, ConfigXMLParseException&gt; finalConfiguration = configuration;</span>
<span class="fc" id="L1251">                authenticationConfigurationsMap.put(name, () -&gt; finalConfiguration.apply(AuthenticationConfiguration.empty()));</span>
<span class="fc" id="L1252">                return;</span>
            } else {
<span class="nc" id="L1254">                throw reader.unexpectedContent();</span>
            }
<span class="fc" id="L1256">        }</span>
<span class="nc" id="L1257">        throw reader.unexpectedDocumentEnd();</span>
    }

    static Supplier&lt;Provider[]&gt; parseProvidersType(ConfigurationXMLStreamReader reader, final Version xmlVersion) throws ConfigXMLParseException {
<span class="fc" id="L1261">        requireNoAttributes(reader);</span>

<span class="fc" id="L1263">        Supplier&lt;Provider[]&gt; providerSupplier = null;</span>

<span class="fc" id="L1265">        int foundBits = 0;</span>
<span class="pc bpc" id="L1266" title="1 of 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="fc" id="L1267">            final int tag = reader.nextTag();</span>
<span class="fc bfc" id="L1268" title="All 2 branches covered.">            if (tag == START_ELEMENT) {</span>
<span class="fc" id="L1269">                checkElementNamespace(reader, xmlVersion);</span>
<span class="pc bpc" id="L1270" title="2 of 3 branches missed.">                switch (reader.getLocalName()) {</span>
                    case &quot;global&quot;: {
<span class="pc bpc" id="L1272" title="1 of 2 branches missed.">                        if (isSet(foundBits, 1)) throw reader.unexpectedElement();</span>
<span class="fc" id="L1273">                        foundBits = setBit(foundBits, 1);</span>
<span class="fc" id="L1274">                        parseEmptyType(reader);</span>
<span class="pc bpc" id="L1275" title="1 of 2 branches missed.">                        providerSupplier = providerSupplier == null ? INSTALLED_PROVIDERS : ProviderUtil.aggregate(providerSupplier, INSTALLED_PROVIDERS);</span>
<span class="fc" id="L1276">                        break;</span>
                    }
                    case &quot;use-service-loader&quot;: {
<span class="nc bnc" id="L1279" title="All 2 branches missed.">                        if (isSet(foundBits, 2)) throw reader.unexpectedElement();</span>
<span class="nc" id="L1280">                        foundBits = setBit(foundBits, 2);</span>
<span class="nc" id="L1281">                        final String moduleName = parseModuleRefType(reader);</span>
<span class="nc bnc" id="L1282" title="All 2 branches missed.">                        Supplier&lt;Provider[]&gt; serviceLoaderSupplier = (moduleName == null) ?</span>
<span class="nc" id="L1283">                                ELYTRON_PROVIDER_SUPPLIER :</span>
<span class="nc" id="L1284">                                new ProviderServiceLoaderSupplier(ModuleLoader.getClassLoaderFromModule(reader, moduleName));</span>
<span class="nc bnc" id="L1285" title="All 2 branches missed.">                        providerSupplier = providerSupplier == null ? serviceLoaderSupplier : ProviderUtil.aggregate(providerSupplier, serviceLoaderSupplier);</span>
<span class="nc" id="L1286">                        break;</span>
                    }
<span class="pc" id="L1288">                    default: throw reader.unexpectedElement();</span>
                }
<span class="pc bpc" id="L1290" title="1 of 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="fc" id="L1291">                return providerSupplier;</span>
            } else {
<span class="nc" id="L1293">                throw reader.unexpectedContent();</span>
            }
<span class="fc" id="L1295">        }</span>
<span class="nc" id="L1296">        throw reader.unexpectedDocumentEnd();</span>
    }

    static Map&lt;String, ?&gt; parseWebServicesType(ConfigurationXMLStreamReader reader, final Version xmlVersion) throws ConfigXMLParseException {
<span class="fc" id="L1300">        requireNoAttributes(reader);</span>

<span class="fc" id="L1302">        int foundBits = 0;</span>
<span class="pc bpc" id="L1303" title="1 of 2 branches missed.">        if (! reader.hasNext()) {</span>
<span class="nc" id="L1304">            throw reader.unexpectedDocumentEnd();</span>
        }
<span class="fc" id="L1306">        Map&lt;String, String&gt; propertiesMap = new HashMap&lt;&gt;();</span>

<span class="pc bpc" id="L1308" title="1 of 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="fc" id="L1309">            final int tag = reader.nextTag();</span>
<span class="fc bfc" id="L1310" title="All 2 branches covered.">            if (tag == START_ELEMENT) {</span>
<span class="fc" id="L1311">                checkElementNamespace(reader, xmlVersion);</span>
<span class="pc bpc" id="L1312" title="1 of 3 branches missed.">                switch (reader.getLocalName()) {</span>
                    case &quot;set-http-mechanism&quot;: {
<span class="pc bpc" id="L1314" title="1 of 2 branches missed.">                        if (isSet(foundBits, 0)) throw reader.unexpectedElement();</span>
<span class="fc" id="L1315">                        foundBits = setBit(foundBits, 0);</span>
<span class="fc" id="L1316">                        final String httpMechName = parseNameType(reader);</span>
<span class="fc" id="L1317">                        propertiesMap.put(&quot;http-mechanism&quot;, httpMechName);</span>
<span class="fc" id="L1318">                        break;</span>
                    }
                    case &quot;set-ws-security-type&quot;: {
<span class="pc bpc" id="L1321" title="1 of 2 branches missed.">                        if (isSet(foundBits, 1)) throw reader.unexpectedElement();</span>
<span class="fc" id="L1322">                        foundBits = setBit(foundBits, 1);</span>
<span class="fc" id="L1323">                        final String wsSecurityType = parseNameType(reader);</span>
<span class="fc" id="L1324">                        propertiesMap.put(&quot;ws-security-type&quot;, wsSecurityType);</span>
<span class="fc" id="L1325">                        break;</span>
                    }
<span class="pc" id="L1327">                    default: throw reader.unexpectedElement();</span>
                }
<span class="pc bpc" id="L1329" title="1 of 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="fc" id="L1330">                return propertiesMap;</span>
            } else {
<span class="nc" id="L1332">                throw reader.unexpectedContent();</span>
            }
<span class="fc" id="L1334">        }</span>
<span class="nc" id="L1335">        throw reader.unexpectedDocumentEnd();</span>
    }

    /**
     * Parse the XML match-rule group.  On return, the reader will be positioned either at a start tag for an element
     * that is not included in this group, or at an end tag.
     *
     * @param reader the XML reader
     * @param xmlVersion the version of parsed XML
     * @return the parsed match rule
     * @throws ConfigXMLParseException if the resource failed to be parsed
     */
    static MatchRule parseAbstractMatchRuleType(ConfigurationXMLStreamReader reader, final Version xmlVersion) throws ConfigXMLParseException {
<span class="fc" id="L1348">        MatchRule rule = MatchRule.ALL;</span>
<span class="fc" id="L1349">        int foundBits = 0;</span>
<span class="pc bpc" id="L1350" title="1 of 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="fc" id="L1351">            final int tag = reader.nextTag();</span>
<span class="fc bfc" id="L1352" title="All 2 branches covered.">            if (tag == START_ELEMENT) {</span>
<span class="fc" id="L1353">                checkElementNamespace(reader, xmlVersion);</span>
<span class="pc bpc" id="L1354" title="8 of 10 branches missed.">                switch (reader.getLocalName()) {</span>
                    // -- match --
                    case &quot;match-no-user&quot;: {
<span class="nc bnc" id="L1357" title="All 2 branches missed.">                        if (isSet(foundBits, 0)) throw reader.unexpectedElement();</span>
<span class="nc" id="L1358">                        foundBits = setBit(foundBits, 0);</span>
<span class="nc" id="L1359">                        parseEmptyType(reader);</span>
<span class="nc" id="L1360">                        rule = rule.matchNoUser();</span>
<span class="nc" id="L1361">                        break;</span>
                    }
                    case &quot;match-user&quot;: {
<span class="nc bnc" id="L1364" title="All 2 branches missed.">                        if (isSet(foundBits, 0)) throw reader.unexpectedElement();</span>
<span class="nc" id="L1365">                        foundBits = setBit(foundBits, 0);</span>
<span class="nc" id="L1366">                        rule = rule.matchUser(parseNameType(reader));</span>
<span class="nc" id="L1367">                        break;</span>
                    }
                    case &quot;match-protocol&quot;: {
<span class="nc bnc" id="L1370" title="All 2 branches missed.">                        if (isSet(foundBits, 1)) throw reader.unexpectedElement();</span>
<span class="nc" id="L1371">                        foundBits = setBit(foundBits, 1);</span>
<span class="nc" id="L1372">                        rule = rule.matchProtocol(parseNameType(reader));</span>
<span class="nc" id="L1373">                        break;</span>
                    }
                    case &quot;match-host&quot;: {
<span class="pc bpc" id="L1376" title="1 of 2 branches missed.">                        if (isSet(foundBits, 2)) throw reader.unexpectedElement();</span>
<span class="fc" id="L1377">                        foundBits = setBit(foundBits, 2);</span>
<span class="fc" id="L1378">                        rule = rule.matchHost(parseNameType(reader));</span>
<span class="fc" id="L1379">                        break;</span>
                    }
                    case &quot;match-path&quot;: {
<span class="nc bnc" id="L1382" title="All 2 branches missed.">                        if (isSet(foundBits, 3)) throw reader.unexpectedElement();</span>
<span class="nc" id="L1383">                        foundBits = setBit(foundBits, 3);</span>
<span class="nc" id="L1384">                        rule = rule.matchPath(parseNameType(reader));</span>
<span class="nc" id="L1385">                        break;</span>
                    }
                    case &quot;match-port&quot;: {
<span class="pc bpc" id="L1388" title="1 of 2 branches missed.">                        if (isSet(foundBits, 4)) throw reader.unexpectedElement();</span>
<span class="fc" id="L1389">                        foundBits = setBit(foundBits, 4);</span>
<span class="fc" id="L1390">                        rule = rule.matchPort(parsePortType(reader));</span>
<span class="fc" id="L1391">                        break;</span>
                    }
                    case &quot;match-urn&quot;: {
<span class="nc bnc" id="L1394" title="All 2 branches missed.">                        if (isSet(foundBits, 5)) throw reader.unexpectedElement();</span>
<span class="nc" id="L1395">                        foundBits = setBit(foundBits, 5);</span>
<span class="nc" id="L1396">                        rule = rule.matchUrnName(parseNameType(reader));</span>
<span class="nc" id="L1397">                        break;</span>
                    }
                    case &quot;match-domain&quot;: {
<span class="nc bnc" id="L1400" title="All 2 branches missed.">                        if (isSet(foundBits, 6)) throw reader.unexpectedElement();</span>
<span class="nc" id="L1401">                        foundBits = setBit(foundBits, 6);</span>
<span class="nc" id="L1402">                        rule = rule.matchLocalSecurityDomain(parseNameType(reader));</span>
<span class="nc" id="L1403">                        break;</span>
                    }
                    case &quot;match-abstract-type&quot;: {
<span class="nc bnc" id="L1406" title="All 2 branches missed.">                        if (isSet(foundBits, 7)) throw reader.unexpectedElement();</span>
<span class="nc" id="L1407">                        foundBits = setBit(foundBits, 7);</span>
<span class="nc" id="L1408">                        rule = parseMatchAbstractType(rule, reader);</span>
<span class="nc" id="L1409">                        break;</span>
                    }
                    default: {
<span class="pc" id="L1412">                        return rule;</span>
                    }
                }
            } else {
<span class="fc" id="L1416">                return rule;</span>
            }
<span class="fc" id="L1418">        }</span>
<span class="nc" id="L1419">        throw reader.unexpectedDocumentEnd();</span>
    }

    private static MatchRule parseMatchAbstractType(final MatchRule rule, final ConfigurationXMLStreamReader reader) throws ConfigXMLParseException {
<span class="nc" id="L1423">        final int attributeCount = reader.getAttributeCount();</span>
<span class="nc" id="L1424">        String name = null;</span>
<span class="nc" id="L1425">        String authority = null;</span>
<span class="nc bnc" id="L1426" title="All 2 branches missed.">        for (int i = 0; i &lt; attributeCount; i ++) {</span>
<span class="nc" id="L1427">            checkAttributeNamespace(reader, i);</span>
<span class="nc bnc" id="L1428" title="All 3 branches missed.">            switch (reader.getAttributeLocalName(i)) {</span>
<span class="nc" id="L1429">                case &quot;name&quot;: name = reader.getAttributeValueResolved(i); break;</span>
<span class="nc" id="L1430">                case &quot;authority&quot;: authority = reader.getAttributeValueResolved(i); break;</span>
<span class="nc" id="L1431">                default: throw reader.unexpectedAttribute(i);</span>
            }
        }
<span class="nc bnc" id="L1434" title="All 2 branches missed.">        if (! reader.hasNext()) throw reader.unexpectedDocumentEnd();</span>
<span class="nc bnc" id="L1435" title="All 2 branches missed.">        if (reader.nextTag() != END_ELEMENT) throw reader.unexpectedElement();</span>
<span class="nc bnc" id="L1436" title="All 4 branches missed.">        return name == null &amp;&amp; authority == null ? rule : rule.matchAbstractType(name, authority);</span>
    }

    private static boolean isSet(int var, int bit) {
<span class="pc bpc" id="L1440" title="1 of 2 branches missed.">        return (var &amp; 1 &lt;&lt; bit) != 0;</span>
    }

    private static int setBit(int var, int bit) {
<span class="fc" id="L1444">        return var | 1 &lt;&lt; bit;</span>
    }

    private static &lt;T, E extends Exception&gt; ExceptionUnaryOperator&lt;T, E&gt; andThenOp(ExceptionUnaryOperator&lt;T, E&gt; first, ExceptionUnaryOperator&lt;T, E&gt; second) {
<span class="fc" id="L1448">        return t -&gt; second.apply(first.apply(t));</span>
    }

    private static ExceptionSupplier&lt;CredentialSource, ConfigXMLParseException&gt; parseCredentialsType(final ConfigurationXMLStreamReader reader, final Version xmlVersion, final Map&lt;String, ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt;&gt; keyStoresMap, final Map&lt;String, ExceptionSupplier&lt;CredentialStore, ConfigXMLParseException&gt;&gt; credentialStoresMap, Supplier&lt;Provider[]&gt; providers) throws ConfigXMLParseException {
<span class="fc" id="L1452">        ExceptionUnaryOperator&lt;CredentialSource, ConfigXMLParseException&gt; function = parent -&gt; CredentialSource.NONE;</span>
<span class="fc" id="L1453">        requireNoAttributes(reader);</span>
<span class="pc bpc" id="L1454" title="1 of 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="fc" id="L1455">            final int tag = reader.nextTag();</span>
<span class="fc bfc" id="L1456" title="All 2 branches covered.">            if (tag == START_ELEMENT) {</span>
<span class="fc" id="L1457">                checkElementNamespace(reader, xmlVersion);</span>
<span class="pc bpc" id="L1458" title="8 of 12 branches missed.">                switch (reader.getLocalName()) {</span>
                    case &quot;key-store-reference&quot;: {
<span class="nc" id="L1460">                        final ExceptionSupplier&lt;KeyStore.Entry, ConfigXMLParseException&gt; supplier = parseKeyStoreRefType(reader, xmlVersion, keyStoresMap, credentialStoresMap, providers);</span>
<span class="nc" id="L1461">                        function = andThenOp(function, credentialSource -&gt; credentialSource.with(new KeyStoreCredentialSource(new FixedSecurityFactory&lt;KeyStore.Entry&gt;(supplier.get()))));</span>
<span class="nc" id="L1462">                        break;</span>
                    }
                    case &quot;credential-store-reference&quot;: {
<span class="nc" id="L1465">                        final ExceptionSupplier&lt;CredentialSource, ConfigXMLParseException&gt; supplier = parseCredentialStoreRefType(reader, credentialStoresMap);</span>
<span class="nc" id="L1466">                        function = andThenOp(function, credentialSource -&gt; credentialSource.with(supplier.get()));</span>
<span class="nc" id="L1467">                        break;</span>
                    }
                    case &quot;clear-password&quot;: {
<span class="fc" id="L1470">                        ExceptionSupplier&lt;Password, ConfigXMLParseException&gt; password = parseClearPassword(reader, providers);</span>
<span class="fc" id="L1471">                        function = andThenOp(function, credentialSource -&gt; credentialSource.with(IdentityCredentials.NONE.withCredential(new PasswordCredential(password.get()))));</span>
<span class="fc" id="L1472">                        break;</span>
                    }
                    case &quot;masked-password&quot;: {
<span class="pc bpc" id="L1475" title="1 of 2 branches missed.">                        if ( ! xmlVersion.isAtLeast(Version.VERSION_1_4)) {</span>
<span class="nc" id="L1476">                            throw reader.unexpectedElement();</span>
                        }
<span class="fc" id="L1478">                        final XMLLocation location = reader.getLocation();</span>
<span class="fc" id="L1479">                        ExceptionSupplier&lt;Password, ConfigXMLParseException&gt; password = parseMaskedPassword(reader, providers);</span>
<span class="fc" id="L1480">                        Password maskedPassword = password.get();</span>
                        Password finalPassword;
                        try {
<span class="fc" id="L1483">                            final PasswordFactory passwordFactory = PasswordFactory.getInstance(maskedPassword.getAlgorithm(), providers);</span>
<span class="fc" id="L1484">                            final ClearPasswordSpec spec = passwordFactory.getKeySpec(maskedPassword, ClearPasswordSpec.class);</span>
<span class="fc" id="L1485">                            final char[] clearPassword = spec.getEncodedPassword();</span>
<span class="fc" id="L1486">                            PasswordFactory clearPasswordFactory = PasswordFactory.getInstance(ClearPassword.ALGORITHM_CLEAR, providers);</span>
<span class="fc" id="L1487">                            finalPassword = clearPasswordFactory.generatePassword(new ClearPasswordSpec(clearPassword)).castAs(ClearPassword.class);</span>
<span class="nc" id="L1488">                        } catch (InvalidKeySpecException | NoSuchAlgorithmException cause) {</span>
<span class="nc" id="L1489">                            throw xmlLog.xmlFailedToCreateCredential(location, cause);</span>
<span class="fc" id="L1490">                        }</span>
<span class="fc" id="L1491">                        function = andThenOp(function, credentialSource -&gt; credentialSource.with(IdentityCredentials.NONE.withCredential(new PasswordCredential(finalPassword))));</span>
<span class="fc" id="L1492">                        break;</span>
                    }
                    case &quot;key-pair&quot;: {
<span class="fc" id="L1495">                        KeyPairCredential keyPairCredential = parseKeyPair(reader, xmlVersion, credentialStoresMap, providers);</span>
<span class="fc" id="L1496">                        function = andThenOp(function, credentialSource -&gt; credentialSource.with(IdentityCredentials.NONE.withCredential(keyPairCredential)));</span>
<span class="fc" id="L1497">                        break;</span>
                    }
                    case &quot;certificate&quot;: {
<span class="nc" id="L1500">                        X509CertificateChainPrivateCredential credential = parseCertificateType(reader, xmlVersion);</span>
<span class="nc" id="L1501">                        function = andThenOp(function, credentialSource -&gt; credentialSource.with(IdentityCredentials.NONE.withCredential(credential)));</span>
<span class="nc" id="L1502">                        break;</span>
                    }
                    case &quot;public-key-pem&quot;: {
<span class="nc" id="L1505">                        PublicKey publicKey = parsePem(reader, PublicKey.class);</span>
<span class="nc" id="L1506">                        function = andThenOp(function, credentialSource -&gt; credentialSource.with(IdentityCredentials.NONE.withCredential(new PublicKeyCredential(publicKey))));</span>
<span class="nc" id="L1507">                        break;</span>
                    }
                    case &quot;bearer-token&quot;: {
<span class="nc" id="L1510">                        BearerTokenCredential bearerToken = parseBearerTokenType(reader);</span>
<span class="nc" id="L1511">                        function = andThenOp(function, credentialSource -&gt; credentialSource.with(IdentityCredentials.NONE.withCredential(bearerToken)));</span>
<span class="nc" id="L1512">                        break;</span>
                    }
                    case &quot;oauth2-bearer-token&quot;: {
<span class="nc" id="L1515">                        final ExceptionSupplier&lt;CredentialSource, ConfigXMLParseException&gt; oauthCredentialSourceSupplier = parseOAuth2BearerTokenType(reader, credentialStoresMap, xmlVersion);</span>
<span class="nc" id="L1516">                        function = andThenOp(function, credentialSource -&gt; credentialSource.with(oauthCredentialSourceSupplier.get()));</span>
<span class="nc" id="L1517">                        break;</span>
                    }
                    case &quot;local-kerberos&quot;: {
<span class="nc bnc" id="L1520" title="All 2 branches missed.">                        if ( ! xmlVersion.isAtLeast(Version.VERSION_1_1)) {</span>
<span class="nc" id="L1521">                            throw reader.unexpectedElement();</span>
                        }
<span class="nc" id="L1523">                        CredentialSource kerberosCredentialSource = parseLocalKerberos(reader);</span>
<span class="nc" id="L1524">                        function = andThenOp(function, credentialSource -&gt; credentialSource.with(kerberosCredentialSource));</span>
<span class="nc" id="L1525">                        xmlLog.xmlDeprecatedElement(reader.getLocalName(), reader.getLocation());</span>
<span class="nc" id="L1526">                        break;</span>
                    }
                    case &quot;ssh-credential&quot;: {
<span class="pc bpc" id="L1529" title="1 of 2 branches missed.">                        if ( ! xmlVersion.isAtLeast(Version.VERSION_1_6)) {</span>
<span class="nc" id="L1530">                            throw reader.unexpectedElement();</span>
                        }
<span class="fc" id="L1532">                        SSHCredential sshCredential = parseSSHKeyLocationCredential(reader, xmlVersion, credentialStoresMap, providers);</span>
<span class="fc" id="L1533">                        function = andThenOp(function, credentialSource -&gt; credentialSource.with(credentialSource.with(IdentityCredentials.NONE.withCredential(sshCredential))));</span>
<span class="fc" id="L1534">                        break;</span>
                    }
                    default: {
<span class="pc" id="L1537">                        throw reader.unexpectedElement();</span>
                    }
                }
<span class="pc bpc" id="L1540" title="1 of 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="pc bpc" id="L1541" title="2 of 6 branches missed.">                assert reader.getLocalName().equals(&quot;credentials&quot;) || reader.getLocalName().equals(&quot;protection-parameter-credentials&quot;);</span>
<span class="fc" id="L1542">                final ExceptionUnaryOperator&lt;CredentialSource, ConfigXMLParseException&gt; finalFunction = function;</span>
<span class="fc" id="L1543">                return () -&gt; finalFunction.apply(null);</span>
            } else {
<span class="nc" id="L1545">                throw reader.unexpectedContent();</span>
            }
<span class="fc" id="L1547">        }</span>
<span class="nc" id="L1548">        throw reader.unexpectedDocumentEnd();</span>
    }

    private static SSHCredential parseSSHKeyLocationCredential(final ConfigurationXMLStreamReader reader, final Version xmlVersion, final Map&lt;String, ExceptionSupplier&lt;CredentialStore, ConfigXMLParseException&gt;&gt; credentialStoresMap, Supplier&lt;Provider[]&gt; providers) throws ConfigXMLParseException {
<span class="fc" id="L1552">        final int attributeCount = reader.getAttributeCount();</span>
<span class="fc" id="L1553">        String sshDirectory = null;</span>
<span class="fc" id="L1554">        String privateKeyIdentity = null;</span>
<span class="fc" id="L1555">        Credential passphrase = null;</span>
<span class="fc" id="L1556">        String knownHostsFile = null;</span>
<span class="fc bfc" id="L1557" title="All 2 branches covered.">        for (int i = 0; i &lt; attributeCount; i ++) {</span>
<span class="fc" id="L1558">            checkAttributeNamespace(reader, i);</span>
<span class="pc bpc" id="L1559" title="1 of 4 branches missed.">            switch (reader.getAttributeLocalName(i)) {</span>
                case &quot;ssh-directory&quot;: {
<span class="fc" id="L1561">                    sshDirectory = reader.getAttributeValueResolved(i);</span>
<span class="fc" id="L1562">                    break;</span>
                }
                case &quot;private-key-file&quot;: {
<span class="fc" id="L1565">                    privateKeyIdentity = reader.getAttributeValueResolved(i);</span>
<span class="fc" id="L1566">                    break;</span>
                }
                case &quot;known-hosts-file&quot;: {
<span class="fc" id="L1569">                    knownHostsFile = reader.getAttributeValueResolved(i);</span>
<span class="fc" id="L1570">                    break;</span>
                }
<span class="nc" id="L1572">                default: throw reader.unexpectedAttribute(i);</span>
            }
        }
<span class="pc bpc" id="L1575" title="1 of 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="fc" id="L1576">            final int tag = reader.nextTag();</span>
<span class="fc bfc" id="L1577" title="All 2 branches covered.">            if (tag == START_ELEMENT) {</span>
<span class="fc" id="L1578">                checkElementNamespace(reader, xmlVersion);</span>
<span class="pc bpc" id="L1579" title="3 of 4 branches missed.">                switch (reader.getLocalName()) {</span>
                    case &quot;credential-store-reference&quot;: {
<span class="fc" id="L1581">                        final ExceptionSupplier&lt;CredentialSource, ConfigXMLParseException&gt; supplier = parseCredentialStoreRefType(reader, credentialStoresMap);</span>
                        try {
<span class="fc" id="L1583">                            passphrase = supplier.get().getCredential(PasswordCredential.class);</span>
<span class="nc" id="L1584">                        } catch (IOException cause) {</span>
<span class="nc" id="L1585">                            throw xmlLog.couldNotObtainCredential();</span>
<span class="fc" id="L1586">                        }</span>
                        break;
                    }
                    case &quot;clear-password&quot;: {
<span class="nc" id="L1590">                        ExceptionSupplier&lt;Password, ConfigXMLParseException&gt; password = parseClearPassword(reader, providers);</span>
<span class="nc" id="L1591">                        passphrase = new PasswordCredential(password.get());</span>
<span class="nc" id="L1592">                        break;</span>
                    }
                    case &quot;masked-password&quot;: {
<span class="nc" id="L1595">                        final XMLLocation location = reader.getLocation();</span>
<span class="nc" id="L1596">                        ExceptionSupplier&lt;Password, ConfigXMLParseException&gt; password = parseMaskedPassword(reader, providers);</span>
<span class="nc" id="L1597">                        Password maskedPassword = password.get();</span>
                        Password finalPassword;
                        try {
<span class="nc" id="L1600">                            final PasswordFactory passwordFactory = PasswordFactory.getInstance(maskedPassword.getAlgorithm(), providers);</span>
<span class="nc" id="L1601">                            final ClearPasswordSpec spec = passwordFactory.getKeySpec(maskedPassword, ClearPasswordSpec.class);</span>
<span class="nc" id="L1602">                            final char[] clearPassword = spec.getEncodedPassword();</span>
<span class="nc" id="L1603">                            PasswordFactory clearPasswordFactory = PasswordFactory.getInstance(ClearPassword.ALGORITHM_CLEAR, providers);</span>
<span class="nc" id="L1604">                            finalPassword = clearPasswordFactory.generatePassword(new ClearPasswordSpec(clearPassword)).castAs(ClearPassword.class);</span>
<span class="nc" id="L1605">                        } catch (InvalidKeySpecException | NoSuchAlgorithmException cause) {</span>
<span class="nc" id="L1606">                            throw xmlLog.xmlFailedToCreateCredential(location, cause);</span>
<span class="nc" id="L1607">                        }</span>
<span class="nc" id="L1608">                        passphrase = new PasswordCredential(finalPassword);</span>
<span class="nc" id="L1609">                        break;</span>
                    }
<span class="pc" id="L1611">                    default: throw reader.unexpectedElement();</span>
                }

<span class="pc bpc" id="L1614" title="1 of 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="fc" id="L1615">                SSHCredential.Builder builder = SSHCredential.builder();</span>
<span class="fc bfc" id="L1616" title="All 2 branches covered.">                if (sshDirectory != null) builder.setSSHDirectory(sshDirectory);</span>
<span class="fc bfc" id="L1617" title="All 2 branches covered.">                if (privateKeyIdentity != null) builder.setPrivateKeyIdentity(privateKeyIdentity);</span>
<span class="pc bpc" id="L1618" title="1 of 2 branches missed.">                if (passphrase != null) builder.setPassphrase(passphrase);</span>
<span class="fc bfc" id="L1619" title="All 2 branches covered.">                if (knownHostsFile != null) builder.setKnownHostsFile(knownHostsFile);</span>
<span class="fc" id="L1620">                return builder.build();</span>
            } else {
<span class="nc" id="L1622">                throw reader.unexpectedContent();</span>
            }
<span class="fc" id="L1624">        }</span>
<span class="nc" id="L1625">        throw reader.unexpectedDocumentEnd();</span>
    }

    private static KeyPairCredential parseKeyPair(final ConfigurationXMLStreamReader reader, final Version xmlVersion, final Map&lt;String, ExceptionSupplier&lt;CredentialStore, ConfigXMLParseException&gt;&gt; credentialStoresMap, Supplier&lt;Provider[]&gt; providers) throws ConfigXMLParseException {
<span class="fc" id="L1629">        PrivateKey privateKey = null;</span>
<span class="fc" id="L1630">        PublicKey publicKey = null;</span>
<span class="fc" id="L1631">        KeyPair keyPair = null;</span>
<span class="pc bpc" id="L1632" title="1 of 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="fc" id="L1633">            final int tag = reader.nextTag();</span>
<span class="fc bfc" id="L1634" title="All 2 branches covered.">            if (tag == START_ELEMENT) {</span>
<span class="fc" id="L1635">                checkElementNamespace(reader, xmlVersion);</span>
<span class="pc bpc" id="L1636" title="3 of 4 branches missed.">                switch (reader.getLocalName()) {</span>
                    case &quot;private-key-pem&quot;: {
<span class="nc bnc" id="L1638" title="All 4 branches missed.">                        if (privateKey != null || keyPair != null) throw reader.unexpectedElement();</span>
<span class="nc" id="L1639">                        privateKey = parsePem(reader, PrivateKey.class);</span>
<span class="nc" id="L1640">                        break;</span>
                    }
                    case &quot;public-key-pem&quot;: {
<span class="nc bnc" id="L1643" title="All 4 branches missed.">                        if (publicKey != null || keyPair != null) throw reader.unexpectedElement();</span>
<span class="nc" id="L1644">                        publicKey = parsePem(reader, PublicKey.class);</span>
<span class="nc" id="L1645">                        break;</span>
                    }
                    case &quot;openssh-private-key&quot;: {
<span class="pc bpc" id="L1648" title="1 of 2 branches missed.">                        if ( ! xmlVersion.isAtLeast(Version.VERSION_1_6)) {</span>
<span class="nc" id="L1649">                            throw reader.unexpectedElement();</span>
                        }
<span class="pc bpc" id="L1651" title="3 of 6 branches missed.">                        if (keyPair != null || privateKey != null || publicKey != null) throw reader.unexpectedElement();</span>
<span class="fc" id="L1652">                        keyPair = parseOpenSSHKeyType(reader, xmlVersion, credentialStoresMap, providers);</span>
<span class="fc" id="L1653">                        break;</span>
                    }
                    default: {
<span class="pc" id="L1656">                        throw reader.unexpectedElement();</span>
                    }
                }
<span class="pc bpc" id="L1659" title="1 of 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="pc bpc" id="L1660" title="1 of 2 branches missed.">                if (keyPair == null) {</span>
<span class="nc bnc" id="L1661" title="All 2 branches missed.">                    if (privateKey == null) throw reader.missingRequiredElement(xmlVersion.namespace, &quot;private-key-pem&quot;);</span>
<span class="nc bnc" id="L1662" title="All 2 branches missed.">                    if (publicKey == null) throw reader.missingRequiredElement(xmlVersion.namespace, &quot;public-key-pem&quot;);</span>
<span class="nc" id="L1663">                    keyPair = new KeyPair(publicKey, privateKey);</span>
                }
<span class="fc" id="L1665">                return new KeyPairCredential(keyPair);</span>
            } else {
<span class="nc" id="L1667">                throw reader.unexpectedContent();</span>
            }
<span class="fc" id="L1669">        }</span>
<span class="nc" id="L1670">        throw reader.unexpectedDocumentEnd();</span>
    }

    private static KeyPair parseOpenSSHKeyType(final ConfigurationXMLStreamReader reader, final Version xmlVersion, final Map&lt;String, ExceptionSupplier&lt;CredentialStore, ConfigXMLParseException&gt;&gt; credentialStoresMap, Supplier&lt;Provider[]&gt; providers) throws ConfigXMLParseException {
<span class="fc" id="L1674">        final int attributeCount = reader.getAttributeCount();</span>
<span class="fc" id="L1675">        ExceptionUnaryOperator&lt;CredentialSource, ConfigXMLParseException&gt; function = parent -&gt; CredentialSource.NONE;</span>
<span class="fc" id="L1676">        String keyContent = null;</span>
<span class="fc bfc" id="L1677" title="All 2 branches covered.">        for (int i = 0; i &lt; attributeCount; i ++) {</span>
<span class="fc" id="L1678">            checkAttributeNamespace(reader, i);</span>
<span class="pc bpc" id="L1679" title="1 of 2 branches missed.">            switch (reader.getAttributeLocalName(i)) {</span>
                case &quot;pem&quot;: {
<span class="pc bpc" id="L1681" title="1 of 2 branches missed.">                    if (keyContent != null) throw reader.unexpectedAttribute(i);</span>
<span class="fc" id="L1682">                    keyContent = reader.getAttributeValueResolved(i);</span>
<span class="fc" id="L1683">                    break;</span>
                }
<span class="nc" id="L1685">                default: throw reader.unexpectedAttribute(i);</span>
            }
        }
<span class="pc bpc" id="L1688" title="1 of 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="fc" id="L1689">            final int tag = reader.nextTag();</span>
<span class="fc bfc" id="L1690" title="All 2 branches covered.">            if (tag == START_ELEMENT) {</span>
<span class="fc" id="L1691">                checkElementNamespace(reader, xmlVersion);</span>
<span class="pc bpc" id="L1692" title="1 of 4 branches missed.">                switch (reader.getLocalName()) {</span>
                    case &quot;credential-store-reference&quot;: {
<span class="fc" id="L1694">                        final ExceptionSupplier&lt;CredentialSource, ConfigXMLParseException&gt; supplier = parseCredentialStoreRefType(reader, credentialStoresMap);</span>
<span class="fc" id="L1695">                        function = andThenOp(function, credentialSource -&gt; credentialSource.with(supplier.get()));</span>
<span class="fc" id="L1696">                        break;</span>
                    }
                    case &quot;clear-password&quot;: {
<span class="fc" id="L1699">                        ExceptionSupplier&lt;Password, ConfigXMLParseException&gt; password = parseClearPassword(reader, providers);</span>
<span class="fc" id="L1700">                        function = andThenOp(function, credentialSource -&gt; credentialSource.with(IdentityCredentials.NONE.withCredential(new PasswordCredential(password.get()))));</span>
<span class="fc" id="L1701">                        break;</span>
                    }
                    case &quot;masked-password&quot;: {
<span class="pc bpc" id="L1704" title="1 of 2 branches missed.">                        if ( ! xmlVersion.isAtLeast(Version.VERSION_1_4)) {</span>
<span class="nc" id="L1705">                            throw reader.unexpectedElement();</span>
                        }
<span class="fc" id="L1707">                        final XMLLocation location = reader.getLocation();</span>
<span class="fc" id="L1708">                        ExceptionSupplier&lt;Password, ConfigXMLParseException&gt; password = parseMaskedPassword(reader, providers);</span>
<span class="fc" id="L1709">                        Password maskedPassword = password.get();</span>
                        Password finalPassword;
                        try {
<span class="fc" id="L1712">                            final PasswordFactory passwordFactory = PasswordFactory.getInstance(maskedPassword.getAlgorithm(), providers);</span>
<span class="fc" id="L1713">                            final ClearPasswordSpec spec = passwordFactory.getKeySpec(maskedPassword, ClearPasswordSpec.class);</span>
<span class="fc" id="L1714">                            final char[] clearPassword = spec.getEncodedPassword();</span>
<span class="fc" id="L1715">                            PasswordFactory clearPasswordFactory = PasswordFactory.getInstance(ClearPassword.ALGORITHM_CLEAR, providers);</span>
<span class="fc" id="L1716">                            finalPassword = clearPasswordFactory.generatePassword(new ClearPasswordSpec(clearPassword)).castAs(ClearPassword.class);</span>
<span class="nc" id="L1717">                        } catch (InvalidKeySpecException | NoSuchAlgorithmException cause) {</span>
<span class="nc" id="L1718">                            throw xmlLog.xmlFailedToCreateCredential(location, cause);</span>
<span class="fc" id="L1719">                        }</span>
<span class="fc" id="L1720">                        function = andThenOp(function, credentialSource -&gt; credentialSource.with(IdentityCredentials.NONE.withCredential(new PasswordCredential(finalPassword))));</span>
<span class="fc" id="L1721">                        break;</span>
                    }
<span class="pc" id="L1723">                    default: throw reader.unexpectedElement();</span>
                }

<span class="pc bpc" id="L1726" title="1 of 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="pc bpc" id="L1727" title="1 of 2 branches missed.">                if (keyContent == null) throw reader.missingRequiredAttribute(reader.getNamespaceURI(), &quot;openssh-private-key&quot;);</span>
<span class="fc" id="L1728">                final ExceptionUnaryOperator&lt;CredentialSource, ConfigXMLParseException&gt; finalFunction = function;</span>
<span class="fc" id="L1729">                ElytronFilePasswordProvider passwordProvider = new ElytronFilePasswordProvider(()-&gt;finalFunction.apply(null));</span>
<span class="fc" id="L1730">                Iterator&lt;PemEntry&lt;?&gt;&gt; pemContent = Pem.parsePemOpenSSHContent(CodePointIterator.ofString(keyContent), passwordProvider);</span>
<span class="fc" id="L1731">                final PemEntry&lt;?&gt; pemEntry = pemContent.next();</span>
<span class="fc" id="L1732">                final KeyPair keyPair = pemEntry.tryCast(KeyPair.class);</span>
<span class="pc bpc" id="L1733" title="1 of 2 branches missed.">                if (keyPair == null) throw xmlLog.xmlInvalidOpenSSHKey(reader);</span>
<span class="fc" id="L1734">                return keyPair;</span>

            } else {
<span class="nc" id="L1737">                throw reader.unexpectedContent();</span>
            }
<span class="fc" id="L1739">        }</span>
<span class="nc" id="L1740">        throw reader.unexpectedDocumentEnd();</span>
    }

    private static X509CertificateChainPrivateCredential parseCertificateType(final ConfigurationXMLStreamReader reader, final Version xmlVersion) throws ConfigXMLParseException {
<span class="nc" id="L1744">        requireNoAttributes(reader);</span>
<span class="nc" id="L1745">        PrivateKey privateKey = null;</span>
<span class="nc" id="L1746">        X509Certificate[] certificates = null;</span>
<span class="nc bnc" id="L1747" title="All 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="nc" id="L1748">            final int tag = reader.nextTag();</span>
<span class="nc bnc" id="L1749" title="All 2 branches missed.">            if (tag == START_ELEMENT) {</span>
<span class="nc" id="L1750">                checkElementNamespace(reader, xmlVersion);</span>
<span class="nc bnc" id="L1751" title="All 3 branches missed.">                switch (reader.getLocalName()) {</span>
                    case &quot;private-key-pem&quot;: {
<span class="nc bnc" id="L1753" title="All 2 branches missed.">                        if (privateKey != null) throw reader.unexpectedElement();</span>
<span class="nc" id="L1754">                        privateKey = parsePem(reader, PrivateKey.class);</span>
<span class="nc" id="L1755">                        break;</span>
                    }
                    case &quot;pem&quot;: {
<span class="nc bnc" id="L1758" title="All 2 branches missed.">                        if (certificates != null) throw reader.unexpectedElement();</span>
<span class="nc" id="L1759">                        certificates = parseMultiPem(reader, X509Certificate.class, X509Certificate[]::new);</span>
<span class="nc" id="L1760">                        break;</span>
                    }
                    default: {
<span class="nc" id="L1763">                        throw reader.unexpectedElement();</span>
                    }
                }
<span class="nc bnc" id="L1766" title="All 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="nc bnc" id="L1767" title="All 2 branches missed.">                if (privateKey == null) throw reader.missingRequiredElement(xmlVersion.namespace, &quot;private-key-pem&quot;);</span>
<span class="nc bnc" id="L1768" title="All 2 branches missed.">                if (certificates == null) throw reader.missingRequiredElement(xmlVersion.namespace, &quot;pem&quot;);</span>
<span class="nc" id="L1769">                return new X509CertificateChainPrivateCredential(privateKey, certificates);</span>
            } else {
<span class="nc" id="L1771">                throw reader.unexpectedContent();</span>
            }
<span class="nc" id="L1773">        }</span>
<span class="nc" id="L1774">        throw reader.unexpectedDocumentEnd();</span>
    }

    private static &lt;P&gt; P[] parseMultiPem(final ConfigurationXMLStreamReader reader, final Class&lt;P&gt; pemType, final IntFunction&lt;P[]&gt; ctor) throws ConfigXMLParseException {
<span class="nc" id="L1778">        requireNoAttributes(reader);</span>
<span class="nc" id="L1779">        final Iterator&lt;PemEntry&lt;?&gt;&gt; pemContent = Pem.parsePemContent(CodePointIterator.ofString(reader.getElementText()));</span>
<span class="nc bnc" id="L1780" title="All 2 branches missed.">        if (! reader.hasNext()) throw reader.unexpectedDocumentEnd();</span>
<span class="nc" id="L1781">        final ArrayList&lt;P&gt; arrayList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1782" title="All 2 branches missed.">        while (pemContent.hasNext()) {</span>
<span class="nc" id="L1783">            final PemEntry&lt;?&gt; pemEntry = pemContent.next();</span>
<span class="nc" id="L1784">            final P pem = pemEntry.tryCast(pemType);</span>
<span class="nc bnc" id="L1785" title="All 2 branches missed.">            if (pem == null) throw xmlLog.xmlWrongPemType(reader, pemType, pemEntry.getEntry().getClass());</span>
<span class="nc" id="L1786">            arrayList.add(pem);</span>
<span class="nc" id="L1787">        }</span>
<span class="nc bnc" id="L1788" title="All 2 branches missed.">        if (arrayList.isEmpty()) throw xmlLog.xmlNoPemContent(reader);</span>
<span class="nc" id="L1789">        return arrayList.toArray(ctor.apply(arrayList.size()));</span>
    }

    private static &lt;P&gt; P parsePem(final ConfigurationXMLStreamReader reader, final Class&lt;P&gt; pemType) throws ConfigXMLParseException {
<span class="nc" id="L1793">        requireNoAttributes(reader);</span>
<span class="nc" id="L1794">        final Iterator&lt;PemEntry&lt;?&gt;&gt; pemContent = Pem.parsePemContent(CodePointIterator.ofString(reader.getElementText()));</span>
<span class="nc bnc" id="L1795" title="All 2 branches missed.">        if (! reader.hasNext()) throw reader.unexpectedDocumentEnd();</span>
<span class="nc bnc" id="L1796" title="All 2 branches missed.">        if (! pemContent.hasNext()) throw xmlLog.xmlNoPemContent(reader);</span>
<span class="nc" id="L1797">        final PemEntry&lt;?&gt; pemEntry = pemContent.next();</span>
<span class="nc" id="L1798">        final P pem = pemEntry.tryCast(pemType);</span>
<span class="nc bnc" id="L1799" title="All 2 branches missed.">        if (pem == null) throw xmlLog.xmlWrongPemType(reader, pemType, pemEntry.getEntry().getClass());</span>
<span class="nc" id="L1800">        return pem;</span>
    }

    /**
     * Parse an XML element of type {@code key-stores-type} from an XML reader.
     *
     * @param reader the XML stream reader
     * @param xmlVersion the version of parsed XML
     * @param keyStoresMap the map of key stores to use
     * @throws ConfigXMLParseException if the resource failed to be parsed
     */
    static void parseKeyStoresType(ConfigurationXMLStreamReader reader, final Version xmlVersion, final Map&lt;String, ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt;&gt; keyStoresMap, final Map&lt;String, ExceptionSupplier&lt;CredentialStore, ConfigXMLParseException&gt;&gt; credentialStoresMap, final Supplier&lt;Provider[]&gt; providers) throws ConfigXMLParseException {
<span class="fc" id="L1812">        requireNoAttributes(reader);</span>
<span class="pc bpc" id="L1813" title="1 of 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="fc" id="L1814">            final int tag = reader.nextTag();</span>
<span class="fc bfc" id="L1815" title="All 2 branches covered.">            if (tag == START_ELEMENT) {</span>
<span class="fc" id="L1816">                checkElementNamespace(reader, xmlVersion);</span>
<span class="pc bpc" id="L1817" title="1 of 2 branches missed.">                switch (reader.getLocalName()) {</span>
                    case &quot;key-store&quot;: {
<span class="fc" id="L1819">                        parseKeyStoreType(reader, xmlVersion, keyStoresMap, credentialStoresMap, providers);</span>
<span class="fc" id="L1820">                        break;</span>
                    }
<span class="pc" id="L1822">                    default: throw reader.unexpectedElement();</span>
                }
<span class="pc bpc" id="L1824" title="1 of 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="fc" id="L1825">                return;</span>
            } else {
<span class="nc" id="L1827">                throw reader.unexpectedContent();</span>
            }
<span class="fc" id="L1829">        }</span>
<span class="nc" id="L1830">        throw reader.unexpectedDocumentEnd();</span>
    }

    /**
     * Parse an XML element of type {@code key-store-type} from an XML reader.
     *
     * @param reader the XML stream reader
     * @param xmlVersion the version of parsed XML
     * @param keyStoresMap the map of key stores to use
     * @throws ConfigXMLParseException if the resource failed to be parsed
     */
    static void parseKeyStoreType(ConfigurationXMLStreamReader reader, final Version xmlVersion, final Map&lt;String, ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt;&gt; keyStoresMap,
            final Map&lt;String, ExceptionSupplier&lt;CredentialStore, ConfigXMLParseException&gt;&gt; credentialStoresMap, final Supplier&lt;Provider[]&gt; providers) throws ConfigXMLParseException {
<span class="fc" id="L1843">        final int attributeCount = reader.getAttributeCount();</span>
<span class="fc" id="L1844">        String name = null;</span>
<span class="fc" id="L1845">        String type = null;</span>
<span class="fc" id="L1846">        String provider = null;</span>
<span class="fc" id="L1847">        Boolean wrap = null;</span>
<span class="fc" id="L1848">        DeferredSupplier&lt;Provider[]&gt; providersSupplier = new DeferredSupplier&lt;&gt;(providers);</span>
<span class="fc bfc" id="L1849" title="All 2 branches covered.">        for (int i = 0; i &lt; attributeCount; i ++) {</span>
<span class="fc" id="L1850">            checkAttributeNamespace(reader, i);</span>
<span class="pc bpc" id="L1851" title="3 of 5 branches missed.">            switch (reader.getAttributeLocalName(i)) {</span>
                case &quot;type&quot;: {
<span class="pc bpc" id="L1853" title="1 of 2 branches missed.">                    if (type != null) throw reader.unexpectedAttribute(i);</span>
<span class="fc" id="L1854">                    type = reader.getAttributeValueResolved(i);</span>
<span class="fc" id="L1855">                    break;</span>
                }
                case &quot;provider&quot;: {
<span class="nc bnc" id="L1858" title="All 2 branches missed.">                    if (provider != null) throw reader.unexpectedAttribute(i);</span>
<span class="nc" id="L1859">                    provider = reader.getAttributeValueResolved(i);</span>
<span class="nc" id="L1860">                    break;</span>
                }
                case &quot;name&quot;: {
<span class="pc bpc" id="L1863" title="1 of 2 branches missed.">                    if (name != null) throw reader.unexpectedAttribute(i);</span>
<span class="fc" id="L1864">                    name = reader.getAttributeValueResolved(i);</span>
<span class="fc" id="L1865">                    break;</span>
                }
                case &quot;wrap-passwords&quot;: {
<span class="nc bnc" id="L1868" title="All 2 branches missed.">                    if (wrap != null) throw reader.unexpectedAttribute(i);</span>
<span class="nc" id="L1869">                    wrap = Boolean.valueOf(Boolean.parseBoolean(reader.getAttributeValueResolved(i)));</span>
<span class="nc" id="L1870">                    break;</span>
                }
                default:
<span class="nc" id="L1873">                    throw reader.unexpectedAttribute(i);</span>
            }
        }
<span class="pc bpc" id="L1876" title="1 of 4 branches missed.">        if (type == null &amp;&amp; !xmlVersion.isAtLeast(Version.VERSION_1_3)) {</span>
<span class="nc" id="L1877">            throw missingAttribute(reader, &quot;type&quot;);</span>
        }
<span class="pc bpc" id="L1879" title="1 of 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L1880">            throw missingAttribute(reader, &quot;name&quot;);</span>
        }
<span class="fc" id="L1882">        final XMLLocation location = reader.getLocation();</span>
<span class="fc" id="L1883">        ExceptionSupplier&lt;char[], ConfigXMLParseException&gt; passwordFactory = null;</span>
<span class="fc" id="L1884">        boolean gotSource = false;</span>
<span class="fc" id="L1885">        boolean gotCredential = false;</span>
<span class="fc" id="L1886">        boolean gotProviders = false;</span>

<span class="fc" id="L1888">        String fileSource = null;</span>
<span class="fc" id="L1889">        ExceptionSupplier&lt;InputStream, IOException&gt; resourceSource = null;</span>
<span class="fc" id="L1890">        URI uriSource = null;</span>

<span class="pc bpc" id="L1892" title="1 of 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="fc" id="L1893">            final int tag = reader.nextTag();</span>
<span class="fc bfc" id="L1894" title="All 2 branches covered.">            if (tag == START_ELEMENT) {</span>
<span class="fc" id="L1895">                checkElementNamespace(reader, xmlVersion);</span>
<span class="pc bpc" id="L1896" title="6 of 9 branches missed.">                switch (reader.getLocalName()) {</span>
                    case &quot;key-store-credential&quot;: {
                        // group 2
<span class="nc bnc" id="L1899" title="All 2 branches missed.">                        if (gotCredential) {</span>
<span class="nc" id="L1900">                            throw reader.unexpectedElement();</span>
                        }
<span class="nc" id="L1902">                        gotCredential = true;</span>
<span class="nc" id="L1903">                        final XMLLocation nestedLocation = reader.getLocation();</span>
<span class="nc" id="L1904">                        final ExceptionSupplier&lt;KeyStore.Entry, ConfigXMLParseException&gt; entryFactory = parseKeyStoreRefType(reader, xmlVersion, keyStoresMap, credentialStoresMap, providersSupplier);</span>
<span class="nc" id="L1905">                        passwordFactory = () -&gt; {</span>
<span class="nc" id="L1906">                            final KeyStore.Entry entry = entryFactory.get();</span>
<span class="nc bnc" id="L1907" title="All 2 branches missed.">                            if (entry instanceof PasswordEntry) try {</span>
<span class="nc" id="L1908">                                final Password password = ((PasswordEntry) entry).getPassword();</span>
<span class="nc" id="L1909">                                final PasswordFactory passwordFactory1 = PasswordFactory.getInstance(password.getAlgorithm(), providersSupplier);</span>
<span class="nc" id="L1910">                                final ClearPasswordSpec passwordSpec = passwordFactory1.getKeySpec(password, ClearPasswordSpec.class);</span>
<span class="nc" id="L1911">                                return passwordSpec.getEncodedPassword();</span>
<span class="nc" id="L1912">                            } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L1913">                                throw xmlLog.xmlFailedToCreateCredential(nestedLocation, e);</span>
                            }
<span class="nc" id="L1915">                            return null;</span>
                        };
<span class="nc" id="L1917">                        break;</span>
                    }
                    case &quot;credential-store-reference&quot;: {
<span class="nc bnc" id="L1920" title="All 4 branches missed.">                        if (gotCredential || !xmlVersion.isAtLeast(Version.VERSION_1_0_1)) {</span>
<span class="nc" id="L1921">                            throw reader.unexpectedElement();</span>
                        }
<span class="nc" id="L1923">                        gotCredential = true;</span>
<span class="nc" id="L1924">                        final XMLLocation nestedLocation = reader.getLocation();</span>
<span class="nc" id="L1925">                        ExceptionSupplier&lt;CredentialSource, ConfigXMLParseException&gt; credentialSourceSupplier = parseCredentialStoreRefType(reader, credentialStoresMap);</span>
<span class="nc" id="L1926">                        passwordFactory = () -&gt; {</span>
                            try {
<span class="nc" id="L1928">                                return credentialSourceSupplier.get().applyToCredential(PasswordCredential.class,</span>
<span class="nc" id="L1929">                                        c -&gt; c.getPassword().castAndApply(ClearPassword.class, ClearPassword::getPassword));</span>
<span class="nc" id="L1930">                            } catch (IOException e) {</span>
<span class="nc" id="L1931">                                throw xmlLog.xmlFailedToCreateCredential(nestedLocation, e);</span>
                            }
                        };
<span class="nc" id="L1934">                        break;</span>
                    }
                    case &quot;key-store-clear-password&quot;: {
                        // group 2
<span class="pc bpc" id="L1938" title="1 of 2 branches missed.">                        if (gotCredential) {</span>
<span class="nc" id="L1939">                            throw reader.unexpectedElement();</span>
                        }
<span class="fc" id="L1941">                        gotCredential = true;</span>
<span class="fc" id="L1942">                        final ExceptionSupplier&lt;Password, ConfigXMLParseException&gt; clearPassword = parseClearPassword(reader, providersSupplier);</span>
<span class="fc" id="L1943">                        passwordFactory = () -&gt; ((ClearPassword)clearPassword.get()).getPassword();</span>
<span class="fc" id="L1944">                        break;</span>
                    }
                    case &quot;key-store-masked-password&quot;: {
                        // group 2
<span class="pc bpc" id="L1948" title="2 of 4 branches missed.">                        if (gotCredential || !xmlVersion.isAtLeast(Version.VERSION_1_4)) {</span>
<span class="nc" id="L1949">                            throw reader.unexpectedElement();</span>
                        }
<span class="fc" id="L1951">                        gotCredential = true;</span>
<span class="fc" id="L1952">                        final XMLLocation nestedLocation = reader.getLocation();</span>
<span class="fc" id="L1953">                        final ExceptionSupplier&lt;Password, ConfigXMLParseException&gt; maskedPassword = parseMaskedPassword(reader, providersSupplier);</span>
<span class="fc" id="L1954">                        passwordFactory = () -&gt; {</span>
                            try {
<span class="fc" id="L1956">                                Password password = maskedPassword.get();</span>
<span class="fc" id="L1957">                                PasswordFactory factory = PasswordFactory.getInstance(password.getAlgorithm(), providersSupplier);</span>
<span class="fc" id="L1958">                                ClearPasswordSpec spec = factory.getKeySpec(password, ClearPasswordSpec.class);</span>
<span class="fc" id="L1959">                                return spec.getEncodedPassword();</span>
<span class="nc" id="L1960">                            } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L1961">                                throw xmlLog.xmlFailedToCreateCredential(nestedLocation, e);</span>
                            }
                        };
<span class="fc" id="L1964">                        break;</span>
                    }
                    case &quot;file&quot;: {
                        // group 1
<span class="pc bpc" id="L1968" title="2 of 4 branches missed.">                        if (gotSource || gotCredential) {</span>
<span class="nc" id="L1969">                            throw reader.unexpectedElement();</span>
                        }
<span class="fc" id="L1971">                        gotSource = true;</span>
<span class="fc" id="L1972">                        fileSource = parseNameType(reader);</span>
<span class="fc" id="L1973">                        break;</span>
                    }
                    case &quot;resource&quot;: {
                        // group 1
<span class="nc bnc" id="L1977" title="All 4 branches missed.">                        if (gotSource || gotCredential) {</span>
<span class="nc" id="L1978">                            throw reader.unexpectedElement();</span>
                        }
<span class="nc" id="L1980">                        gotSource = true;</span>
<span class="nc" id="L1981">                        resourceSource = parseResourceType(reader, xmlVersion);</span>
<span class="nc" id="L1982">                        break;</span>
                    }
                    case &quot;uri&quot;: {
                        // group 1
<span class="nc bnc" id="L1986" title="All 4 branches missed.">                        if (gotSource || gotCredential) {</span>
<span class="nc" id="L1987">                            throw reader.unexpectedElement();</span>
                        }
<span class="nc" id="L1989">                        gotSource = true;</span>
<span class="nc" id="L1990">                        uriSource = parseUriType(reader);</span>
<span class="nc" id="L1991">                        break;</span>
                    }
                    case &quot;providers&quot;: {
<span class="nc bnc" id="L1994" title="All 4 branches missed.">                        if (gotProviders || !xmlVersion.isAtLeast(Version.VERSION_1_1)) {</span>
<span class="nc" id="L1995">                            throw reader.unexpectedElement();</span>
                        }
<span class="nc" id="L1997">                        gotProviders = true;</span>
<span class="nc" id="L1998">                        Supplier&lt;Provider[]&gt; supplier = parseProvidersType(reader, xmlVersion);</span>
<span class="nc bnc" id="L1999" title="All 2 branches missed.">                        if (supplier != null) {</span>
<span class="nc" id="L2000">                            providersSupplier.setSupplier(supplier);</span>
                        }
                        break;
                    }
<span class="pc" id="L2004">                    default: throw reader.unexpectedElement();</span>
                }
<span class="pc bpc" id="L2006" title="1 of 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="fc" id="L2007">                ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt; keyStoreFactory = null;</span>
<span class="pc bpc" id="L2008" title="1 of 4 branches missed.">                if (type == null || type.equalsIgnoreCase(&quot;automatic&quot;)) {</span>
<span class="fc" id="L2009">                    keyStoreFactory = new UnknownTypeFileKeyStoreFactory(providers, provider, passwordFactory, fileSource, resourceSource, uriSource, location);</span>
<span class="pc bpc" id="L2010" title="1 of 2 branches missed.">                    if (wrap == Boolean.TRUE) {</span>
<span class="nc" id="L2011">                        keyStoreFactory = new PasswordKeyStoreFactory(keyStoreFactory);</span>
                    }
                } else {
<span class="fc" id="L2014">                    keyStoreFactory = new KeyStoreCreateFactory(providersSupplier, provider, type, location);</span>
<span class="pc bpc" id="L2015" title="1 of 2 branches missed.">                    if (wrap == Boolean.TRUE) {</span>
<span class="nc" id="L2016">                        keyStoreFactory = new PasswordKeyStoreFactory(keyStoreFactory);</span>
                    }
<span class="pc bpc" id="L2018" title="1 of 2 branches missed.">                    if (fileSource != null) {</span>
<span class="fc" id="L2019">                        keyStoreFactory = new FileLoadingKeyStoreFactory(keyStoreFactory, passwordFactory, fileSource, location);</span>
<span class="nc bnc" id="L2020" title="All 2 branches missed.">                    } else if (resourceSource != null) {</span>
<span class="nc" id="L2021">                        keyStoreFactory = new ResourceLoadingKeyStoreFactory(keyStoreFactory, passwordFactory, resourceSource, location);</span>
<span class="nc bnc" id="L2022" title="All 2 branches missed.">                    } else if (uriSource != null) {</span>
<span class="nc" id="L2023">                        keyStoreFactory = new URILoadingKeyStoreFactory(keyStoreFactory, passwordFactory, uriSource, location);</span>
                    } else {
<span class="nc" id="L2025">                        keyStoreFactory = new NullLoadingKeyStoreFactory(keyStoreFactory, passwordFactory, location);</span>
                    }
                }
<span class="fc" id="L2028">                keyStoresMap.put(name, keyStoreFactory);</span>
<span class="fc" id="L2029">                return;</span>
            } else {
<span class="nc" id="L2031">                throw reader.unexpectedContent();</span>
            }
<span class="fc" id="L2033">        }</span>
<span class="nc" id="L2034">        throw reader.unexpectedDocumentEnd();</span>
    }

    /**
     * Parse an XML element of type {@code key-store-ref-type} from an XML reader.
     *
     * @param reader the XML stream reader
     * @param xmlVersion the version of parsed XML
     * @param keyStoresMap the map of key stores to use
     * @param credentialStoresMap the map of credential stores to use
     * @param providers supplier of providers for loading services
     * @return the key store entry factory
     * @throws ConfigXMLParseException if the resource failed to be parsed
     */
    static ExceptionSupplier&lt;KeyStore.Entry, ConfigXMLParseException&gt; parseKeyStoreRefType(ConfigurationXMLStreamReader reader, final Version xmlVersion,
            final Map&lt;String, ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt;&gt; keyStoresMap, final Map&lt;String, ExceptionSupplier&lt;CredentialStore, ConfigXMLParseException&gt;&gt; credentialStoresMap,
            final Supplier&lt;Provider[]&gt; providers) throws ConfigXMLParseException {
<span class="nc" id="L2051">        final int attributeCount = reader.getAttributeCount();</span>
<span class="nc" id="L2052">        final XMLLocation location = reader.getLocation();</span>
<span class="nc" id="L2053">        String keyStoreName = null;</span>
<span class="nc" id="L2054">        String alias = null;</span>
<span class="nc bnc" id="L2055" title="All 2 branches missed.">        for (int i = 0; i &lt; attributeCount; i ++) {</span>
<span class="nc" id="L2056">            checkAttributeNamespace(reader, i);</span>
<span class="nc bnc" id="L2057" title="All 3 branches missed.">            switch (reader.getAttributeLocalName(i)) {</span>
                case &quot;key-store-name&quot;: {
<span class="nc bnc" id="L2059" title="All 2 branches missed.">                    if (keyStoreName != null) throw reader.unexpectedAttribute(i);</span>
<span class="nc" id="L2060">                    keyStoreName = reader.getAttributeValueResolved(i);</span>
<span class="nc" id="L2061">                    break;</span>
                }
                case &quot;alias&quot;: {
<span class="nc bnc" id="L2064" title="All 2 branches missed.">                    if (alias != null) throw reader.unexpectedAttribute(i);</span>
<span class="nc" id="L2065">                    alias = reader.getAttributeValueResolved(i);</span>
<span class="nc" id="L2066">                    break;</span>
                }
<span class="nc" id="L2068">                default: throw reader.unexpectedElement();</span>
            }
        }
<span class="nc bnc" id="L2071" title="All 2 branches missed.">        if (keyStoreName == null) {</span>
<span class="nc" id="L2072">            throw missingAttribute(reader, &quot;key-store-name&quot;);</span>
        }
<span class="nc" id="L2074">        ExceptionSupplier&lt;KeyStore.Entry, ConfigXMLParseException&gt; keyStoreCredential = null;</span>
<span class="nc bnc" id="L2075" title="All 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="nc" id="L2076">            final int tag = reader.nextTag();</span>
<span class="nc bnc" id="L2077" title="All 2 branches missed.">            if (tag == START_ELEMENT) {</span>
<span class="nc" id="L2078">                checkElementNamespace(reader, xmlVersion);</span>
<span class="nc bnc" id="L2079" title="All 5 branches missed.">                switch (reader.getLocalName()) {</span>
                    case &quot;key-store-credential&quot;: {
<span class="nc bnc" id="L2081" title="All 2 branches missed.">                        if (keyStoreCredential != null) throw reader.unexpectedElement();</span>
<span class="nc" id="L2082">                        keyStoreCredential = parseKeyStoreRefType(reader, xmlVersion, keyStoresMap, credentialStoresMap, providers);</span>
<span class="nc" id="L2083">                        break;</span>
                    }
                    case &quot;key-store-clear-password&quot;: {
<span class="nc bnc" id="L2086" title="All 2 branches missed.">                        if (keyStoreCredential != null) throw reader.unexpectedElement();</span>
<span class="nc" id="L2087">                        ExceptionSupplier&lt;Password, ConfigXMLParseException&gt; credential = parseClearPassword(reader, providers);</span>
<span class="nc" id="L2088">                        keyStoreCredential = () -&gt; new PasswordEntry(credential.get());</span>
<span class="nc" id="L2089">                        break;</span>
                    }
                    case &quot;key-store-masked-password&quot;: {
<span class="nc bnc" id="L2092" title="All 4 branches missed.">                        if (keyStoreCredential != null || !xmlVersion.isAtLeast(Version.VERSION_1_4)) throw reader.unexpectedElement();</span>
<span class="nc" id="L2093">                        ExceptionSupplier&lt;Password, ConfigXMLParseException&gt; credential = parseMaskedPassword(reader, providers);</span>
<span class="nc" id="L2094">                        keyStoreCredential = () -&gt; new PasswordEntry(credential.get());</span>
<span class="nc" id="L2095">                        break;</span>
                    }
                    case &quot;credential-store-reference&quot;: {
<span class="nc bnc" id="L2098" title="All 4 branches missed.">                        if (keyStoreCredential != null || !xmlVersion.isAtLeast(Version.VERSION_1_0_1)) {</span>
<span class="nc" id="L2099">                            throw reader.unexpectedElement();</span>
                        }
<span class="nc" id="L2101">                        final XMLLocation nestedLocation = reader.getLocation();</span>
<span class="nc" id="L2102">                        ExceptionSupplier&lt;CredentialSource, ConfigXMLParseException&gt; credentialSourceSupplier = parseCredentialStoreRefType(reader, credentialStoresMap);</span>
<span class="nc" id="L2103">                        keyStoreCredential = () -&gt; {</span>
                            try {
<span class="nc" id="L2105">                                PasswordCredential passwordCredential = credentialSourceSupplier.get().getCredential(PasswordCredential.class);</span>
<span class="nc bnc" id="L2106" title="All 2 branches missed.">                                if (passwordCredential == null) {</span>
<span class="nc" id="L2107">                                    throw new ConfigXMLParseException(xmlLog.couldNotObtainCredential(), reader);</span>
                                }
<span class="nc" id="L2109">                                return new PasswordEntry(passwordCredential.getPassword());</span>
<span class="nc" id="L2110">                            } catch (IOException e) {</span>
<span class="nc" id="L2111">                                throw xmlLog.xmlFailedToCreateCredential(nestedLocation, e);</span>
                            }
                        };
<span class="nc" id="L2114">                        break;</span>
                    }
<span class="nc" id="L2116">                    default: throw reader.unexpectedElement();</span>
                }
<span class="nc bnc" id="L2118" title="All 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="nc" id="L2119">                final ExceptionSupplier&lt;KeyStore.Entry, ConfigXMLParseException&gt; finalKeyStoreCredential = keyStoreCredential;</span>
<span class="nc" id="L2120">                final String finalKeyStoreName = keyStoreName;</span>
<span class="nc" id="L2121">                final String finalAlias = alias;</span>
<span class="nc" id="L2122">                return () -&gt; {</span>
                    try {
<span class="nc" id="L2124">                        final ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt; keyStoreSupplier = keyStoresMap.get(finalKeyStoreName);</span>
<span class="nc bnc" id="L2125" title="All 2 branches missed.">                        if (keyStoreSupplier == null) {</span>
<span class="nc" id="L2126">                            throw xmlLog.xmlUnknownKeyStoreSpecified(location);</span>
                        }
<span class="nc" id="L2128">                        char[] password = keyStoreCredentialToPassword(finalKeyStoreCredential, providers);</span>
<span class="nc bnc" id="L2129" title="All 2 branches missed.">                        final KeyStore.ProtectionParameter protectionParameter = password != null ? new KeyStore.PasswordProtection(password) : null;</span>
<span class="nc bnc" id="L2130" title="All 2 branches missed.">                        if (finalAlias != null) {</span>
<span class="nc bnc" id="L2131" title="All 2 branches missed.">                            KeyStore.Entry finalEntry = keyStoreSupplier.get().getEntry(finalAlias, protectionParameter == null ? null : protectionParameter);</span>
<span class="nc bnc" id="L2132" title="All 2 branches missed.">                            if (finalEntry == null) {</span>
<span class="nc" id="L2133">                                throw xmlLog.keyStoreEntryMissing(location, finalAlias);</span>
                            }
<span class="nc" id="L2135">                            return finalEntry;</span>
                        } else {
                            //  allow to retrieve entry without providing alias only if keystore includes one and only entry.
<span class="nc bnc" id="L2138" title="All 2 branches missed.">                            if (keyStoreSupplier.get().size() &gt; 1) {</span>
<span class="nc" id="L2139">                                throw xmlLog.missingAlias(location);</span>
<span class="nc bnc" id="L2140" title="All 2 branches missed.">                            } else if (keyStoreSupplier.get().aliases().hasMoreElements()) {</span>
<span class="nc" id="L2141">                                String firstAlias = keyStoreSupplier.get().aliases().nextElement();</span>
<span class="nc bnc" id="L2142" title="All 2 branches missed.">                                KeyStore.Entry finalEntry = keyStoreSupplier.get().getEntry(firstAlias, protectionParameter == null ? null : protectionParameter);</span>
<span class="nc bnc" id="L2143" title="All 2 branches missed.">                                if (finalEntry == null) {</span>
<span class="nc" id="L2144">                                    throw xmlLog.keyStoreEntryMissing(location, firstAlias);</span>
                                }
<span class="nc" id="L2146">                                return finalEntry;</span>
                            } else {
<span class="nc" id="L2148">                                return null;</span>
                            }
                        }
<span class="nc" id="L2151">                    } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L2152">                        throw xmlLog.xmlFailedToLoadKeyStoreData(location, e);</span>
                    }
                };
            } else {
<span class="nc" id="L2156">                throw reader.unexpectedContent();</span>
            }
<span class="nc" id="L2158">        }</span>
<span class="nc" id="L2159">        throw reader.unexpectedDocumentEnd();</span>
    }

    private static char[] keyStoreCredentialToPassword(ExceptionSupplier&lt;KeyStore.Entry, ConfigXMLParseException&gt; keyStoreCredential,
            Supplier&lt;Provider[]&gt; providers) throws GeneralSecurityException, ConfigXMLParseException {
<span class="pc bpc" id="L2164" title="1 of 2 branches missed.">        final KeyStore.Entry entry = keyStoreCredential == null ? null : keyStoreCredential.get();</span>
<span class="pc bpc" id="L2165" title="1 of 2 branches missed.">        if (entry instanceof PasswordEntry) {</span>
<span class="fc" id="L2166">            Password password = ((PasswordEntry) entry).getPassword();</span>
<span class="fc" id="L2167">            final PasswordFactory passwordFactory = PasswordFactory.getInstance(password.getAlgorithm(), providers);</span>
<span class="fc" id="L2168">            password = passwordFactory.translate(password);</span>
<span class="fc" id="L2169">            final ClearPasswordSpec spec = passwordFactory.getKeySpec(password, ClearPasswordSpec.class);</span>
<span class="fc" id="L2170">            return spec.getEncodedPassword();</span>
<span class="nc bnc" id="L2171" title="All 2 branches missed.">        } else if (entry instanceof KeyStore.SecretKeyEntry) {</span>
<span class="nc" id="L2172">            final SecretKey secretKey = ((KeyStore.SecretKeyEntry) entry).getSecretKey();</span>
<span class="nc" id="L2173">            final SecretKeyFactory instance = SecretKeyFactory.getInstance(secretKey.getAlgorithm());</span>
<span class="nc" id="L2174">            final SecretKeySpec keySpec = (SecretKeySpec) instance.getKeySpec(secretKey, SecretKeySpec.class);</span>
<span class="nc" id="L2175">            final byte[] encoded = keySpec.getEncoded();</span>
<span class="nc bnc" id="L2176" title="All 2 branches missed.">            return encoded == null ? null : new String(encoded, StandardCharsets.UTF_8).toCharArray();</span>
        } else {
<span class="nc" id="L2178">            return null;</span>
        }
    }

    /**
     * Parse an XML element of type {@code trust-store-ref-type} from an XML reader.
     *
     * @param reader the XML stream reader
     * @param keyStoresMap the map of key stores to use
     * @return the key store entry factory
     * @throws ConfigXMLParseException if the resource failed to be parsed
     */
    static ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt; parseTrustStoreRefType(ConfigurationXMLStreamReader reader, final Map&lt;String, ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt;&gt; keyStoresMap) throws ConfigXMLParseException {
<span class="nc" id="L2191">        final int attributeCount = reader.getAttributeCount();</span>
<span class="nc" id="L2192">        final XMLLocation location = reader.getLocation();</span>
<span class="nc" id="L2193">        String keyStoreName = null;</span>
<span class="nc bnc" id="L2194" title="All 2 branches missed.">        for (int i = 0; i &lt; attributeCount; i ++) {</span>
<span class="nc" id="L2195">            checkAttributeNamespace(reader, i);</span>
<span class="nc bnc" id="L2196" title="All 2 branches missed.">            switch (reader.getAttributeLocalName(i)) {</span>
                case &quot;key-store-name&quot;: {
<span class="nc bnc" id="L2198" title="All 2 branches missed.">                    if (keyStoreName != null) throw reader.unexpectedAttribute(i);</span>
<span class="nc" id="L2199">                    keyStoreName = reader.getAttributeValueResolved(i);</span>
<span class="nc" id="L2200">                    break;</span>
                }
<span class="nc" id="L2202">                default: throw reader.unexpectedElement();</span>
            }
        }
<span class="nc bnc" id="L2205" title="All 2 branches missed.">        if (keyStoreName == null) {</span>
<span class="nc" id="L2206">            throw missingAttribute(reader, &quot;key-store-name&quot;);</span>
        }
<span class="nc bnc" id="L2208" title="All 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="nc" id="L2209">            final int tag = reader.nextTag();</span>
<span class="nc bnc" id="L2210" title="All 2 branches missed.">            if (tag == START_ELEMENT) {</span>
<span class="nc" id="L2211">                throw reader.unexpectedElement();</span>
<span class="nc bnc" id="L2212" title="All 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="nc" id="L2213">                final ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt; keyStoreSupplier = keyStoresMap.get(keyStoreName);</span>
<span class="nc bnc" id="L2214" title="All 2 branches missed.">                if (keyStoreSupplier == null) {</span>
<span class="nc" id="L2215">                    throw xmlLog.xmlUnknownKeyStoreSpecified(location);</span>
                }
<span class="nc" id="L2217">                return keyStoreSupplier;</span>
            } else {
<span class="nc" id="L2219">                throw reader.unexpectedContent();</span>
            }
        }
<span class="nc" id="L2222">        throw reader.unexpectedDocumentEnd();</span>
    }

    static ExceptionSupplier&lt;CredentialSource, ConfigXMLParseException&gt; parseCredentialStoreRefType(ConfigurationXMLStreamReader reader, final Map&lt;String, ExceptionSupplier&lt;CredentialStore, ConfigXMLParseException&gt;&gt; credentialStoresMap) throws ConfigXMLParseException {
<span class="fc" id="L2226">        final int attributeCount = reader.getAttributeCount();</span>
<span class="fc" id="L2227">        String storeName = null;</span>
<span class="fc" id="L2228">        String alias = null;</span>
<span class="fc" id="L2229">        String clearText = null;</span>
<span class="fc bfc" id="L2230" title="All 2 branches covered.">        for (int i = 0; i &lt; attributeCount; i ++) {</span>
<span class="fc" id="L2231">            checkAttributeNamespace(reader, i);</span>
<span class="pc bpc" id="L2232" title="1 of 4 branches missed.">            switch (reader.getAttributeLocalName(i)) {</span>
                case &quot;store&quot;: {
<span class="pc bpc" id="L2234" title="1 of 2 branches missed.">                    if (storeName != null) throw reader.unexpectedAttribute(i);</span>
<span class="fc" id="L2235">                    storeName = reader.getAttributeValueResolved(i);</span>
<span class="fc" id="L2236">                    break;</span>
                }
                case &quot;alias&quot;: {
<span class="pc bpc" id="L2239" title="1 of 2 branches missed.">                    if (alias != null) throw reader.unexpectedAttribute(i);</span>
<span class="fc" id="L2240">                    alias = reader.getAttributeValueResolved(i);</span>
<span class="fc" id="L2241">                    break;</span>
                }
                case &quot;clear-text&quot;: {
<span class="pc bpc" id="L2244" title="1 of 2 branches missed.">                    if (clearText != null) throw reader.unexpectedAttribute(i);</span>
<span class="fc" id="L2245">                    clearText = reader.getAttributeValueResolved(i);</span>
<span class="fc" id="L2246">                    break;</span>
                }
                default:
<span class="nc" id="L2249">                    throw reader.unexpectedAttribute(i);</span>
            }
        }
<span class="pc bpc" id="L2252" title="1 of 2 branches missed.">        if (! reader.hasNext()) throw reader.unexpectedDocumentEnd();</span>
<span class="pc bpc" id="L2253" title="1 of 2 branches missed.">        if (reader.nextTag() != END_ELEMENT) throw reader.unexpectedContent();</span>
<span class="fc" id="L2254">        final XMLLocation finalLocation = reader.getLocation();</span>
<span class="fc" id="L2255">        final String finalStoreName = storeName;</span>
<span class="fc" id="L2256">        final String finalClearText = clearText;</span>
<span class="fc" id="L2257">        final String finalAlias = alias;</span>
<span class="pc bpc" id="L2258" title="3 of 4 branches missed.">        if (finalStoreName == null &amp;&amp; finalClearText == null) throw xmlLog.xmlInvalidCredentialStoreRef(reader.getLocation());</span>
<span class="pc bpc" id="L2259" title="2 of 4 branches missed.">        if (finalStoreName != null &amp;&amp; finalAlias == null) throw missingAttribute(reader, &quot;alias&quot;);</span>
<span class="fc" id="L2260">        return () -&gt; {</span>
<span class="pc bpc" id="L2261" title="1 of 2 branches missed.">            if (finalStoreName != null) {</span>
<span class="fc" id="L2262">                final ExceptionSupplier&lt;CredentialStore, ConfigXMLParseException&gt; supplier = credentialStoresMap.get(finalStoreName);</span>
<span class="pc bpc" id="L2263" title="1 of 2 branches missed.">                if (supplier == null) {</span>
<span class="nc" id="L2264">                    throw xmlLog.xmlCredentialStoreNameNotDefined(finalLocation, finalStoreName);</span>
                }
<span class="fc" id="L2266">                final CredentialStore credentialStore = supplier.get();</span>
<span class="fc" id="L2267">                return new CredentialStoreCredentialSource(credentialStore, finalAlias);</span>
            } else {
<span class="nc" id="L2269">                final PasswordCredential passwordCredential = new PasswordCredential(ClearPassword.createRaw(ClearPassword.ALGORITHM_CLEAR, finalClearText.toCharArray()));</span>
<span class="nc" id="L2270">                return IdentityCredentials.NONE.withCredential(passwordCredential);</span>
            }
        };
    }

    /**
     * Parse an XML element of type {@code credential-stores-type} from an XML reader.
     *
     * @param reader the XML stream reader
     * @param xmlVersion the version of parsed XML
     * @param keyStoresMap the key stores map
     * @param credentialStoresMap the map of  credential stores to use  @throws ConfigXMLParseException if the resource failed to be parsed
     */
    private static void parseCredentialStoresType(ConfigurationXMLStreamReader reader, final Version xmlVersion, Map&lt;String, ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt;&gt; keyStoresMap, final Map&lt;String, ExceptionSupplier&lt;CredentialStore, ConfigXMLParseException&gt;&gt; credentialStoresMap, final Supplier&lt;Provider[]&gt; providers) throws ConfigXMLParseException {
<span class="fc" id="L2284">        final int attributeCount = reader.getAttributeCount();</span>
<span class="pc bpc" id="L2285" title="1 of 2 branches missed.">        if (attributeCount &gt; 0) {</span>
<span class="nc" id="L2286">            throw reader.unexpectedAttribute(0);</span>
        }
<span class="pc bpc" id="L2288" title="1 of 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="fc" id="L2289">            final int tag = reader.nextTag();</span>
<span class="fc bfc" id="L2290" title="All 2 branches covered.">            if (tag == START_ELEMENT) {</span>
<span class="fc" id="L2291">                checkElementNamespace(reader, xmlVersion);</span>
<span class="pc bpc" id="L2292" title="1 of 2 branches missed.">                switch (reader.getLocalName()) {</span>
                    case &quot;credential-store&quot;: {
<span class="fc" id="L2294">                        parseCredentialStoreType(reader, xmlVersion, keyStoresMap, credentialStoresMap, providers);</span>
<span class="fc" id="L2295">                        break;</span>
                    }
<span class="pc" id="L2297">                    default: throw reader.unexpectedElement();</span>
                }
<span class="pc bpc" id="L2299" title="1 of 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="fc" id="L2300">                return;</span>
            } else {
<span class="nc" id="L2302">                throw reader.unexpectedContent();</span>
            }
<span class="fc" id="L2304">        }</span>
<span class="nc" id="L2305">        throw reader.unexpectedDocumentEnd();</span>
    }

    /**
     * Parse an XML element of type {@code credential-store-type} from an XML reader.
     *
     * @param reader the XML stream reader
     * @param xmlVersion the version of parsed XML
     * @param keyStoresMap the key stores map
     * @param credentialStoresMap the map of  credential stores to fill  @throws ConfigXMLParseException if the resource failed to be parsed
     */
    private static void parseCredentialStoreType(ConfigurationXMLStreamReader reader, final Version xmlVersion, Map&lt;String, ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt;&gt; keyStoresMap, final Map&lt;String, ExceptionSupplier&lt;CredentialStore, ConfigXMLParseException&gt;&gt; credentialStoresMap, final Supplier&lt;Provider[]&gt; providers) throws ConfigXMLParseException {
<span class="fc" id="L2317">        final XMLLocation location = reader.getLocation();</span>
<span class="fc" id="L2318">        final int attributeCount = reader.getAttributeCount();</span>
<span class="fc" id="L2319">        String name = null;</span>
<span class="fc" id="L2320">        String type = null;</span>
<span class="fc" id="L2321">        String provider = null;</span>
<span class="fc bfc" id="L2322" title="All 2 branches covered.">        for (int i = 0; i &lt; attributeCount; i ++) {</span>
<span class="fc" id="L2323">            final String attributeNamespace = reader.getAttributeNamespace(i);</span>
<span class="pc bpc" id="L2324" title="3 of 4 branches missed.">            if (attributeNamespace != null &amp;&amp; ! attributeNamespace.isEmpty()) {</span>
<span class="nc" id="L2325">                throw reader.unexpectedAttribute(i);</span>
            }
<span class="pc bpc" id="L2327" title="3 of 4 branches missed.">            switch (reader.getAttributeLocalName(i)) {</span>
                case &quot;type&quot;: {
<span class="nc bnc" id="L2329" title="All 2 branches missed.">                    if (type != null) throw reader.unexpectedAttribute(i);</span>
<span class="nc" id="L2330">                    type = reader.getAttributeValueResolved(i);</span>
<span class="nc" id="L2331">                    break;</span>
                }
                case &quot;provider&quot;: {
<span class="nc bnc" id="L2334" title="All 2 branches missed.">                    if (provider != null) throw reader.unexpectedAttribute(i);</span>
<span class="nc" id="L2335">                    provider = reader.getAttributeValueResolved(i);</span>
<span class="nc" id="L2336">                    break;</span>
                }
                case &quot;name&quot;: {
<span class="pc bpc" id="L2339" title="1 of 2 branches missed.">                    if (name != null) throw reader.unexpectedAttribute(i);</span>
<span class="fc" id="L2340">                    name = reader.getAttributeValueResolved(i);</span>
<span class="fc" id="L2341">                    break;</span>
                }
                default:
<span class="nc" id="L2344">                    throw reader.unexpectedAttribute(i);</span>
            }
        }
<span class="pc bpc" id="L2347" title="1 of 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L2348">            throw missingAttribute(reader, &quot;name&quot;);</span>
        }

<span class="fc" id="L2351">        final Map&lt;String, String&gt; attributesMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L2352">        int foundBits = 0;</span>
<span class="fc" id="L2353">        ExceptionSupplier&lt;CredentialSource, ConfigXMLParseException&gt; credentialSourceSupplier = null;</span>
<span class="fc" id="L2354">        DeferredSupplier&lt;Provider[]&gt; providersSupplier = new DeferredSupplier&lt;&gt;(providers);</span>
<span class="pc bpc" id="L2355" title="1 of 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="fc" id="L2356">            final int tag = reader.nextTag();</span>
<span class="fc bfc" id="L2357" title="All 2 branches covered.">            if (tag == START_ELEMENT) {</span>
<span class="fc" id="L2358">                checkElementNamespace(reader, xmlVersion);</span>
<span class="pc bpc" id="L2359" title="2 of 4 branches missed.">                switch (reader.getLocalName()) {</span>
                    case &quot;attributes&quot;: {
<span class="pc bpc" id="L2361" title="1 of 2 branches missed.">                        if (isSet(foundBits, 1)) throw reader.unexpectedElement();</span>
<span class="fc" id="L2362">                        foundBits = setBit(foundBits, 1);</span>
<span class="fc" id="L2363">                        parseAttributesType(reader, xmlVersion, attributesMap);</span>
<span class="fc" id="L2364">                        break;</span>
                    }
                    case &quot;protection-parameter-credentials&quot;: {
<span class="pc bpc" id="L2367" title="1 of 2 branches missed.">                        if (isSet(foundBits, 2)) throw reader.unexpectedElement();</span>
<span class="fc" id="L2368">                        foundBits = setBit(foundBits, 2);</span>
<span class="fc" id="L2369">                        credentialSourceSupplier = parseCredentialsType(reader, xmlVersion, keyStoresMap, credentialStoresMap, providersSupplier);</span>
<span class="fc" id="L2370">                        break;</span>
                    }
                    case &quot;providers&quot;: {
<span class="nc bnc" id="L2373" title="All 2 branches missed.">                        if (isSet(foundBits, 3)) throw reader.unexpectedElement();</span>
<span class="nc" id="L2374">                        foundBits = setBit(foundBits, 3);</span>
<span class="nc" id="L2375">                        Supplier&lt;Provider[]&gt; supplier = parseProvidersType(reader, xmlVersion);</span>
<span class="nc bnc" id="L2376" title="All 2 branches missed.">                        if (supplier != null) {</span>
<span class="nc" id="L2377">                            providersSupplier.setSupplier(supplier);</span>
                        }
                        break;
                    }
<span class="pc" id="L2381">                    default: throw reader.unexpectedElement();</span>
                }
<span class="pc bpc" id="L2383" title="1 of 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="pc bpc" id="L2384" title="1 of 2 branches missed.">                if (!credentialStoresMap.containsKey(name)) {</span>
<span class="fc" id="L2385">                    ExceptionSupplier&lt;CredentialStore, ConfigXMLParseException&gt; credentialStoreSecurityFactory = new CredentialStoreFactory(name, type, attributesMap, provider, location, credentialSourceSupplier, providersSupplier);</span>
<span class="fc" id="L2386">                    credentialStoresMap.put(name, credentialStoreSecurityFactory);</span>
<span class="fc" id="L2387">                } else {</span>
<span class="nc" id="L2388">                    throw xmlLog.duplicateCredentialStoreName(reader, name);</span>
                }
<span class="fc" id="L2390">                return;</span>
            } else {
<span class="nc" id="L2392">                throw reader.unexpectedContent();</span>
            }
<span class="fc" id="L2394">        }</span>
<span class="nc" id="L2395">        throw reader.unexpectedDocumentEnd();</span>
    }

    // common types

    /**
     * Parse attributes {@code attributes-type} from an XML reader.
     *
     * @param reader the XML stream reader
     * @param attributesMap the map to put attributes to.
     * @throws ConfigXMLParseException if the resource failed to be parsed
     */
    private static void parseAttributesType(ConfigurationXMLStreamReader reader, final Version xmlVersion, final Map&lt;String, String&gt; attributesMap) throws ConfigXMLParseException {
<span class="fc" id="L2408">        final int attributeCount = reader.getAttributeCount();</span>
<span class="pc bpc" id="L2409" title="1 of 2 branches missed.">        if (attributeCount &gt; 0) {</span>
<span class="nc" id="L2410">            throw reader.unexpectedAttribute(0);</span>
        }
<span class="pc bpc" id="L2412" title="1 of 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="fc" id="L2413">            final int tag = reader.nextTag();</span>
<span class="fc bfc" id="L2414" title="All 2 branches covered.">            if (tag == START_ELEMENT) {</span>
<span class="fc" id="L2415">                checkElementNamespace(reader, xmlVersion);</span>
<span class="pc bpc" id="L2416" title="1 of 2 branches missed.">                switch (reader.getLocalName()) {</span>
                    case &quot;attribute&quot;: {
<span class="fc" id="L2418">                        parseAttributeType(reader, attributesMap);</span>
<span class="fc" id="L2419">                        break;</span>
                    }
<span class="pc" id="L2421">                    default: throw reader.unexpectedElement();</span>
                }
<span class="pc bpc" id="L2423" title="1 of 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="fc" id="L2424">                return;</span>
            } else {
<span class="nc" id="L2426">                throw reader.unexpectedContent();</span>
            }
<span class="fc" id="L2428">        }</span>
<span class="nc" id="L2429">        throw reader.unexpectedDocumentEnd();</span>
    }

    /**
     * Parse an attribute {@code attribute-type} from an XML reader.
     *
     * @param reader the XML stream reader
     * @param attributesMap the map to put attributes to.
     * @throws ConfigXMLParseException if the resource failed to be parsed
     */
    private static void parseAttributeType(ConfigurationXMLStreamReader reader, final Map&lt;String, String&gt; attributesMap) throws ConfigXMLParseException {
<span class="fc" id="L2440">        final int attributeCount = reader.getAttributeCount();</span>
<span class="fc" id="L2441">        String name = null;</span>
<span class="fc" id="L2442">        String value = null;</span>
<span class="fc bfc" id="L2443" title="All 2 branches covered.">        for (int i = 0; i &lt; attributeCount; i ++) {</span>
<span class="fc" id="L2444">            final String attributeNamespace = reader.getAttributeNamespace(i);</span>
<span class="pc bpc" id="L2445" title="3 of 4 branches missed.">            if (attributeNamespace != null &amp;&amp; ! attributeNamespace.isEmpty()) {</span>
<span class="nc" id="L2446">                throw reader.unexpectedAttribute(i);</span>
            }
<span class="pc bpc" id="L2448" title="1 of 3 branches missed.">            switch (reader.getAttributeLocalName(i)) {</span>
                case &quot;name&quot;: {
<span class="pc bpc" id="L2450" title="1 of 2 branches missed.">                    if (name != null) throw reader.unexpectedAttribute(i);</span>
<span class="fc" id="L2451">                    name = reader.getAttributeValueResolved(i);</span>
<span class="fc" id="L2452">                    break;</span>
                }
                case &quot;value&quot;: {
<span class="pc bpc" id="L2455" title="1 of 2 branches missed.">                    if (value != null) throw reader.unexpectedAttribute(i);</span>
<span class="fc" id="L2456">                    value = reader.getAttributeValueResolved(i);</span>
<span class="fc" id="L2457">                    break;</span>
                }
                default:
<span class="nc" id="L2460">                    throw reader.unexpectedAttribute(i);</span>
            }
        }
<span class="pc bpc" id="L2463" title="1 of 2 branches missed.">        if (reader.hasNext()) {</span>
<span class="fc" id="L2464">            final int tag = reader.nextTag();</span>
<span class="pc bpc" id="L2465" title="1 of 2 branches missed.">            if (tag == START_ELEMENT) {</span>
<span class="nc" id="L2466">                throw reader.unexpectedContent();</span>
<span class="pc bpc" id="L2467" title="1 of 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="pc bpc" id="L2468" title="1 of 2 branches missed.">                if (!attributesMap.containsKey(name)) {</span>
<span class="fc" id="L2469">                    attributesMap.put(name, value);</span>
                } else {
<span class="nc" id="L2471">                    throw xmlLog.duplicateAttributeFound(reader, name);</span>
                }
<span class="fc" id="L2473">                return;</span>
            }
<span class="nc" id="L2475">            throw reader.unexpectedContent();</span>
        }
<span class="nc" id="L2477">        throw reader.unexpectedContent();</span>
    }

    /**
     * Parse an XML element of type {@code empty-type} from an XML reader.
     *
     * @param reader the XML stream reader
     * @throws ConfigXMLParseException if the resource failed to be parsed
     */
    static void parseEmptyType(ConfigurationXMLStreamReader reader) throws ConfigXMLParseException {
<span class="fc" id="L2487">        requireNoAttributes(reader);</span>
<span class="pc bpc" id="L2488" title="1 of 2 branches missed.">        if (reader.hasNext()) {</span>
<span class="fc" id="L2489">            final int tag = reader.nextTag();</span>
<span class="pc bpc" id="L2490" title="1 of 2 branches missed.">            if (tag == START_ELEMENT) {</span>
<span class="nc" id="L2491">                throw reader.unexpectedElement();</span>
<span class="pc bpc" id="L2492" title="1 of 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="fc" id="L2493">                return;</span>
            } else {
<span class="nc" id="L2495">                throw reader.unexpectedContent();</span>
            }
        }
<span class="nc" id="L2498">        throw reader.unexpectedDocumentEnd();</span>
    }

    /**
     * Parse an XML element of type {@code name-type} from an XML reader.
     *
     * @param reader the XML stream reader
     * @return the parsed name
     * @throws ConfigXMLParseException if the resource failed to be parsed
     */
    static String parseNameType(ConfigurationXMLStreamReader reader) throws ConfigXMLParseException {
<span class="fc" id="L2509">        return parseNameType(reader, false);</span>
    }

    /**
     * Parse an XML element of type {@code name-type} from an XML reader.
     *
     * @param reader the XML stream reader
     * @param optional is the name attribute optional?
     * @return the parsed name
     * @throws ConfigXMLParseException if the resource failed to be parsed
     */
    static String parseNameType(ConfigurationXMLStreamReader reader, boolean optional) throws ConfigXMLParseException {
<span class="fc" id="L2521">        final int attributeCount = reader.getAttributeCount();</span>
<span class="fc" id="L2522">        String name = null;</span>
<span class="fc bfc" id="L2523" title="All 2 branches covered.">        for (int i = 0; i &lt; attributeCount; i ++) {</span>
<span class="fc" id="L2524">            checkAttributeNamespace(reader, i);</span>
<span class="pc bpc" id="L2525" title="1 of 2 branches missed.">            if (reader.getAttributeLocalName(i).equals(&quot;name&quot;)) {</span>
<span class="fc" id="L2526">                name = reader.getAttributeValueResolved(i);</span>
            } else {
<span class="nc" id="L2528">                throw reader.unexpectedAttribute(i);</span>
            }
        }
<span class="pc bpc" id="L2531" title="3 of 4 branches missed.">        if (name == null &amp;&amp; !optional) {</span>
<span class="nc" id="L2532">            throw missingAttribute(reader, &quot;name&quot;);</span>
        }
<span class="pc bpc" id="L2534" title="1 of 2 branches missed.">        if (reader.hasNext()) {</span>
<span class="fc" id="L2535">            final int tag = reader.nextTag();</span>
<span class="pc bpc" id="L2536" title="1 of 2 branches missed.">            if (tag == START_ELEMENT) {</span>
<span class="nc" id="L2537">                throw reader.unexpectedElement();</span>
<span class="pc bpc" id="L2538" title="1 of 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="fc" id="L2539">                return name;</span>
            } else {
<span class="nc" id="L2541">                throw reader.unexpectedContent();</span>
            }
        }
<span class="nc" id="L2544">        throw reader.unexpectedDocumentEnd();</span>
    }

    /**
     * Parse an XML element of type {@code resource-type} from an XML reader.
     *
     * @param reader the XML stream reader
     * @param xmlVersion the version of the XML being parsed
     * @return An {@code ExceptionSupplier&lt;InputStream, IOException&gt;} for the referenced resource
     * @throws ConfigXMLParseException if the resource failed to be parsed
     */
    static ExceptionSupplier&lt;InputStream, IOException&gt; parseResourceType(ConfigurationXMLStreamReader reader, Version xmlVersion) throws ConfigXMLParseException {
<span class="nc" id="L2556">        final int attributeCount = reader.getAttributeCount();</span>
<span class="nc" id="L2557">        String name = null;</span>
<span class="nc" id="L2558">        String module = null;</span>
<span class="nc bnc" id="L2559" title="All 2 branches missed.">        for (int i = 0; i &lt; attributeCount; i ++) {</span>
<span class="nc" id="L2560">            checkAttributeNamespace(reader, i);</span>
<span class="nc bnc" id="L2561" title="All 2 branches missed.">            if (reader.getAttributeLocalName(i).equals(&quot;name&quot;)) {</span>
<span class="nc" id="L2562">                name = reader.getAttributeValueResolved(i);</span>
<span class="nc bnc" id="L2563" title="All 4 branches missed.">            } else if (reader.getAttributeLocalName(i).equals(&quot;module-name&quot;) &amp;&amp; xmlVersion.isAtLeast(Version.VERSION_1_1)) {</span>
<span class="nc" id="L2564">                module = reader.getAttributeValueResolved(i);</span>
            } else {
<span class="nc" id="L2566">                throw reader.unexpectedAttribute(i);</span>
            }
        }
<span class="nc bnc" id="L2569" title="All 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L2570">            throw missingAttribute(reader, &quot;name&quot;);</span>
        }
<span class="nc bnc" id="L2572" title="All 2 branches missed.">        if (reader.hasNext()) {</span>
<span class="nc" id="L2573">            final int tag = reader.nextTag();</span>
<span class="nc bnc" id="L2574" title="All 2 branches missed.">            if (tag == START_ELEMENT) {</span>
<span class="nc" id="L2575">                throw reader.unexpectedElement();</span>
<span class="nc bnc" id="L2576" title="All 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="nc" id="L2577">                final String resourceName = name;</span>
<span class="nc bnc" id="L2578" title="All 2 branches missed.">                final ClassLoader classLoader = module != null ? ModuleLoader.getClassLoaderFromModule(reader, module) : Thread.currentThread().getContextClassLoader();</span>
<span class="nc" id="L2579">                return () -&gt; {</span>
<span class="nc bnc" id="L2580" title="All 2 branches missed.">                    ClassLoader actualClassLoader = classLoader != null ? classLoader : ElytronXmlParser.class.getClassLoader();</span>
<span class="nc" id="L2581">                    final InputStream stream = actualClassLoader.getResourceAsStream(resourceName);</span>
<span class="nc bnc" id="L2582" title="All 2 branches missed.">                    if (stream == null) throw new FileNotFoundException(resourceName);</span>
<span class="nc" id="L2583">                    return stream;</span>
                };
            } else {
<span class="nc" id="L2586">                throw reader.unexpectedContent();</span>
            }
        }
<span class="nc" id="L2589">        throw reader.unexpectedDocumentEnd();</span>
    }

    /**
     * Parse an XML element of type {@code port-type} from an XML reader.
     *
     * @param reader the XML stream reader
     * @return the port number (1-65535 inclusive)
     * @throws ConfigXMLParseException if the resource failed to be parsed
     */
    static int parsePortType(ConfigurationXMLStreamReader reader) throws ConfigXMLParseException {
<span class="fc" id="L2600">        final int attributeCount = reader.getAttributeCount();</span>
<span class="fc" id="L2601">        int number = -1;</span>
<span class="fc bfc" id="L2602" title="All 2 branches covered.">        for (int i = 0; i &lt; attributeCount; i ++) {</span>
<span class="fc" id="L2603">            checkAttributeNamespace(reader, i);</span>
<span class="pc bpc" id="L2604" title="1 of 2 branches missed.">            if (reader.getAttributeLocalName(i).equals(&quot;number&quot;)) {</span>
<span class="fc" id="L2605">                String s = reader.getAttributeValueResolved(i);</span>
                try {
<span class="fc" id="L2607">                    number = Integer.parseInt(s);</span>
<span class="nc" id="L2608">                } catch (NumberFormatException ignored) {</span>
<span class="nc" id="L2609">                    throw invalidPortNumber(reader, i);</span>
<span class="fc" id="L2610">                }</span>
<span class="pc bpc" id="L2611" title="2 of 4 branches missed.">                if (number &lt; 1 || number &gt; 65535) {</span>
<span class="nc" id="L2612">                    throw invalidPortNumber(reader, i);</span>
                }
<span class="fc" id="L2614">            } else {</span>
<span class="nc" id="L2615">                throw reader.unexpectedAttribute(i);</span>
            }
        }
<span class="pc bpc" id="L2618" title="1 of 2 branches missed.">        if (number == -1) {</span>
<span class="nc" id="L2619">            throw missingAttribute(reader, &quot;number&quot;);</span>
        }
<span class="pc bpc" id="L2621" title="1 of 2 branches missed.">        if (reader.hasNext()) {</span>
<span class="fc" id="L2622">            final int tag = reader.nextTag();</span>
<span class="pc bpc" id="L2623" title="1 of 2 branches missed.">            if (tag == START_ELEMENT) {</span>
<span class="nc" id="L2624">                throw reader.unexpectedElement();</span>
<span class="pc bpc" id="L2625" title="1 of 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="fc" id="L2626">                return number;</span>
            } else {
<span class="nc" id="L2628">                throw reader.unexpectedContent();</span>
            }
        }
<span class="nc" id="L2631">        throw reader.unexpectedDocumentEnd();</span>
    }

    /**
     * Parse an XML element of type {@code regex-substitution-type} from an XML reader.
     *
     * @param reader the XML stream reader
     * @return the regular expression based name rewriter
     * @throws ConfigXMLParseException if the resource failed to be parsed
     */
    static NameRewriter parseRegexSubstitutionType(ConfigurationXMLStreamReader reader) throws ConfigXMLParseException {
<span class="nc" id="L2642">        final int attributeCount = reader.getAttributeCount();</span>
<span class="nc" id="L2643">        Pattern pattern = null;</span>
<span class="nc" id="L2644">        String replacement = null;</span>
<span class="nc bnc" id="L2645" title="All 2 branches missed.">        for (int i = 0; i &lt; attributeCount; i ++) {</span>
<span class="nc" id="L2646">            checkAttributeNamespace(reader, i);</span>
<span class="nc bnc" id="L2647" title="All 2 branches missed.">            if (reader.getAttributeLocalName(i).equals(&quot;pattern&quot;)) {</span>
<span class="nc" id="L2648">                pattern = Pattern.compile(reader.getAttributeValueResolved(i));</span>
<span class="nc bnc" id="L2649" title="All 2 branches missed.">            } else if (reader.getAttributeLocalName(i).equals(&quot;replacement&quot;)) {</span>
<span class="nc" id="L2650">                replacement = reader.getAttributeValueResolved(i);</span>
            } else {
<span class="nc" id="L2652">                throw reader.unexpectedAttribute(i);</span>
            }
        }
<span class="nc bnc" id="L2655" title="All 2 branches missed.">        if (pattern == null) {</span>
<span class="nc" id="L2656">            throw missingAttribute(reader, &quot;pattern&quot;);</span>
        }
<span class="nc bnc" id="L2658" title="All 2 branches missed.">        if (replacement == null) {</span>
<span class="nc" id="L2659">            throw missingAttribute(reader, &quot;replacement&quot;);</span>
        }
<span class="nc bnc" id="L2661" title="All 2 branches missed.">        if (reader.hasNext()) {</span>
<span class="nc" id="L2662">            final int tag = reader.nextTag();</span>
<span class="nc bnc" id="L2663" title="All 2 branches missed.">            if (tag == START_ELEMENT) {</span>
<span class="nc" id="L2664">                throw reader.unexpectedElement();</span>
<span class="nc bnc" id="L2665" title="All 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="nc" id="L2666">                return new RegexNameRewriter(pattern, replacement, true);</span>
            } else {
<span class="nc" id="L2668">                throw reader.unexpectedContent();</span>
            }
        }
<span class="nc" id="L2671">        throw reader.unexpectedDocumentEnd();</span>
    }

    /**
     * Parse an XML element of type {@code names-type} from an XML reader.
     *
     * @param reader the XML stream reader
     * @return the array of parsed names
     * @throws ConfigXMLParseException if the resource failed to be parsed
     */
    static String[] parseNamesType(ConfigurationXMLStreamReader reader) throws ConfigXMLParseException {
<span class="fc" id="L2682">        final int attributeCount = reader.getAttributeCount();</span>
<span class="fc" id="L2683">        String[] names = null;</span>
<span class="fc bfc" id="L2684" title="All 2 branches covered.">        for (int i = 0; i &lt; attributeCount; i ++) {</span>
<span class="fc" id="L2685">            checkAttributeNamespace(reader, i);</span>
<span class="pc bpc" id="L2686" title="1 of 2 branches missed.">            if (reader.getAttributeLocalName(i).equals(&quot;names&quot;)) {</span>
<span class="fc" id="L2687">                String s = reader.getAttributeValueResolved(i);</span>
<span class="fc" id="L2688">                names = s.trim().split(&quot;\\s+&quot;);</span>
<span class="fc" id="L2689">            } else {</span>
<span class="nc" id="L2690">                throw reader.unexpectedAttribute(i);</span>
            }
        }
<span class="pc bpc" id="L2693" title="1 of 2 branches missed.">        if (names == null) {</span>
<span class="nc" id="L2694">            throw missingAttribute(reader, &quot;names&quot;);</span>
        }
<span class="pc bpc" id="L2696" title="1 of 2 branches missed.">        if (reader.hasNext()) {</span>
<span class="fc" id="L2697">            final int tag = reader.nextTag();</span>
<span class="pc bpc" id="L2698" title="1 of 2 branches missed.">            if (tag == START_ELEMENT) {</span>
<span class="nc" id="L2699">                throw reader.unexpectedElement();</span>
<span class="pc bpc" id="L2700" title="1 of 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="fc" id="L2701">                return names;</span>
            } else {
<span class="nc" id="L2703">                throw reader.unexpectedContent();</span>
            }
        }
<span class="nc" id="L2706">        throw reader.unexpectedDocumentEnd();</span>
    }

    /**
     * Parse an XML element of type {@code uri-type} from an XML reader.
     *
     * @param reader the XML stream reader
     * @return the parsed URI
     * @throws ConfigXMLParseException if the resource failed to be parsed
     */
    static URI parseUriType(ConfigurationXMLStreamReader reader) throws ConfigXMLParseException {
<span class="nc" id="L2717">        final int attributeCount = reader.getAttributeCount();</span>
<span class="nc" id="L2718">        URI uri = null;</span>
<span class="nc bnc" id="L2719" title="All 2 branches missed.">        for (int i = 0; i &lt; attributeCount; i ++) {</span>
<span class="nc" id="L2720">            checkAttributeNamespace(reader, i);</span>
<span class="nc bnc" id="L2721" title="All 2 branches missed.">            if (reader.getAttributeLocalName(i).equals(&quot;uri&quot;)) {</span>
<span class="nc" id="L2722">                uri = reader.getURIAttributeValueResolved(i);</span>
            } else {
<span class="nc" id="L2724">                throw reader.unexpectedAttribute(i);</span>
            }
        }
<span class="nc bnc" id="L2727" title="All 2 branches missed.">        if (uri == null) {</span>
<span class="nc" id="L2728">            throw missingAttribute(reader, &quot;uri&quot;);</span>
        }
<span class="nc bnc" id="L2730" title="All 2 branches missed.">        if (reader.hasNext()) {</span>
<span class="nc" id="L2731">            final int tag = reader.nextTag();</span>
<span class="nc bnc" id="L2732" title="All 2 branches missed.">            if (tag == START_ELEMENT) {</span>
<span class="nc" id="L2733">                throw reader.unexpectedElement();</span>
<span class="nc bnc" id="L2734" title="All 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="nc" id="L2735">                return uri;</span>
            } else {
<span class="nc" id="L2737">                throw reader.unexpectedContent();</span>
            }
        }
<span class="nc" id="L2740">        throw reader.unexpectedDocumentEnd();</span>
    }

    static SaslMechanismSelector parseSaslMechanismSelectorType(ConfigurationXMLStreamReader reader) throws ConfigXMLParseException {
<span class="nc" id="L2744">        final int attributeCount = reader.getAttributeCount();</span>
<span class="nc" id="L2745">        SaslMechanismSelector selector = null;</span>
<span class="nc bnc" id="L2746" title="All 2 branches missed.">        for (int i = 0; i &lt; attributeCount; i ++) {</span>
<span class="nc" id="L2747">            checkAttributeNamespace(reader, i);</span>
<span class="nc bnc" id="L2748" title="All 2 branches missed.">            if (reader.getAttributeLocalName(i).equals(&quot;selector&quot;)) {</span>
<span class="nc" id="L2749">                selector = SaslMechanismSelector.fromString(reader.getAttributeValueResolved(i));</span>
            } else {
<span class="nc" id="L2751">                throw reader.unexpectedAttribute(i);</span>
            }
        }
<span class="nc bnc" id="L2754" title="All 2 branches missed.">        if (selector == null) {</span>
<span class="nc" id="L2755">            throw missingAttribute(reader, &quot;selector&quot;);</span>
        }
<span class="nc bnc" id="L2757" title="All 2 branches missed.">        if (reader.hasNext()) {</span>
<span class="nc" id="L2758">            final int tag = reader.nextTag();</span>
<span class="nc bnc" id="L2759" title="All 2 branches missed.">            if (tag == START_ELEMENT) {</span>
<span class="nc" id="L2760">                throw reader.unexpectedElement();</span>
<span class="nc bnc" id="L2761" title="All 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="nc" id="L2762">                return selector;</span>
            } else {
<span class="nc" id="L2764">                throw reader.unexpectedContent();</span>
            }
        }
<span class="nc" id="L2767">        throw reader.unexpectedDocumentEnd();</span>
    }

    /**
     * Parse an XML element of type {@code ssl-cipher-selector-type} from an XML reader.
     *
     * @param reader the XML stream reader
     * @return the parsed cipher suite selector
     * @throws ConfigXMLParseException if the resource failed to be parsed
     */
    static CipherSuiteSelector parseCipherSuiteSelectorType(ConfigurationXMLStreamReader reader, Version xmlVersion) throws ConfigXMLParseException {
<span class="fc" id="L2778">        final int attributeCount = reader.getAttributeCount();</span>
<span class="fc" id="L2779">        CipherSuiteSelector selector = null;</span>
<span class="fc" id="L2780">        CipherSuiteSelector names = null;</span>
<span class="fc bfc" id="L2781" title="All 2 branches covered.">        for (int i = 0; i &lt; attributeCount; i ++) {</span>
<span class="fc" id="L2782">            checkAttributeNamespace(reader, i);</span>
<span class="fc bfc" id="L2783" title="All 2 branches covered.">            if (reader.getAttributeLocalName(i).equals(&quot;selector&quot;)) {</span>
<span class="fc" id="L2784">                selector = CipherSuiteSelector.fromString(reader.getAttributeValueResolved(i));</span>
<span class="pc bpc" id="L2785" title="2 of 4 branches missed.">            } else if (xmlVersion.isAtLeast(Version.VERSION_1_5) &amp;&amp; reader.getAttributeLocalName(i).equals(&quot;names&quot;)) {</span>
<span class="fc" id="L2786">                names = CipherSuiteSelector.fromNamesString(reader.getAttributeValueResolved(i));</span>
            } else {
<span class="nc" id="L2788">                throw reader.unexpectedAttribute(i);</span>
            }
        }
<span class="pc bpc" id="L2791" title="1 of 4 branches missed.">        if (selector == null &amp;&amp; ! xmlVersion.isAtLeast(Version.VERSION_1_5)) {</span>
<span class="nc" id="L2792">            throw missingAttribute(reader, &quot;selector&quot;);</span>
<span class="pc bpc" id="L2793" title="3 of 6 branches missed.">        } else if (selector == null &amp;&amp; names == null &amp;&amp; xmlVersion.isAtLeast(Version.VERSION_1_5)) {</span>
<span class="nc" id="L2794">            throw xmlLog.atLeastOneCipherSuiteAttributeMustBeProvided(&quot;selector&quot;, &quot;names&quot;);</span>
        }
<span class="fc bfc" id="L2796" title="All 2 branches covered.">        if (selector == null) {</span>
<span class="fc" id="L2797">            selector = CipherSuiteSelector.openSslDefault(); // default cipher suites pre TLSv1.3</span>
        }
        // ELY-1917: The following lines should be added back when once we are ready to enable TLS 1.3 by default
        /*if ((names == null) &amp;&amp; xmlVersion.isAtLeast(Version.VERSION_1_5)) {
            names = CipherSuiteSelector.openSslDefaultCipherSuites(); // default cipher suites for TLSv1.3
        }*/
<span class="pc bpc" id="L2803" title="1 of 2 branches missed.">        if (reader.hasNext()) {</span>
<span class="fc" id="L2804">            final int tag = reader.nextTag();</span>
<span class="pc bpc" id="L2805" title="1 of 2 branches missed.">            if (tag == START_ELEMENT) {</span>
<span class="nc" id="L2806">                throw reader.unexpectedElement();</span>
<span class="pc bpc" id="L2807" title="1 of 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="fc" id="L2808">                return CipherSuiteSelector.aggregate(names, selector);</span>
            } else {
<span class="nc" id="L2810">                throw reader.unexpectedContent();</span>
            }
        }
<span class="nc" id="L2813">        throw reader.unexpectedDocumentEnd();</span>
    }

    /**
     * Parse an XML element of type {@code names} which yields a protocol selector from an XML reader.
     *
     * @param reader the XML stream reader
     * @return the parsed protocol selector
     * @throws ConfigXMLParseException if the resource failed to be parsed
     */
    static ProtocolSelector parseProtocolSelectorNamesType(ConfigurationXMLStreamReader reader) throws ConfigXMLParseException {
<span class="fc" id="L2824">        ProtocolSelector selector = ProtocolSelector.empty();</span>
<span class="fc bfc" id="L2825" title="All 2 branches covered.">        for (String name : parseNamesType(reader)) {</span>
<span class="fc" id="L2826">            selector = selector.add(name);</span>
        }
<span class="fc" id="L2828">        return selector;</span>
    }

    /**
     * Parse an XML element of type {@code module-ref-type} from an XML reader.
     *
     * @param reader the XML stream reader
     * @return the corresponding module name
     * @throws ConfigXMLParseException if the resource failed to be parsed or the module is not found
     */
    static String parseModuleRefType(ConfigurationXMLStreamReader reader) throws ConfigXMLParseException {
<span class="nc" id="L2839">        final int attributeCount = reader.getAttributeCount();</span>
<span class="nc" id="L2840">        String moduleName = null;</span>
<span class="nc bnc" id="L2841" title="All 2 branches missed.">        for (int i = 0; i &lt; attributeCount; i ++) {</span>
<span class="nc" id="L2842">            checkAttributeNamespace(reader, i);</span>
<span class="nc bnc" id="L2843" title="All 2 branches missed.">            if (reader.getAttributeLocalName(i).equals(&quot;module-name&quot;)) {</span>
<span class="nc" id="L2844">                moduleName = reader.getAttributeValueResolved(i);</span>
            } else {
<span class="nc" id="L2846">                throw reader.unexpectedAttribute(i);</span>
            }
        }

<span class="nc bnc" id="L2850" title="All 2 branches missed.">        if (reader.hasNext()) {</span>
<span class="nc" id="L2851">            final int tag = reader.nextTag();</span>
<span class="nc bnc" id="L2852" title="All 2 branches missed.">            if (tag == START_ELEMENT) {</span>
<span class="nc" id="L2853">                throw reader.unexpectedElement();</span>
<span class="nc bnc" id="L2854" title="All 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="nc" id="L2855">                return moduleName;</span>
            } else {
<span class="nc" id="L2857">                throw reader.unexpectedContent();</span>
            }
        }
<span class="nc" id="L2860">        throw reader.unexpectedDocumentEnd();</span>
    }


    /**
     * Parse an XML element of type {@code clear-password-type} from an XML reader.
     *
     * @param reader the XML stream reader
     * @return the clear password characters
     * @throws ConfigXMLParseException if the resource failed to be parsed or the module is not found
     */
    static ExceptionSupplier&lt;Password, ConfigXMLParseException&gt; parseClearPassword(ConfigurationXMLStreamReader reader, Supplier&lt;Provider[]&gt; providers) throws ConfigXMLParseException {
<span class="fc" id="L2872">        final int attributeCount = reader.getAttributeCount();</span>
<span class="fc" id="L2873">        char[] password = null;</span>
<span class="fc bfc" id="L2874" title="All 2 branches covered.">        for (int i = 0; i &lt; attributeCount; i ++) {</span>
<span class="fc" id="L2875">            checkAttributeNamespace(reader, i);</span>
<span class="pc bpc" id="L2876" title="1 of 2 branches missed.">            if (reader.getAttributeLocalName(i).equals(&quot;password&quot;)) {</span>
<span class="fc" id="L2877">                password = reader.getAttributeValueResolved(i).toCharArray();</span>
            } else {
<span class="nc" id="L2879">                throw reader.unexpectedAttribute(i);</span>
            }
        }
<span class="pc bpc" id="L2882" title="1 of 2 branches missed.">        if (password == null) {</span>
<span class="nc" id="L2883">            throw missingAttribute(reader, &quot;password&quot;);</span>
        }
<span class="pc bpc" id="L2885" title="1 of 2 branches missed.">        if (reader.hasNext()) {</span>
<span class="fc" id="L2886">            final int tag = reader.nextTag();</span>
<span class="pc bpc" id="L2887" title="1 of 2 branches missed.">            if (tag == START_ELEMENT) {</span>
<span class="nc" id="L2888">                throw reader.unexpectedElement();</span>
<span class="pc bpc" id="L2889" title="1 of 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="fc" id="L2890">                final XMLLocation location = reader.getLocation();</span>
<span class="fc" id="L2891">                final char[] finalPassword = password;</span>
<span class="fc" id="L2892">                return () -&gt; {</span>
                    try {
<span class="fc" id="L2894">                        PasswordFactory factory = PasswordFactory.getInstance(ClearPassword.ALGORITHM_CLEAR, providers);</span>
<span class="fc" id="L2895">                        return Assert.assertNotNull(factory.generatePassword(new ClearPasswordSpec(finalPassword)).castAs(ClearPassword.class));</span>
<span class="nc" id="L2896">                    } catch (InvalidKeySpecException | NoSuchAlgorithmException cause) {</span>
<span class="nc" id="L2897">                        throw xmlLog.xmlFailedToCreateCredential(location, cause);</span>
                    }
                };
            } else {
<span class="nc" id="L2901">                throw reader.unexpectedContent();</span>
            }
        }
<span class="nc" id="L2904">        throw reader.unexpectedDocumentEnd();</span>
    }

    /**
     * Parse an XML element of type {@code masked-password-type} from an XML reader.
     *
     * @param reader the XML stream reader
     * @return a {@link MaskedPassword} supplier
     * @throws ConfigXMLParseException if the resource failed to be parsed or the module is not found
     */
    static ExceptionSupplier&lt;Password, ConfigXMLParseException&gt; parseMaskedPassword(ConfigurationXMLStreamReader reader, Supplier&lt;Provider[]&gt; providers) throws ConfigXMLParseException {
<span class="fc" id="L2915">        final int attributeCount = reader.getAttributeCount();</span>
<span class="fc" id="L2916">        String algorithm = MaskedPassword.ALGORITHM_MASKED_MD5_DES;</span>
<span class="fc" id="L2917">        char[] initialKeyMaterial = &quot;somearbitrarycrazystringthatdoesnotmatter&quot;.toCharArray();</span>
<span class="fc" id="L2918">        int iterationCount = 0;</span>
<span class="fc" id="L2919">        byte[] salt = null;</span>
<span class="fc" id="L2920">        byte[] maskedPasswordBytes = null;</span>
<span class="fc" id="L2921">        byte[] initializationVector = null;</span>
<span class="fc bfc" id="L2922" title="All 2 branches covered.">        for (int i = 0; i &lt; attributeCount; i ++) {</span>
<span class="fc" id="L2923">            checkAttributeNamespace(reader, i);</span>
<span class="pc bpc" id="L2924" title="1 of 7 branches missed.">            switch (reader.getAttributeLocalName(i)) {</span>
                case &quot;algorithm&quot;:
<span class="fc" id="L2926">                    algorithm = reader.getAttributeValueResolved(i);</span>
<span class="fc" id="L2927">                    break;</span>
                case &quot;key-material&quot;:
<span class="fc" id="L2929">                    initialKeyMaterial = reader.getAttributeValueResolved(i).toCharArray();</span>
<span class="fc" id="L2930">                    break;</span>
                case &quot;iteration-count&quot;:
<span class="fc" id="L2932">                    iterationCount = reader.getIntAttributeValueResolved(i, 1, Integer.MAX_VALUE);</span>
<span class="fc" id="L2933">                    break;</span>
                case &quot;salt&quot;:
<span class="fc" id="L2935">                    salt = CodePointIterator.ofString(reader.getAttributeValueResolved(i)).asUtf8().drain();</span>
<span class="fc" id="L2936">                    break;</span>
                case &quot;masked-password&quot;:
<span class="fc" id="L2938">                    maskedPasswordBytes = CodePointIterator.ofString(reader.getAttributeValueResolved(i)).base64Decode().drain();</span>
<span class="fc" id="L2939">                    break;</span>
                case &quot;initialization-vector&quot;:
<span class="fc" id="L2941">                    initializationVector = CodePointIterator.ofString(reader.getAttributeValueResolved(i)).base64Decode().drain();</span>
<span class="fc" id="L2942">                    break;</span>
                default:
<span class="nc" id="L2944">                    throw reader.unexpectedAttribute(i);</span>
            }
        }
<span class="pc bpc" id="L2947" title="1 of 2 branches missed.">        if (iterationCount == 0) throw missingAttribute(reader, &quot;iteration-count&quot;);</span>
<span class="pc bpc" id="L2948" title="1 of 2 branches missed.">        if (salt == null) throw missingAttribute(reader, &quot;salt&quot;);</span>
<span class="pc bpc" id="L2949" title="1 of 2 branches missed.">        if (maskedPasswordBytes == null) throw missingAttribute(reader, &quot;masked-password&quot;);</span>
<span class="pc bpc" id="L2950" title="1 of 2 branches missed.">        if (reader.hasNext()) {</span>
<span class="fc" id="L2951">            final int tag = reader.nextTag();</span>
<span class="pc bpc" id="L2952" title="1 of 2 branches missed.">            if (tag == START_ELEMENT) {</span>
<span class="nc" id="L2953">                throw reader.unexpectedElement();</span>
<span class="pc bpc" id="L2954" title="1 of 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="fc" id="L2955">                final XMLLocation location = reader.getLocation();</span>
<span class="pc bpc" id="L2956" title="1 of 2 branches missed.">                if (!MaskedPassword.isMaskedAlgorithm(algorithm)) {</span>
<span class="nc" id="L2957">                    throw xmlLog.xmlUnsupportedAlgorithmForType(location, algorithm, MaskedPassword.class.getSimpleName());</span>
                }
<span class="fc" id="L2959">                final String finalAlgorithm = algorithm;</span>
<span class="fc" id="L2960">                final MaskedPasswordSpec spec = new MaskedPasswordSpec(initialKeyMaterial, iterationCount, salt, maskedPasswordBytes, initializationVector);</span>
<span class="fc" id="L2961">                return () -&gt; {</span>
                    try {
<span class="fc" id="L2963">                        PasswordFactory factory = PasswordFactory.getInstance(finalAlgorithm, providers);</span>
<span class="fc" id="L2964">                        return Assert.assertNotNull(factory.generatePassword(spec).castAs(MaskedPassword.class));</span>
<span class="nc" id="L2965">                    } catch (InvalidKeySpecException | NoSuchAlgorithmException cause) {</span>
<span class="nc" id="L2966">                        throw xmlLog.xmlFailedToCreateCredential(location, cause);</span>
                    }
                };
            } else {
<span class="nc" id="L2970">                throw reader.unexpectedContent();</span>
            }
        }
<span class="nc" id="L2973">        throw reader.unexpectedDocumentEnd();</span>
    }




    static Map&lt;String, String&gt; parsePropertiesType(ConfigurationXMLStreamReader reader, final Version xmlVersion) throws ConfigXMLParseException {
<span class="nc bnc" id="L2980" title="All 2 branches missed.">        if (reader.getAttributeCount() &gt; 0) {</span>
<span class="nc" id="L2981">            throw reader.unexpectedAttribute(0);</span>
        }

<span class="nc" id="L2984">        Map&lt;String, String&gt; propertiesMap = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L2986" title="All 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="nc" id="L2987">            final int tag = reader.nextTag();</span>
<span class="nc bnc" id="L2988" title="All 2 branches missed.">            if (tag == START_ELEMENT) {</span>
<span class="nc" id="L2989">                checkElementNamespace(reader, xmlVersion);</span>
<span class="nc bnc" id="L2990" title="All 2 branches missed.">                switch (reader.getLocalName()) {</span>
                    case &quot;property&quot;:
<span class="nc" id="L2992">                        final int attributeCount = reader.getAttributeCount();</span>
<span class="nc" id="L2993">                        String key = null;</span>
<span class="nc" id="L2994">                        String value = null;</span>
<span class="nc bnc" id="L2995" title="All 2 branches missed.">                        for (int i = 0; i &lt; attributeCount; i++) {</span>
<span class="nc" id="L2996">                            checkAttributeNamespace(reader, i);</span>
<span class="nc bnc" id="L2997" title="All 3 branches missed.">                            switch (reader.getAttributeLocalName(i)) {</span>
                                case &quot;key&quot;:
<span class="nc bnc" id="L2999" title="All 2 branches missed.">                                    if (key != null)</span>
<span class="nc" id="L3000">                                        throw reader.unexpectedAttribute(i);</span>
<span class="nc" id="L3001">                                    key = reader.getAttributeValueResolved(i);</span>
<span class="nc" id="L3002">                                    break;</span>
                                case &quot;value&quot;:
<span class="nc bnc" id="L3004" title="All 2 branches missed.">                                    if (value != null)</span>
<span class="nc" id="L3005">                                        throw reader.unexpectedAttribute(i);</span>
<span class="nc" id="L3006">                                    value = reader.getAttributeValueResolved(i);</span>
<span class="nc" id="L3007">                                    break;</span>
                                default:
<span class="nc" id="L3009">                                    throw reader.unexpectedAttribute(i);</span>
                            }
                        }
<span class="nc bnc" id="L3012" title="All 2 branches missed.">                        if (key == null) {</span>
<span class="nc" id="L3013">                            throw missingAttribute(reader, &quot;key&quot;);</span>
                        }
<span class="nc bnc" id="L3015" title="All 2 branches missed.">                        if (value == null) {</span>
<span class="nc" id="L3016">                            throw missingAttribute(reader, &quot;value&quot;);</span>
                        }
<span class="nc" id="L3018">                        propertiesMap.put(key, value);</span>
<span class="nc bnc" id="L3019" title="All 2 branches missed.">                        if (reader.hasNext()) {</span>
<span class="nc" id="L3020">                            final int innerTag = reader.nextTag();</span>
<span class="nc bnc" id="L3021" title="All 2 branches missed.">                            if (innerTag == START_ELEMENT) {</span>
<span class="nc" id="L3022">                                throw reader.unexpectedElement();</span>
<span class="nc bnc" id="L3023" title="All 2 branches missed.">                            } else if (innerTag == END_ELEMENT) {</span>
                            } else {
<span class="nc" id="L3025">                                throw reader.unexpectedContent();</span>
                            }
<span class="nc" id="L3027">                        } else {</span>
<span class="nc" id="L3028">                            throw reader.unexpectedDocumentEnd();</span>
                        }

                        break;
                    default:
<span class="nc" id="L3033">                        throw reader.unexpectedElement();</span>
                }
<span class="nc bnc" id="L3035" title="All 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="nc" id="L3036">                return propertiesMap;</span>
            } else {
<span class="nc" id="L3038">                throw reader.unexpectedContent();</span>
            }
<span class="nc" id="L3040">        }</span>

<span class="nc" id="L3042">        throw reader.unexpectedDocumentEnd();</span>
    }

    /**
     * Parse an XML element of type {@code bearer-token-type} from an XML reader.
     *
     * @param reader the XML stream reader
     * @throws ConfigXMLParseException if the resource failed to be parsed
     */
    static BearerTokenCredential parseBearerTokenType(ConfigurationXMLStreamReader reader) throws ConfigXMLParseException {
<span class="nc" id="L3052">        String value = requireSingleAttribute(reader, &quot;value&quot;);</span>
<span class="nc bnc" id="L3053" title="All 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="nc" id="L3054">            final int tag = reader.nextTag();</span>
<span class="nc bnc" id="L3055" title="All 2 branches missed.">            if (tag == START_ELEMENT) {</span>
<span class="nc" id="L3056">                throw reader.unexpectedElement();</span>
<span class="nc bnc" id="L3057" title="All 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="nc" id="L3058">                return new BearerTokenCredential(value);</span>
            } else {
<span class="nc" id="L3060">                throw reader.unexpectedContent();</span>
            }
        }
<span class="nc" id="L3063">        throw reader.unexpectedDocumentEnd();</span>
    }

    /**
     * Parse an XML element of type {@code oauth2-bearer-token-type} from an XML reader.
     *
     * @param reader the XML stream reader
     * @param xmlVersion the version of parsed XML
     * @throws ConfigXMLParseException if the resource failed to be parsed
     */
    static ExceptionSupplier&lt;CredentialSource, ConfigXMLParseException&gt; parseOAuth2BearerTokenType(ConfigurationXMLStreamReader reader, final Map&lt;String, ExceptionSupplier&lt;CredentialStore, ConfigXMLParseException&gt;&gt; credentialStoresMap, final Version xmlVersion) throws ConfigXMLParseException {
<span class="nc" id="L3074">        URI tokenEndpointUri = requireSingleURIAttribute(reader, &quot;token-endpoint-uri&quot;);</span>
<span class="nc" id="L3075">        ExceptionSupplier&lt;OAuth2CredentialSource.Builder, ConfigXMLParseException&gt; builderSupplier = null;</span>
<span class="nc" id="L3076">        DeferredSupplier&lt;Provider[]&gt; providersSupplier = new DeferredSupplier&lt;&gt;(ProviderFactory.getElytronProviderSupplier(WildFlyElytronPasswordProvider.class.getClassLoader()));</span>
<span class="nc" id="L3077">        builderSupplier = () -&gt; {</span>
            try {
<span class="nc" id="L3079">                return OAuth2CredentialSource.builder(tokenEndpointUri.toURL());</span>
<span class="nc" id="L3080">            } catch (MalformedURLException e) {</span>
<span class="nc" id="L3081">                throw xmlLog.xmlInvalidUrl(tokenEndpointUri.toString());</span>
            }
        };
<span class="nc bnc" id="L3084" title="All 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="nc" id="L3085">            final int tag = reader.nextTag();</span>
<span class="nc bnc" id="L3086" title="All 2 branches missed.">            if (tag == START_ELEMENT) {</span>
<span class="nc" id="L3087">                checkElementNamespace(reader, xmlVersion);</span>
<span class="nc bnc" id="L3088" title="All 5 branches missed.">                switch (reader.getLocalName()) {</span>
                    case &quot;resource-owner-credentials&quot;: {
<span class="nc" id="L3090">                        builderSupplier = parseOAuth2ResourceOwnerCredentials(reader, builderSupplier, credentialStoresMap, xmlVersion);</span>
<span class="nc" id="L3091">                        break;</span>
                    }
                    case &quot;client-credentials&quot;: {
<span class="nc" id="L3094">                        builderSupplier = parseOAuth2ClientCredentials(reader, builderSupplier, credentialStoresMap, xmlVersion);</span>
<span class="nc" id="L3095">                        break;</span>
                    }
                    case &quot;masked-resource-owner-credentials&quot;: {
<span class="nc bnc" id="L3098" title="All 2 branches missed.">                        if (!xmlVersion.isAtLeast(Version.VERSION_1_4)) {</span>
<span class="nc" id="L3099">                            throw reader.unexpectedElement();</span>
                        }
<span class="nc" id="L3101">                        builderSupplier = parseOAuth2MaskedResourceOwnerCredentials(reader, builderSupplier, xmlVersion, providersSupplier);</span>
<span class="nc" id="L3102">                        break;</span>
                    }
                    case &quot;masked-client-credentials&quot;: {
<span class="nc bnc" id="L3105" title="All 2 branches missed.">                        if (!xmlVersion.isAtLeast(Version.VERSION_1_4)) {</span>
<span class="nc" id="L3106">                            throw reader.unexpectedElement();</span>
                        }
<span class="nc" id="L3108">                        builderSupplier = parseOAuth2MaskedClientCredentials(reader, builderSupplier, xmlVersion, providersSupplier);</span>
<span class="nc" id="L3109">                        break;</span>
                    }
<span class="nc" id="L3111">                    default: throw reader.unexpectedElement();</span>
                }
<span class="nc bnc" id="L3113" title="All 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="nc" id="L3114">                final ExceptionSupplier&lt;OAuth2CredentialSource.Builder, ConfigXMLParseException&gt; finalBuilderSupplier = builderSupplier;</span>
<span class="nc" id="L3115">                return () -&gt; finalBuilderSupplier.get().build();</span>
            } else {
<span class="nc" id="L3117">                throw reader.unexpectedContent();</span>
            }
<span class="nc" id="L3119">        }</span>
<span class="nc" id="L3120">        throw reader.unexpectedDocumentEnd();</span>
    }

    /**
     * Parse an XML element of type {@code oauth2-bearer-token-type} from an XML reader.
     *
     * @param reader the XML stream reader
     * @param builderSupplier the builder supplier
     * @throws ConfigXMLParseException if the resource failed to be parsed
     */
    static ExceptionSupplier&lt;OAuth2CredentialSource.Builder, ConfigXMLParseException&gt; parseOAuth2ResourceOwnerCredentials(ConfigurationXMLStreamReader reader, final ExceptionSupplier&lt;OAuth2CredentialSource.Builder, ConfigXMLParseException&gt; builderSupplier, final Map&lt;String, ExceptionSupplier&lt;CredentialStore, ConfigXMLParseException&gt;&gt; credentialStoresMap, Version xmlVersion) throws ConfigXMLParseException {
<span class="nc" id="L3131">        final int attributeCount = reader.getAttributeCount();</span>
<span class="nc" id="L3132">        ExceptionSupplier&lt;CredentialSource, ConfigXMLParseException&gt; credentialSourceSupplier = null;</span>
<span class="nc" id="L3133">        XMLLocation nestedLocation = null;</span>
<span class="nc" id="L3134">        String userName = null;</span>
<span class="nc" id="L3135">        String password = null;</span>
<span class="nc bnc" id="L3136" title="All 2 branches missed.">        for (int i = 0; i &lt; attributeCount; i ++) {</span>
<span class="nc" id="L3137">            checkAttributeNamespace(reader, i);</span>
<span class="nc bnc" id="L3138" title="All 3 branches missed.">            switch (reader.getAttributeLocalName(i)) {</span>
                case &quot;name&quot;: {
<span class="nc bnc" id="L3140" title="All 2 branches missed.">                    if (userName != null) throw reader.unexpectedAttribute(i);</span>
<span class="nc" id="L3141">                    userName = reader.getAttributeValueResolved(i);</span>
<span class="nc" id="L3142">                    break;</span>
                }
                case &quot;password&quot;: {
<span class="nc bnc" id="L3145" title="All 2 branches missed.">                    if (password != null) throw reader.unexpectedAttribute(i);</span>
<span class="nc" id="L3146">                    password = reader.getAttributeValueResolved(i);</span>
<span class="nc" id="L3147">                    break;</span>
                }
<span class="nc" id="L3149">                default: throw reader.unexpectedAttribute(i);</span>
            }
        }
<span class="nc bnc" id="L3152" title="All 2 branches missed.">        if (userName == null) throw reader.missingRequiredAttribute(xmlVersion.namespace, &quot;name&quot;);</span>
<span class="nc bnc" id="L3153" title="All 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="nc" id="L3154">            final int tag = reader.nextTag();</span>
<span class="nc bnc" id="L3155" title="All 2 branches missed.">            if (tag == START_ELEMENT) {</span>
<span class="nc" id="L3156">                checkElementNamespace(reader, xmlVersion);</span>
<span class="nc bnc" id="L3157" title="All 2 branches missed.">                if (!xmlVersion.isAtLeast(Version.VERSION_1_1)) {</span>
<span class="nc" id="L3158">                   throw reader.unexpectedElement();</span>
                }
<span class="nc bnc" id="L3160" title="All 2 branches missed.">                if (&quot;credential-store-reference&quot;.equals(reader.getLocalName())) {</span>
<span class="nc bnc" id="L3161" title="All 2 branches missed.">                    if (password != null) {</span>
<span class="nc" id="L3162">                        throw reader.unexpectedElement();</span>
                    }
<span class="nc bnc" id="L3164" title="All 2 branches missed.">                    if (credentialSourceSupplier != null) { // must not throw because compatibility</span>
<span class="nc" id="L3165">                        xmlLog.trace(&quot;Multiple credential-store-references in resource-owner-credentials - only the last one used!&quot;);</span>
                    }
<span class="nc" id="L3167">                    nestedLocation = reader.getLocation();</span>
<span class="nc" id="L3168">                    credentialSourceSupplier = parseCredentialStoreRefType(reader, credentialStoresMap);</span>
                } else {
<span class="nc" id="L3170">                    throw reader.unexpectedElement();</span>
                }
<span class="nc bnc" id="L3172" title="All 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="nc" id="L3173">                final String finalUserName = userName;</span>
<span class="nc bnc" id="L3174" title="All 2 branches missed.">                if (password != null) {</span>
<span class="nc" id="L3175">                    final String finalPassword = password;</span>
<span class="nc" id="L3176">                    return () -&gt; builderSupplier.get().useResourceOwnerPassword(finalUserName, finalPassword);</span>
                }
<span class="nc bnc" id="L3178" title="All 2 branches missed.">                if (credentialSourceSupplier != null) {</span>
<span class="nc" id="L3179">                    final XMLLocation finalLocation = nestedLocation;</span>
<span class="nc" id="L3180">                    final ExceptionSupplier&lt;CredentialSource, ConfigXMLParseException&gt; finalCredentialSourceSupplier = credentialSourceSupplier;</span>
<span class="nc" id="L3181">                    return () -&gt; {</span>
                        try {
<span class="nc" id="L3183">                            PasswordCredential passwordCredential = finalCredentialSourceSupplier.get().getCredential(PasswordCredential.class);</span>
<span class="nc bnc" id="L3184" title="All 2 branches missed.">                            if (passwordCredential == null) {</span>
<span class="nc" id="L3185">                                throw new ConfigXMLParseException(xmlLog.couldNotObtainCredential(), reader);</span>
                            }
<span class="nc" id="L3187">                            char[] pass = passwordCredential.getPassword().castAndApply(ClearPassword.class, ClearPassword::getPassword);</span>
<span class="nc bnc" id="L3188" title="All 2 branches missed.">                            if (pass == null) {</span>
<span class="nc" id="L3189">                                throw new ConfigXMLParseException(xmlLog.couldNotObtainCredential(), reader);</span>
                            }
<span class="nc" id="L3191">                            String finalPassword = String.valueOf(pass);</span>
<span class="nc" id="L3192">                            return builderSupplier.get().useResourceOwnerPassword(finalUserName, finalPassword);</span>
<span class="nc" id="L3193">                        } catch (IOException e) {</span>
<span class="nc" id="L3194">                            throw xmlLog.xmlFailedToCreateCredential(finalLocation, e);</span>
                        }
                    };
                }
<span class="nc" id="L3198">                throw reader.missingRequiredAttribute(xmlVersion.namespace, &quot;password&quot;);</span>
            } else {
<span class="nc" id="L3200">                throw reader.unexpectedContent();</span>
            }
<span class="nc" id="L3202">        }</span>
<span class="nc" id="L3203">        throw reader.unexpectedDocumentEnd();</span>
    }

    /**
     * Parse an XML element of type {@code oauth2-client-credentials-type} from an XML reader.
     *
     * @param reader the XML stream reader
     * @param builderSupplier the builder supplier
     * @throws ConfigXMLParseException if the resource failed to be parsed
     */
    static ExceptionSupplier&lt;OAuth2CredentialSource.Builder, ConfigXMLParseException&gt; parseOAuth2ClientCredentials(ConfigurationXMLStreamReader reader, final ExceptionSupplier&lt;OAuth2CredentialSource.Builder, ConfigXMLParseException&gt; builderSupplier, final Map&lt;String, ExceptionSupplier&lt;CredentialStore, ConfigXMLParseException&gt;&gt; credentialStoresMap, Version xmlVersion) throws ConfigXMLParseException {
<span class="nc" id="L3214">        ExceptionSupplier&lt;CredentialSource, ConfigXMLParseException&gt; credentialSourceSupplier = null;</span>
<span class="nc" id="L3215">        XMLLocation nestedLocation = null;</span>
<span class="nc" id="L3216">        String id = null;</span>
<span class="nc" id="L3217">        String secret = null;</span>
<span class="nc bnc" id="L3218" title="All 2 branches missed.">        for (int i = 0; i &lt; reader.getAttributeCount(); i ++) {</span>
<span class="nc" id="L3219">            checkAttributeNamespace(reader, i);</span>
<span class="nc bnc" id="L3220" title="All 3 branches missed.">            switch (reader.getAttributeLocalName(i)) {</span>
                case &quot;client-id&quot;: {
<span class="nc bnc" id="L3222" title="All 2 branches missed.">                    if (id != null) throw reader.unexpectedAttribute(i);</span>
<span class="nc" id="L3223">                    id = reader.getAttributeValueResolved(i);</span>
<span class="nc" id="L3224">                    break;</span>
                }
                case &quot;client-secret&quot;: {
<span class="nc bnc" id="L3227" title="All 2 branches missed.">                    if (secret != null) throw reader.unexpectedAttribute(i);</span>
<span class="nc" id="L3228">                    secret = reader.getAttributeValueResolved(i);</span>
<span class="nc" id="L3229">                    break;</span>
                }
<span class="nc" id="L3231">                default: throw reader.unexpectedAttribute(i);</span>
            }
        }
<span class="nc bnc" id="L3234" title="All 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="nc" id="L3235">            final int tag = reader.nextTag();</span>
<span class="nc bnc" id="L3236" title="All 2 branches missed.">            if (tag == START_ELEMENT) {</span>
<span class="nc" id="L3237">                checkElementNamespace(reader, xmlVersion);</span>
<span class="nc bnc" id="L3238" title="All 2 branches missed.">                if (!xmlVersion.isAtLeast(Version.VERSION_1_1)) {</span>
<span class="nc" id="L3239">                    throw reader.unexpectedElement();</span>
                }
<span class="nc bnc" id="L3241" title="All 2 branches missed.">                if (&quot;credential-store-reference&quot;.equals(reader.getLocalName())) {</span>
<span class="nc bnc" id="L3242" title="All 2 branches missed.">                    if (secret != null) {</span>
<span class="nc" id="L3243">                        throw reader.unexpectedElement();</span>
                    }
<span class="nc bnc" id="L3245" title="All 2 branches missed.">                    if (credentialSourceSupplier != null) { // must not throw because compatibility</span>
<span class="nc" id="L3246">                        xmlLog.trace(&quot;Multiple credential-store-references in client-credentials - only the last one used!&quot;);</span>
                    }
<span class="nc" id="L3248">                    nestedLocation = reader.getLocation();</span>
<span class="nc" id="L3249">                    credentialSourceSupplier = parseCredentialStoreRefType(reader, credentialStoresMap);</span>
                } else {
<span class="nc" id="L3251">                    throw reader.unexpectedElement();</span>
                }
<span class="nc bnc" id="L3253" title="All 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="nc bnc" id="L3254" title="All 2 branches missed.">                if (id == null) throw reader.unexpectedContent();</span>
<span class="nc" id="L3255">                final String finalId = id;</span>
<span class="nc bnc" id="L3256" title="All 2 branches missed.">                if (secret != null) {</span>
<span class="nc" id="L3257">                    final String finalSecret = secret;</span>
<span class="nc" id="L3258">                    return () -&gt; builderSupplier.get().clientCredentials(finalId, finalSecret);</span>
                }
<span class="nc bnc" id="L3260" title="All 2 branches missed.">                if (credentialSourceSupplier != null) {</span>
<span class="nc" id="L3261">                    final XMLLocation finalLocation = nestedLocation;</span>
<span class="nc" id="L3262">                    final ExceptionSupplier&lt;CredentialSource, ConfigXMLParseException&gt; finalCredentialSourceSupplier = credentialSourceSupplier;</span>
<span class="nc" id="L3263">                    return () -&gt; {</span>
                        try {
<span class="nc" id="L3265">                            PasswordCredential passwordCredential = finalCredentialSourceSupplier.get().getCredential(PasswordCredential.class);</span>
<span class="nc bnc" id="L3266" title="All 2 branches missed.">                            if (passwordCredential == null) {</span>
<span class="nc" id="L3267">                                throw new ConfigXMLParseException(xmlLog.couldNotObtainCredential(), reader);</span>
                            }
<span class="nc" id="L3269">                            char[] pass = passwordCredential.getPassword().castAndApply(ClearPassword.class, ClearPassword::getPassword);</span>
<span class="nc bnc" id="L3270" title="All 2 branches missed.">                            if (pass == null) {</span>
<span class="nc" id="L3271">                                throw new ConfigXMLParseException(xmlLog.couldNotObtainCredential(), reader);</span>
                            }
<span class="nc" id="L3273">                            String finalPassword = String.valueOf(pass);</span>
<span class="nc" id="L3274">                            return builderSupplier.get().clientCredentials(finalId, finalPassword);</span>
<span class="nc" id="L3275">                        } catch (IOException e) {</span>
<span class="nc" id="L3276">                            throw xmlLog.xmlFailedToCreateCredential(finalLocation, e);</span>
                        }
                    };
                }
<span class="nc" id="L3280">                throw reader.unexpectedContent();</span>
            } else {
<span class="nc" id="L3282">                throw reader.unexpectedContent();</span>
            }
<span class="nc" id="L3284">        }</span>
<span class="nc" id="L3285">        throw reader.unexpectedDocumentEnd();</span>
    }

    /**
     * Parse an XML element of type {@code oauth2-bearer-token-type} from an XML reader.
     *
     * @param reader the XML stream reader
     * @param builderSupplier the builder supplier
     * @throws ConfigXMLParseException if the resource failed to be parsed
     */
    static ExceptionSupplier&lt;OAuth2CredentialSource.Builder, ConfigXMLParseException&gt; parseOAuth2MaskedResourceOwnerCredentials(ConfigurationXMLStreamReader reader, final ExceptionSupplier&lt;OAuth2CredentialSource.Builder, ConfigXMLParseException&gt; builderSupplier, Version xmlVersion, Supplier&lt;Provider[]&gt; providers) throws ConfigXMLParseException {
<span class="nc" id="L3296">        final int attributeCount = reader.getAttributeCount();</span>
<span class="nc" id="L3297">        XMLLocation nestedLocation = null;</span>
<span class="nc" id="L3298">        String userName = null;</span>
<span class="nc" id="L3299">        String password = null;</span>
<span class="nc bnc" id="L3300" title="All 2 branches missed.">        for (int i = 0; i &lt; attributeCount; i ++) {</span>
<span class="nc" id="L3301">            checkAttributeNamespace(reader, i);</span>
<span class="nc bnc" id="L3302" title="All 2 branches missed.">            if (&quot;name&quot;.equals(reader.getAttributeLocalName(i))) {</span>
<span class="nc bnc" id="L3303" title="All 2 branches missed.">                if (userName != null) throw reader.unexpectedAttribute(i);</span>
<span class="nc" id="L3304">                userName = reader.getAttributeValueResolved(i);</span>
<span class="nc" id="L3305">                break;</span>
            }
            else {
<span class="nc" id="L3308">                throw reader.unexpectedAttribute(i);</span>
            }
        }
<span class="nc bnc" id="L3311" title="All 2 branches missed.">        if (userName == null) throw reader.missingRequiredAttribute(xmlVersion.namespace, &quot;name&quot;);</span>
<span class="nc bnc" id="L3312" title="All 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="nc" id="L3313">            final int tag = reader.nextTag();</span>
<span class="nc bnc" id="L3314" title="All 2 branches missed.">            if (tag == START_ELEMENT) {</span>
<span class="nc" id="L3315">                checkElementNamespace(reader, xmlVersion);</span>
<span class="nc bnc" id="L3316" title="All 2 branches missed.">                if (&quot;masked-password&quot;.equals(reader.getLocalName())) {</span>
<span class="nc bnc" id="L3317" title="All 2 branches missed.">                    if (password != null) {</span>
<span class="nc" id="L3318">                        throw reader.unexpectedElement();</span>
                    }
<span class="nc" id="L3320">                    nestedLocation = reader.getLocation();</span>
<span class="nc" id="L3321">                    Password maskedPassword = parseMaskedPassword(reader, providers).get();</span>
                    try {
<span class="nc" id="L3323">                        final PasswordFactory passwordFactory = PasswordFactory.getInstance(maskedPassword.getAlgorithm(), providers);</span>
<span class="nc" id="L3324">                        final ClearPasswordSpec spec = passwordFactory.getKeySpec(maskedPassword, ClearPasswordSpec.class);</span>
<span class="nc" id="L3325">                        password = String.valueOf(spec.getEncodedPassword());</span>
<span class="nc" id="L3326">                    } catch (InvalidKeySpecException | NoSuchAlgorithmException cause) {</span>
<span class="nc" id="L3327">                        throw xmlLog.xmlFailedToCreateCredential(nestedLocation, cause);</span>
<span class="nc" id="L3328">                    }</span>
<span class="nc" id="L3329">                } else {</span>
<span class="nc" id="L3330">                    throw reader.unexpectedElement();</span>
                }
<span class="nc bnc" id="L3332" title="All 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="nc" id="L3333">                final String finalUserName = userName;</span>
<span class="nc bnc" id="L3334" title="All 2 branches missed.">                if (password != null) {</span>
<span class="nc" id="L3335">                    final String finalPassword = password;</span>
<span class="nc" id="L3336">                    return () -&gt; builderSupplier.get().useResourceOwnerPassword(finalUserName, finalPassword);</span>
                }
<span class="nc" id="L3338">                throw reader.missingRequiredAttribute(xmlVersion.namespace, &quot;password&quot;);</span>
            } else {
<span class="nc" id="L3340">                throw reader.unexpectedContent();</span>
            }
<span class="nc" id="L3342">        }</span>
<span class="nc" id="L3343">        throw reader.unexpectedDocumentEnd();</span>
    }

    /**
     * Parse an XML element of type {@code oauth2-client-credentials-type} from an XML reader.
     *
     * @param reader the XML stream reader
     * @param builderSupplier the builder supplier
     * @throws ConfigXMLParseException if the resource failed to be parsed
     */
    static ExceptionSupplier&lt;OAuth2CredentialSource.Builder, ConfigXMLParseException&gt; parseOAuth2MaskedClientCredentials(ConfigurationXMLStreamReader reader, final ExceptionSupplier&lt;OAuth2CredentialSource.Builder, ConfigXMLParseException&gt; builderSupplier, Version xmlVersion,Supplier&lt;Provider[]&gt; providers) throws ConfigXMLParseException {
<span class="nc" id="L3354">        XMLLocation nestedLocation = null;</span>
<span class="nc" id="L3355">        String id = null;</span>
<span class="nc" id="L3356">        String secret = null;</span>
<span class="nc bnc" id="L3357" title="All 2 branches missed.">        for (int i = 0; i &lt; reader.getAttributeCount(); i ++) {</span>
<span class="nc" id="L3358">            checkAttributeNamespace(reader, i);</span>
<span class="nc bnc" id="L3359" title="All 2 branches missed.">            if (&quot;client-id&quot;.equals(reader.getAttributeLocalName(i))) {</span>
<span class="nc bnc" id="L3360" title="All 2 branches missed.">                if (id != null) throw reader.unexpectedAttribute(i);</span>
<span class="nc" id="L3361">                id = reader.getAttributeValueResolved(i);</span>
<span class="nc" id="L3362">                break;</span>
            }
            else {
<span class="nc" id="L3365">                throw reader.unexpectedAttribute(i);</span>
            }
        }
<span class="nc bnc" id="L3368" title="All 2 branches missed.">        while (reader.hasNext()) {</span>
<span class="nc" id="L3369">            final int tag = reader.nextTag();</span>
<span class="nc bnc" id="L3370" title="All 2 branches missed.">            if (tag == START_ELEMENT) {</span>
<span class="nc" id="L3371">                checkElementNamespace(reader, xmlVersion);</span>
<span class="nc bnc" id="L3372" title="All 2 branches missed.">                if (&quot;masked-client-secret&quot;.equals(reader.getLocalName())) {</span>
<span class="nc bnc" id="L3373" title="All 2 branches missed.">                    if (secret != null) {</span>
<span class="nc" id="L3374">                        throw reader.unexpectedElement();</span>
                    }
<span class="nc" id="L3376">                    nestedLocation = reader.getLocation();</span>
<span class="nc" id="L3377">                    Password maskedPassword = parseMaskedPassword(reader, providers).get();</span>
                    try {
<span class="nc" id="L3379">                        final PasswordFactory passwordFactory = PasswordFactory.getInstance(maskedPassword.getAlgorithm(), providers);</span>
<span class="nc" id="L3380">                        final ClearPasswordSpec spec = passwordFactory.getKeySpec(maskedPassword, ClearPasswordSpec.class);</span>
<span class="nc" id="L3381">                        secret = String.valueOf(spec.getEncodedPassword());</span>
<span class="nc" id="L3382">                    } catch (InvalidKeySpecException | NoSuchAlgorithmException cause) {</span>
<span class="nc" id="L3383">                        throw xmlLog.xmlFailedToCreateCredential(nestedLocation, cause);</span>
<span class="nc" id="L3384">                    }</span>
<span class="nc" id="L3385">                } else {</span>
<span class="nc" id="L3386">                    throw reader.unexpectedElement();</span>
                }
<span class="nc bnc" id="L3388" title="All 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="nc bnc" id="L3389" title="All 2 branches missed.">                if (id == null) throw reader.unexpectedContent();</span>
<span class="nc" id="L3390">                final String finalId = id;</span>
<span class="nc bnc" id="L3391" title="All 2 branches missed.">                if (secret != null) {</span>
<span class="nc" id="L3392">                    final String finalSecret = secret;</span>
<span class="nc" id="L3393">                    return () -&gt; builderSupplier.get().clientCredentials(finalId, finalSecret);</span>
                }
<span class="nc" id="L3395">                throw reader.unexpectedContent();</span>
            } else {
<span class="nc" id="L3397">                throw reader.unexpectedContent();</span>
            }
<span class="nc" id="L3399">        }</span>
<span class="nc" id="L3400">        throw reader.unexpectedDocumentEnd();</span>
    }

    /**
     * Parse an XML element of type {@code local-kerberos-type} from an XML reader.
     *
     * @param reader the XML stream reader
     * @return the clear password characters
     * @throws ConfigXMLParseException if the resource failed to be parsed or the module is not found
     */
    static CredentialSource parseLocalKerberos(ConfigurationXMLStreamReader reader) throws ConfigXMLParseException {
<span class="nc" id="L3411">        final int attributeCount = reader.getAttributeCount();</span>
<span class="nc" id="L3412">        List&lt;Oid&gt; mechanismOids = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L3413" title="All 2 branches missed.">        for (int i = 0; i &lt; attributeCount; i ++) {</span>
<span class="nc" id="L3414">            checkAttributeNamespace(reader, i);</span>
<span class="nc bnc" id="L3415" title="All 2 branches missed.">            if (reader.getAttributeLocalName(i).equals(&quot;mechanism-names&quot;)) {</span>
<span class="nc bnc" id="L3416" title="All 2 branches missed.">                for (String name : reader.getListAttributeValueAsArrayResolved(i)) {</span>
<span class="nc" id="L3417">                    String oid = OidsUtil.attributeNameToOid(OidsUtil.Category.GSS, name);</span>
<span class="nc bnc" id="L3418" title="All 2 branches missed.">                    if (oid == null) {</span>
<span class="nc" id="L3419">                        throw xmlLog.xmlInvalidGssMechanismName(reader, name);</span>
                    }
                    try {
<span class="nc" id="L3422">                        mechanismOids.add(new Oid(oid));</span>
<span class="nc" id="L3423">                    } catch (GSSException e) {</span>
<span class="nc" id="L3424">                        throw xmlLog.xmlGssMechanismOidConversionFailed(reader, oid, e);</span>
<span class="nc" id="L3425">                    }</span>
                }
<span class="nc bnc" id="L3427" title="All 2 branches missed.">            } else if (reader.getAttributeLocalName(i).equals(&quot;mechanism-oids&quot;)) {</span>
<span class="nc bnc" id="L3428" title="All 2 branches missed.">                for (String oid : reader.getListAttributeValueAsArrayResolved(i)) {</span>
                    try {
<span class="nc" id="L3430">                        mechanismOids.add(new Oid(oid));</span>
<span class="nc" id="L3431">                    } catch (GSSException e) {</span>
<span class="nc" id="L3432">                        throw xmlLog.xmlGssMechanismOidConversionFailed(reader, oid, e);</span>
<span class="nc" id="L3433">                    }</span>
                }
            } else {
<span class="nc" id="L3436">                throw reader.unexpectedAttribute(i);</span>
            }
        }
<span class="nc bnc" id="L3439" title="All 2 branches missed.">        if (mechanismOids.size() == 0) {</span>
<span class="nc" id="L3440">            mechanismOids.add(GSSCredentialSecurityFactory.KERBEROS_V5);</span>
<span class="nc" id="L3441">            mechanismOids.add(GSSCredentialSecurityFactory.SPNEGO);</span>
        }
<span class="nc bnc" id="L3443" title="All 2 branches missed.">        if (reader.hasNext()) {</span>
<span class="nc" id="L3444">            final int tag = reader.nextTag();</span>
<span class="nc bnc" id="L3445" title="All 2 branches missed.">            if (tag == START_ELEMENT) {</span>
<span class="nc" id="L3446">                throw reader.unexpectedElement();</span>
<span class="nc bnc" id="L3447" title="All 2 branches missed.">            } else if (tag == END_ELEMENT) {</span>
<span class="nc" id="L3448">                return LocalKerberosCredentialSource.builder().setMechanismOids(mechanismOids.toArray(new Oid[mechanismOids.size()])).build();</span>
            } else {
<span class="nc" id="L3450">                throw reader.unexpectedContent();</span>
            }
        }
<span class="nc" id="L3453">        throw reader.unexpectedDocumentEnd();</span>
    }

    // util

    private static String checkGetElementNamespace(final ConfigurationXMLStreamReader reader) throws ConfigXMLParseException {
<span class="fc" id="L3459">        String namespaceUri = reader.getNamespaceURI();</span>
<span class="pc bpc" id="L3460" title="1 of 2 branches missed.">        if (! KNOWN_NAMESPACES.containsKey(namespaceUri)) {</span>
<span class="nc" id="L3461">            throw reader.unexpectedElement();</span>
        }
<span class="fc" id="L3463">        return namespaceUri;</span>
    }

    private static void checkElementNamespace(final ConfigurationXMLStreamReader reader, final Version xmlVersion) throws ConfigXMLParseException {
<span class="pc bpc" id="L3467" title="1 of 2 branches missed.">        if (! xmlVersion.namespace.equals(reader.getNamespaceURI())) {</span>
<span class="nc" id="L3468">            throw reader.unexpectedElement();</span>
        }
<span class="fc" id="L3470">    }</span>

    private static void checkAttributeNamespace(final ConfigurationXMLStreamReader reader, final int idx) throws ConfigXMLParseException {
<span class="fc" id="L3473">        final String attributeNamespace = reader.getAttributeNamespace(idx);</span>
<span class="pc bpc" id="L3474" title="3 of 4 branches missed.">        if (attributeNamespace != null &amp;&amp; ! attributeNamespace.isEmpty()) {</span>
<span class="nc" id="L3475">            throw reader.unexpectedAttribute(idx);</span>
        }
<span class="fc" id="L3477">    }</span>

    private static void requireNoAttributes(final ConfigurationXMLStreamReader reader) throws ConfigXMLParseException {
<span class="fc" id="L3480">        final int attributeCount = reader.getAttributeCount();</span>
<span class="pc bpc" id="L3481" title="1 of 2 branches missed.">        if (attributeCount &gt; 0) {</span>
<span class="nc" id="L3482">            throw reader.unexpectedAttribute(0);</span>
        }
<span class="fc" id="L3484">    }</span>

    private static String requireSingleAttribute(final ConfigurationXMLStreamReader reader, final String attributeName) throws ConfigXMLParseException {
<span class="fc" id="L3487">        return requireSingleAttribute(reader, attributeName, (ExceptionSupplier&lt;String, ConfigXMLParseException&gt;) () -&gt; reader.getAttributeValueResolved(0));</span>
    }

    private static URI requireSingleURIAttribute(final ConfigurationXMLStreamReader reader, final String attributeName) throws ConfigXMLParseException {
<span class="nc" id="L3491">        return requireSingleAttribute(reader, attributeName, () -&gt; reader.getURIAttributeValueResolved(0));</span>
    }

    private static &lt;A&gt; A requireSingleAttribute(final ConfigurationXMLStreamReader reader, final String attributeName, ExceptionSupplier&lt;A, ConfigXMLParseException&gt; attributeFunction) throws ConfigXMLParseException {
<span class="fc" id="L3495">        final int attributeCount = reader.getAttributeCount();</span>
<span class="pc bpc" id="L3496" title="1 of 2 branches missed.">        if (attributeCount &lt; 1) {</span>
<span class="nc" id="L3497">            throw reader.missingRequiredAttribute(&quot;&quot;, attributeName);</span>
        }
<span class="fc" id="L3499">        checkAttributeNamespace(reader, 0);</span>
<span class="pc bpc" id="L3500" title="1 of 2 branches missed.">        if (! reader.getAttributeLocalName(0).equals(attributeName)) {</span>
<span class="nc" id="L3501">            throw reader.unexpectedAttribute(0);</span>
        }
<span class="pc bpc" id="L3503" title="1 of 2 branches missed.">        if (attributeCount &gt; 1) {</span>
<span class="nc" id="L3504">            throw reader.unexpectedAttribute(1);</span>
        }
<span class="fc" id="L3506">        return attributeFunction.get();</span>
    }

    private static ConfigXMLParseException missingAttribute(final ConfigurationXMLStreamReader reader, final String name) {
<span class="nc" id="L3510">        return reader.missingRequiredAttribute(null, name);</span>
    }

    private static ConfigXMLParseException invalidPortNumber(final ConfigurationXMLStreamReader reader, final int index) throws ConfigXMLParseException {
<span class="nc" id="L3514">        return xmlLog.xmlInvalidPortNumber(reader, reader.getAttributeValueResolved(index), reader.getAttributeLocalName(index), reader.getName());</span>
    }

    static final class KeyStoreCreateFactory implements ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt; {
        private final String providerName;
        private final Supplier&lt;Provider[]&gt; providers;
        private final String type;
        private final XMLLocation location;

<span class="fc" id="L3523">        KeyStoreCreateFactory(final Supplier&lt;Provider[]&gt; providers, final String providerName, final String type, final XMLLocation location) {</span>
<span class="fc" id="L3524">            this.providerName = providerName;</span>
<span class="fc" id="L3525">            this.providers = providers;</span>
<span class="fc" id="L3526">            this.type = type;</span>
<span class="fc" id="L3527">            this.location = location;</span>
<span class="fc" id="L3528">        }</span>

        public KeyStore get() throws ConfigXMLParseException {
<span class="fc" id="L3531">            Provider provider = findProvider(providers, providerName, KeyStore.class, type);</span>
<span class="pc bpc" id="L3532" title="1 of 2 branches missed.">            if (provider == null) {</span>
<span class="nc" id="L3533">                throw xmlLog.xmlUnableToIdentifyProvider(location, providerName, &quot;KeyStore&quot;, type);</span>
            }
            try {
<span class="fc" id="L3536">                return KeyStore.getInstance(type, provider);</span>
<span class="nc" id="L3537">            } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L3538">                throw xmlLog.xmlFailedToCreateKeyStore(location, e);</span>
            }
        }
    }

    static final class UnknownTypeFileKeyStoreFactory implements ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt; {
        private final String providerName;
        private final Supplier&lt;Provider[]&gt; providers;
        private final XMLLocation location;
        protected final ExceptionSupplier&lt;char[], ConfigXMLParseException&gt; passwordFactory;
        private final String fileName;
        private final ExceptionSupplier&lt;InputStream, IOException&gt; resourceSupplier;
        private final URI uri;

<span class="fc" id="L3552">        UnknownTypeFileKeyStoreFactory(final Supplier&lt;Provider[]&gt; providers, final String providerName, final ExceptionSupplier&lt;char[], ConfigXMLParseException&gt; passwordFactory, final String fileName, final ExceptionSupplier&lt;InputStream, IOException&gt; resourceSupplier, final URI uri, final XMLLocation location) {</span>
<span class="fc" id="L3553">            this.providerName = providerName;</span>
<span class="fc" id="L3554">            this.providers = providers;</span>
<span class="fc" id="L3555">            this.location = location;</span>
<span class="fc" id="L3556">            this.passwordFactory = passwordFactory;</span>
<span class="fc" id="L3557">            this.fileName = fileName;</span>
<span class="fc" id="L3558">            this.resourceSupplier = resourceSupplier;</span>
<span class="fc" id="L3559">            this.uri = uri;</span>
<span class="fc" id="L3560">        }</span>

        @Override
        public KeyStore get() throws ConfigXMLParseException {
<span class="fc" id="L3564">            KeyStore keyStore = null;</span>
<span class="fc" id="L3565">            FileInputStream fin = null;</span>
            try {
<span class="pc bpc" id="L3567" title="1 of 2 branches missed.">                if (fileName != null) {</span>
<span class="fc" id="L3568">                    fin = new FileInputStream(fileName);</span>
<span class="nc bnc" id="L3569" title="All 2 branches missed.">                } else if (resourceSupplier != null) {</span>
<span class="nc" id="L3570">                    InputStream is = resourceSupplier.get();</span>
<span class="nc bnc" id="L3571" title="All 2 branches missed.">                    if (is instanceof FileInputStream) {</span>
<span class="nc" id="L3572">                        fin = (FileInputStream) is;</span>
                    }
<span class="nc" id="L3574">                } else {</span>
<span class="nc" id="L3575">                    fin = new FileInputStream(uri.toURL().getFile());</span>
                }
<span class="fc" id="L3577">                keyStore = KeyStoreUtil.loadKeyStore(providers, providerName, fin, fileName, passwordFactory.get());</span>
<span class="nc" id="L3578">            } catch (Exception e) {</span>
<span class="nc" id="L3579">                throw xmlLog.xmlFailedToCreateKeyStore(location, e);</span>
            } finally {
<span class="fc" id="L3581">                safeClose(fin);</span>
            }
<span class="fc" id="L3583">            return keyStore;</span>
        }

        private static void safeClose(Closeable c) {
<span class="pc bpc" id="L3587" title="1 of 2 branches missed.">            if (c != null) {</span>
                try {
<span class="fc" id="L3589">                    c.close();</span>
<span class="pc" id="L3590">                } catch (Throwable ignored) {}</span>
            }
<span class="fc" id="L3592">        }</span>
    }

    static final class PasswordKeyStoreFactory implements ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt; {
        private final ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt; delegateFactory;

<span class="nc" id="L3598">        PasswordKeyStoreFactory(final ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt; delegateFactory) {</span>
<span class="nc" id="L3599">            this.delegateFactory = delegateFactory;</span>
<span class="nc" id="L3600">        }</span>

        public KeyStore get() throws ConfigXMLParseException {
<span class="nc" id="L3603">            return new WrappingPasswordKeyStore(delegateFactory.get());</span>
        }
    }

    abstract static class AbstractLoadingKeyStoreFactory implements ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt; {

        protected final ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt; delegateFactory;
        protected final ExceptionSupplier&lt;char[], ConfigXMLParseException&gt; passwordFactory;
        protected final XMLLocation location;

<span class="fc" id="L3613">        protected AbstractLoadingKeyStoreFactory(final ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt; delegateFactory, final ExceptionSupplier&lt;char[], ConfigXMLParseException&gt; passwordFactory, final XMLLocation location) {</span>
<span class="fc" id="L3614">            this.delegateFactory = delegateFactory;</span>
<span class="fc" id="L3615">            this.passwordFactory = passwordFactory;</span>
<span class="fc" id="L3616">            this.location = location;</span>
<span class="fc" id="L3617">        }</span>

        public KeyStore get() throws ConfigXMLParseException {
            try {
<span class="fc" id="L3621">                KeyStore keyStore = delegateFactory.get();</span>
<span class="fc" id="L3622">                try (InputStream fis = createStream()) {</span>
<span class="pc bpc" id="L3623" title="1 of 2 branches missed.">                    keyStore.load(fis, passwordFactory == null ? null : passwordFactory.get());</span>
                }
<span class="fc" id="L3625">                return keyStore;</span>
<span class="nc" id="L3626">            } catch (GeneralSecurityException | IOException e) {</span>
<span class="nc" id="L3627">                throw xmlLog.xmlFailedToLoadKeyStoreData(location, e);</span>
            }
        }

        abstract InputStream createStream() throws IOException;
    }

    static final class FileLoadingKeyStoreFactory extends AbstractLoadingKeyStoreFactory {

        private final String fileName;

        FileLoadingKeyStoreFactory(final ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt; delegateFactory, final ExceptionSupplier&lt;char[], ConfigXMLParseException&gt; passwordFactory, final String fileName, final XMLLocation location) {
<span class="fc" id="L3639">            super(delegateFactory, passwordFactory, location);</span>
<span class="fc" id="L3640">            this.fileName = fileName;</span>
<span class="fc" id="L3641">        }</span>

        InputStream createStream() throws FileNotFoundException {
<span class="fc" id="L3644">            return new FileInputStream(fileName);</span>
        }
    }

    static final class ResourceLoadingKeyStoreFactory extends AbstractLoadingKeyStoreFactory {

        private final ExceptionSupplier&lt;InputStream, IOException&gt; resourceSupplier;

        ResourceLoadingKeyStoreFactory(final ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt; delegateFactory, final ExceptionSupplier&lt;char[], ConfigXMLParseException&gt; passwordFactory, final ExceptionSupplier&lt;InputStream, IOException&gt; resourceSupplier, final XMLLocation location) {
<span class="nc" id="L3653">            super(delegateFactory, passwordFactory, location);</span>
<span class="nc" id="L3654">            this.resourceSupplier = resourceSupplier;</span>
<span class="nc" id="L3655">        }</span>

        InputStream createStream() throws IOException {
<span class="nc" id="L3658">            return resourceSupplier.get();</span>
        }
    }

    static final class URILoadingKeyStoreFactory extends AbstractLoadingKeyStoreFactory {
        private final URI uri;

        URILoadingKeyStoreFactory(final ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt; delegateFactory, final ExceptionSupplier&lt;char[], ConfigXMLParseException&gt; passwordFactory, final URI uri, final XMLLocation location) {
<span class="nc" id="L3666">            super(delegateFactory, passwordFactory, location);</span>
<span class="nc" id="L3667">            this.uri = uri;</span>
<span class="nc" id="L3668">        }</span>

        InputStream createStream() throws IOException {
<span class="nc" id="L3671">            return uri.toURL().openStream();</span>
        }
    }

    static final class NullLoadingKeyStoreFactory extends AbstractLoadingKeyStoreFactory {

        NullLoadingKeyStoreFactory(final ExceptionSupplier&lt;KeyStore, ConfigXMLParseException&gt; delegateFactory, final ExceptionSupplier&lt;char[], ConfigXMLParseException&gt; passwordFactory, final XMLLocation location) {
<span class="nc" id="L3678">            super(delegateFactory, passwordFactory, location);</span>
<span class="nc" id="L3679">        }</span>

        @Override
        InputStream createStream() throws IOException {
<span class="nc" id="L3683">            return null;</span>
        }

    }

    static final class DeferredSupplier&lt;T&gt;  implements Supplier&lt;T&gt; {

        private volatile Supplier&lt;T&gt; supplier;
        private T value;

<span class="fc" id="L3693">        DeferredSupplier(Supplier&lt;T&gt; supplier) {</span>
<span class="fc" id="L3694">            checkNotNullParam(&quot;supplier&quot;, supplier);</span>
<span class="fc" id="L3695">            this.supplier = supplier;</span>
<span class="fc" id="L3696">        }</span>

        void setSupplier(Supplier&lt;T&gt; supplier) {
<span class="fc" id="L3699">            checkNotNullParam(&quot;supplier&quot;, supplier);</span>
<span class="fc" id="L3700">            this.supplier = supplier;</span>
<span class="fc" id="L3701">        }</span>

        @Override
        public T get() {
<span class="fc" id="L3705">            return supplier.get();</span>
        }

    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>